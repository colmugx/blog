<!DOCTYPE html><html lang="zh-CN"><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge, chrome=1"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1"><meta name="browsermode" content="application"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-title" content="Colmugx 's Blog"><meta name="apple-mobile-web-app-status-bar-style" content="default"><meta name="msapplication-navbutton-color" content="#666666"><meta name="format-detection" content="telephone=no"><link rel="apple-touch-icon" sizes="72x72" href="https://avatars2.githubusercontent.com/u/21327913?v=3&s=466"><link rel="apple-touch-icon-precomposed" sizes="72x72" href="https://avatars2.githubusercontent.com/u/21327913?v=3&s=466"><meta name="subtitle" content="让一切充满想象力"><meta name="description" content="Co1MugX Blog"><meta name="keywords" content="JavaScript, vue, nlvi"><link rel="apple-touch-startup-image" media="(device-width: 375px)" href="assets/apple-launch-1125x2436.png"><link rel="apple-touch-startup-image" media="(orientation: landscape)" href="assets/apple-touch-startup-image-2048x1496.png"><link rel="stylesheet" href="/blog/style/style.css"><script>var nlviconfig={title:"Colmugx 's Blog",author:"colmugx",baseUrl:"/blog/",theme:{scheme:"balance",lightbox:!0,animate:!0,search:!0,friends:!0,reward:!1,pjax:!0,lazy:!0,toc:!0}}</script><link rel="stylesheet" href="/blog/script/lib/lightbox/css/lightbox.min.css"><link rel="stylesheet" href="/blog/syuanpi/syuanpi.min.css"><link rel="icon" href="https://avatars2.githubusercontent.com/u/21327913?v=3&s=466"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml"><script async src="https://www.googletagmanager.com/gtag/js?id=UA-98059014-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-98059014-1")</script><style>@font-face{font-family:Allura;src:url(/blog/font/allura/allura.ttf)}</style><title>使用JSX的VUE应用开发体验 · Colmugx 's Blog</title></head><body><div class="container"><header class="header" id="header"><div class="header-wrapper"><div class="logo"><div class="logo-inner syuanpi tvIn" style="display:none"><h1><a href="/blog/">Colmugx 's Blog</a></h1><span id="subtitle">让一切充满想象力</span></div></div><nav class="main-nav"><ul class="main-nav-list syuanpi tvIn"><li class="menu-item"><a href="javascript:;" id="search-btn" aria-label="Search"><i class="iconfont icon-search"></i></a></li><li class="menu-item"><a href="/blog/" id="article"><span class="base-name">ARTICLE</span></a></li><li class="menu-item"><a href="/blog/archives" id="archives"><span class="base-name">ARCHIVES</span></a></li><li class="menu-item"><a href="javascript:;" id="tags"><span class="base-name">TAGS</span></a></li><li class="menu-item"><a href="/blog/about" id="about"><span class="base-name">ABOUT</span></a></li><li class="menu-item"><a href="/blog/rss.xml" id="rss"><span class="base-name">RSS</span></a></li><li class="menu-item"><a href="javascript:;" id="switch-toc">文章导航</a></li></ul></nav></div></header><div class="mobile-header" id="mobile-header"><div class="mobile-header-nav"><div class="mobile-header-item" id="mobile-left"><div class="header-menu-item"><div class="header-menu-line"></div></div></div><h1 class="mobile-header-title"><a href="/">Colmugx 's Blog</a></h1><div class="mobile-header-item"></div></div><div class="mobile-header-body"><ul class="mobile-header-list"><li class="mobile-nav-item syuanpi fadeInRightShort back-0"><a href="/blog/">ARTICLE</a></li><li class="mobile-nav-item syuanpi fadeInRightShort back-1"><a href="/blog/archives">ARCHIVES</a></li><li class="mobile-nav-item syuanpi fadeInRightShort back-2"><a href="javascript:;" id="mobile-tags">TAGS</a></li><li class="mobile-nav-item syuanpi fadeInRightShort back-3"><a href="/blog/about">ABOUT</a></li><li class="mobile-nav-item syuanpi fadeInRightShort back-4"><a href="/blog/rss.xml">RSS</a></li></ul></div></div><aside class="post-toc"><div class="title"><span>文章导航</span></div><div class="toc-inner"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#开局搭环境"><span class="toc-text">开局搭环境</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#装插件"><span class="toc-text">装插件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#正文"><span class="toc-text">正文</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#渲染元素"><span class="toc-text">渲染元素</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#函数式组件"><span class="toc-text">函数式组件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#JSX的一些小区别"><span class="toc-text">JSX的一些小区别</span></a></li></ol></div></aside><div class="container-inner" style="display:none"><main class="main" id="main"><div class="main-wrapper"><article class="post is_post"><header class="post-header"><div class="post-time syuanpi fadeInRightShort back-1"><div class="post-time-wrapper"><time>2017-12-11</time> <span class="post-category"><a href="/blog/categories/实践尝试/">实践尝试</a></span></div></div><h1 class="post-title syuanpi fadeInRightShort back-2">使用JSX的VUE应用开发体验</h1></header><div class="post-content syuanpi fadeInRightShort back-3"><blockquote><p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p></blockquote><p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p><a id="more"></a><h2 id="开局搭环境">开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p><h2 id="装插件">装插件</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">npm install\</span><br><span class="line">  babel-plugin-syntax-jsx\</span><br><span class="line">  babel-plugin-transform-vue-jsx\</span><br><span class="line">  babel-helper-vue-jsx-merge-props\</span><br><span class="line">  babel-preset-env\</span><br><span class="line">  --save-dev</span><br></pre></td></tr></table></figure><p><code>.babelrc</code>主要是这个</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"transform-vue-jsx"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p><h2 id="正文">正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p><h2 id="渲染元素">渲染元素</h2><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p><ol><li>它并不是哪个位置的方法都会有createElement函数的。</li><li>classes形式的组件找不到render函数！</li></ol><p>其实关于vue与jsx，tsx我是做了很多次尝试</p><p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  render(<span class="comment">/* h / createElement */</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello World <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p><p>优点：</p><ol><li>顺手，完全单文件中的<code>script</code>标签</li><li>没了</li></ol><p>缺点：</p><ol><li>这么搞肯定容易眼花啊！</li><li>不好维护，不直观</li></ol><p>第二种，如果是这种结构的tsx的话，与jsx同理。</p><p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;h1&gt;Hello World&lt;/h1&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  @Component</span><br><span class="line">  export default class MainClass extends Vue &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure><p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p><p>好了关键的来了…</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="class"><span class="keyword">class</span> <span class="title">MainClass</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">get</span> render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span> Hello World <span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// render or template not defind.</span></span><br></pre></td></tr></table></figure><p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p><p>官方在自动注入这方面有一个栗子的</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Vue.component(<span class="string">'jsx-example'</span>, &#123;</span><br><span class="line">  render () &#123; <span class="comment">// h will be injected</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  myMethod: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="comment">// h will not be injected</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;,</span><br><span class="line">  someOtherMethod: <span class="function"><span class="params">()</span> =&gt;</span> &#123; <span class="comment">// h will not be injected</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">@Component</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">Vue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> computed () &#123; <span class="comment">// h will be injected</span></span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"foo"</span>&gt;</span>bar<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p><p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p><p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params">h, args</span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p><h2 id="函数式组件">函数式组件</h2><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  functional: <span class="literal">true</span>,</span><br><span class="line"></span><br><span class="line">  render() &#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p><p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p><p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p><blockquote><ul><li><code>props</code>：提供 props 的对象</li><li><code>children</code>: VNode 子节点的数组</li><li><code>slots</code>: slots 对象</li><li><code>data</code>：传递给组件的 data 对象</li><li><code>parent</code>：对父组件的引用</li><li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li><li><code>injections</code>: (2.3.0+) 如果使用了 <a href="https://cn.vuejs.org/v2/api/#provide-inject" target="_blank" rel="noopener"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li></ul></blockquote><h2 id="JSX的一些小区别">JSX的一些小区别</h2><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p><p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p><p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p><p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p></div><div class="post-tags syuanpi fadeInRightShort back-3"><a href="/blog/tags/JavaScript/">JavaScript</a> <a href="/blog/tags/vue/">vue</a></div><hr class="copy-line"><div class="post-copyright"><div class="copy-author"><span>作者 :</span> <span>colmugx</span></div><div class="copy-url"><span>地址 :</span> <a href="https://colmugx.github.io/blog/2017/12/11/vue-jsx/">https://colmugx.github.io/blog/2017/12/11/vue-jsx/</a></div><div class="copy-origin"><span>来源 :</span> <a href="https://colmugx.github.io/blog">https://colmugx.github.io/blog</a></div><div class="copy-license">著作权归作者所有，转载请联系作者获得授权。</div></div></article><nav class="article-page"><a href="/blog/2017/12/20/exchange_number/" id="art-left" class="art-left"><span class="next-title"><i class="iconfont icon-left"></i>冒泡排序的骚思路 </span></a><a href="/blog/2017/12/07/about-currying/" id="art-right" class="art-right"><span class="prev-title">扯扯柯里化<i class="iconfont icon-right"></i></span></a></nav><i id="com-switch" class="iconfont icon-down jumping-in long infinite" style="font-size:24px;display:block;text-align:center;transform:rotate(180deg)"></i><div class="post-comments" id="post-comments" style="display:block;margin:auto 16px"><div id="disqus_thread"><noscript>Please enable JavaScript to view the <a href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript></div><script type="text/javascript">var disqus_shortname="co1mugxs-blog";!function(){var e=document.createElement("script");e.type="text/javascript",e.async=!0,e.src="//"+disqus_shortname+".disqus.com/embed.js",(document.getElementsByTagName("head")[0]||document.getElementsByTagName("body")[0]).appendChild(e)}()</script></div></div></main><footer class="footer syuanpi fadeIn" id="footer"><hr><div class="footer-wrapper"><div class="left"><div class="contact-icon"><a href="https://www.zhihu.com/people/colmugx" class="iconfont icon-zhihu" title="zhihu"></a> <a href="https://github.com/colmugx" class="iconfont icon-github" title="github"></a></div></div><div class="right"><div class="copyright"><div class="info"><span>&copy;</span> <span>2016 ~ 2020</span> <span>❤</span> <span>colmugx</span></div><div class="theme"><span>动力来源于 <a href="http://hexo.io/" target="_blank" rel="noopener">Hexo </a></span><span>主题 <a href="https://github.com/ColMugX/hexo-theme-Nlvi">Nlvi</a></span></div></div></div></div></footer></div><div class="tagcloud" id="tagcloud"><div class="tagcloud-taglist"><div class="tagcloud-tag"><button>JavaScript</button></div><div class="tagcloud-tag"><button>nlvi</button></div><div class="tagcloud-tag"><button>colmugx</button></div><div class="tagcloud-tag"><button>vue</button></div><div class="tagcloud-tag"><button>electron</button></div><div class="tagcloud-tag"><button>docker</button></div><div class="tagcloud-tag"><button>Functional Programming</button></div><div class="tagcloud-tag"><button>TypeScript</button></div><div class="tagcloud-tag"><button>weapp</button></div><div class="tagcloud-tag"><button>hammerspoon</button></div><div class="tagcloud-tag"><button>typescript</button></div><div class="tagcloud-tag"><button>vim</button></div><div class="tagcloud-tag"><button>react</button></div><div class="tagcloud-tag"><button>Redux</button></div><div class="tagcloud-tag"><button>Syuanpi</button></div><div class="tagcloud-tag"><button>CSS</button></div><div class="tagcloud-tag"><button>rust</button></div><div class="tagcloud-tag"><button>actix</button></div><div class="tagcloud-tag"><button>swift</button></div><div class="tagcloud-tag"><button>vuex</button></div></div><div class="tagcloud-postlist active"><h2>JavaScript</h2><div class="tagcloud-post"><a href="/blog/2017/08/09/about-conditionals/"><time class="tagcloud-posttime">2017 / 08 / 09</time> <span>关于Javascript的条件判断</span></a></div><div class="tagcloud-post"><a href="/blog/2017/12/07/about-currying/"><time class="tagcloud-posttime">2017 / 12 / 07</time> <span>扯扯柯里化</span></a></div><div class="tagcloud-post"><a href="/blog/2019/03/02/about-redux/"><time class="tagcloud-posttime">2019 / 03 / 02</time> <span>看过 Redux 之后，我写了一个不负责任的状态管理</span></a></div><div class="tagcloud-post"><a href="/blog/2017/02/17/async-await-first/"><time class="tagcloud-posttime">2017 / 02 / 17</time> <span>async-await 初尝试</span></a></div><div class="tagcloud-post"><a href="/blog/2018/07/04/different-function/"><time class="tagcloud-posttime">2018 / 07 / 04</time> <span>我就写个方法，这么麻烦？</span></a></div><div class="tagcloud-post"><a href="/blog/2018/03/12/dji-interview/"><time class="tagcloud-posttime">2018 / 03 / 12</time> <span>关于四轴的踩坑指南</span></a></div><div class="tagcloud-post"><a href="/blog/2017/12/20/exchange_number/"><time class="tagcloud-posttime">2017 / 12 / 20</time> <span>冒泡排序的骚思路</span></a></div><div class="tagcloud-post"><a href="/blog/2017/08/14/js-call-apply-bind/"><time class="tagcloud-posttime">2017 / 08 / 14</time> <span>JavaScript的call，bind，apply</span></a></div><div class="tagcloud-post"><a href="/blog/2017/11/20/js-console/"><time class="tagcloud-posttime">2017 / 11 / 20</time> <span>你还在用Console.log()？</span></a></div><div class="tagcloud-post"><a href="/blog/2017/02/22/js-extends/"><time class="tagcloud-posttime">2017 / 02 / 22</time> <span>来搞一手关于Javascript对象继承</span></a></div><div class="tagcloud-post"><a href="/blog/2017/03/02/js-for/"><time class="tagcloud-posttime">2017 / 03 / 02</time> <span>JavaScript所有for</span></a></div><div class="tagcloud-post"><a href="/blog/2017/12/23/js-method-chaining/"><time class="tagcloud-posttime">2017 / 12 / 23</time> <span>JavaScript链式方法</span></a></div><div class="tagcloud-post"><a href="/blog/2017/03/03/js-this/"><time class="tagcloud-posttime">2017 / 03 / 03</time> <span>关于JavaScript的this</span></a></div><div class="tagcloud-post"><a href="/blog/2018/02/28/promise-chaining/"><time class="tagcloud-posttime">2018 / 02 / 28</time> <span>promise链式调用</span></a></div><div class="tagcloud-post"><a href="/blog/2019/05/28/react-component-method/"><time class="tagcloud-posttime">2019 / 05 / 28</time> <span>react函数级写法和继承写法有什么区别？</span></a></div><div class="tagcloud-post"><a href="/blog/2017/10/17/reference-equal-pointer/"><time class="tagcloud-posttime">2017 / 10 / 17</time> <span>引用等于指针吗？</span></a></div><div class="tagcloud-post"><a href="/blog/2018/01/04/replace-space/"><time class="tagcloud-posttime">2018 / 01 / 04</time> <span>剑指Offer —— 替换空格</span></a></div><div class="tagcloud-post"><a href="/blog/2017/12/11/vue-jsx/"><time class="tagcloud-posttime">2017 / 12 / 11</time> <span>使用JSX的VUE应用开发体验</span></a></div><div class="tagcloud-post"><a href="/blog/2019/04/20/why-vue-proxy/"><time class="tagcloud-posttime">2019 / 04 / 20</time> <span>defineProperty? Proxy?</span></a></div><div class="tagcloud-post"><a href="/blog/2019/03/27/you-dont-know-let/"><time class="tagcloud-posttime">2019 / 03 / 27</time> <span>我今天给 let 安排了</span></a></div></div><div class="tagcloud-postlist"><h2>nlvi</h2><div class="tagcloud-post"><a href="/blog/2019/04/17/about-nlvi-pwa/"><time class="tagcloud-posttime">2019 / 04 / 17</time> <span>关于 Nlvi 「添加到桌面」</span></a></div><div class="tagcloud-post"><a href="/blog/2019/03/25/bye-nlvi/"><time class="tagcloud-posttime">2019 / 03 / 25</time> <span>最后的 Nlvi</span></a></div></div><div class="tagcloud-postlist"><h2>colmugx</h2><div class="tagcloud-post"><a href="/blog/2019/03/25/bye-nlvi/"><time class="tagcloud-posttime">2019 / 03 / 25</time> <span>最后的 Nlvi</span></a></div><div class="tagcloud-post"><a href="/blog/2018/07/12/kill-parentless-on-npm/"><time class="tagcloud-posttime">2018 / 07 / 12</time> <span>记在NPM抢空包名的经历</span></a></div></div><div class="tagcloud-postlist"><h2>vue</h2><div class="tagcloud-post"><a href="/blog/2018/03/12/dji-interview/"><time class="tagcloud-posttime">2018 / 03 / 12</time> <span>关于四轴的踩坑指南</span></a></div><div class="tagcloud-post"><a href="/blog/2017/08/22/do-markdown-hexo/"><time class="tagcloud-posttime">2017 / 08 / 22</time> <span>搞electron + vue + webpack2 + TypeScript什么体验</span></a></div><div class="tagcloud-post"><a href="/blog/2017/12/11/vue-jsx/"><time class="tagcloud-posttime">2017 / 12 / 11</time> <span>使用JSX的VUE应用开发体验</span></a></div><div class="tagcloud-post"><a href="/blog/2018/01/22/vuex-dva/"><time class="tagcloud-posttime">2018 / 01 / 22</time> <span>通过dva得到的思考 —— “滥用”VUEX</span></a></div><div class="tagcloud-post"><a href="/blog/2018/01/25/vuex-study-1/"><time class="tagcloud-posttime">2018 / 01 / 25</time> <span>vuex源码理解（一）</span></a></div><div class="tagcloud-post"><a href="/blog/2018/01/30/vuex-study-2/"><time class="tagcloud-posttime">2018 / 01 / 30</time> <span>vuex源码理解（二）</span></a></div><div class="tagcloud-post"><a href="/blog/2019/04/20/why-vue-proxy/"><time class="tagcloud-posttime">2019 / 04 / 20</time> <span>defineProperty? Proxy?</span></a></div></div><div class="tagcloud-postlist"><h2>electron</h2><div class="tagcloud-post"><a href="/blog/2017/08/22/do-markdown-hexo/"><time class="tagcloud-posttime">2017 / 08 / 22</time> <span>搞electron + vue + webpack2 + TypeScript什么体验</span></a></div><div class="tagcloud-post"><a href="/blog/2017/09/19/what-the-feeling-about-hyper/"><time class="tagcloud-posttime">2017 / 09 / 19</time> <span>使用桌面应用写hexo博客是什么体验？</span></a></div></div><div class="tagcloud-postlist"><h2>docker</h2><div class="tagcloud-post"><a href="/blog/2020/03/29/docker-container-bridge/"><time class="tagcloud-posttime">2020 / 03 / 29</time> <span>docker 容器内通信</span></a></div></div><div class="tagcloud-postlist"><h2>Functional Programming</h2><div class="tagcloud-post"><a href="/blog/2017/12/27/funny-monad/"><time class="tagcloud-posttime">2017 / 12 / 27</time> <span>有意思的monad记录</span></a></div></div><div class="tagcloud-postlist"><h2>TypeScript</h2><div class="tagcloud-post"><a href="/blog/2018/11/19/gamble-fn/"><time class="tagcloud-posttime">2018 / 11 / 19</time> <span>一位赌狗前端的自我修养</span></a></div><div class="tagcloud-post"><a href="/blog/2019/03/23/last-test-questions/"><time class="tagcloud-posttime">2019 / 03 / 23</time> <span>做不完的题目</span></a></div><div class="tagcloud-post"><a href="/blog/2019/10/13/try-wasm/"><time class="tagcloud-posttime">2019 / 10 / 13</time> <span>如果我把 Rust 用在网页呢</span></a></div><div class="tagcloud-post"><a href="/blog/2017/09/19/what-the-feeling-about-hyper/"><time class="tagcloud-posttime">2017 / 09 / 19</time> <span>使用桌面应用写hexo博客是什么体验？</span></a></div></div><div class="tagcloud-postlist"><h2>weapp</h2><div class="tagcloud-post"><a href="/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/"><time class="tagcloud-posttime">2016 / 10 / 28</time> <span>关于微信小程序</span></a></div></div><div class="tagcloud-postlist"><h2>hammerspoon</h2><div class="tagcloud-post"><a href="/blog/2020/06/04/hammerspoon-clipboard/"><time class="tagcloud-posttime">2020 / 06 / 04</time> <span>我如何用 hammerspoon 实现剪贴板历史</span></a></div><div class="tagcloud-post"><a href="/blog/2020/06/02/hammerspoon-ts/"><time class="tagcloud-posttime">2020 / 06 / 02</time> <span>或许可以用 TypeScript 编写 hammerspoon</span></a></div></div><div class="tagcloud-postlist"><h2>typescript</h2><div class="tagcloud-post"><a href="/blog/2020/06/04/hammerspoon-clipboard/"><time class="tagcloud-posttime">2020 / 06 / 04</time> <span>我如何用 hammerspoon 实现剪贴板历史</span></a></div><div class="tagcloud-post"><a href="/blog/2020/06/02/hammerspoon-ts/"><time class="tagcloud-posttime">2020 / 06 / 02</time> <span>或许可以用 TypeScript 编写 hammerspoon</span></a></div></div><div class="tagcloud-postlist"><h2>vim</h2><div class="tagcloud-post"><a href="/blog/2018/02/13/new-life-nvim/"><time class="tagcloud-posttime">2018 / 02 / 13</time> <span>抛下不成熟，开始nvim</span></a></div></div><div class="tagcloud-postlist"><h2>react</h2><div class="tagcloud-post"><a href="/blog/2019/05/28/react-component-method/"><time class="tagcloud-posttime">2019 / 05 / 28</time> <span>react函数级写法和继承写法有什么区别？</span></a></div><div class="tagcloud-post"><a href="/blog/2020/01/31/react-translate/"><time class="tagcloud-posttime">2020 / 01 / 31</time> <span>利用 Context 传递多语言文本</span></a></div></div><div class="tagcloud-postlist"><h2>Redux</h2><div class="tagcloud-post"><a href="/blog/2019/03/08/redux-combinereducers/"><time class="tagcloud-posttime">2019 / 03 / 08</time> <span>Redux —— combineReducers</span></a></div></div><div class="tagcloud-postlist"><h2>Syuanpi</h2><div class="tagcloud-post"><a href="/blog/2017/02/13/syuanpi-css/"><time class="tagcloud-posttime">2017 / 02 / 13</time> <span>自己造轮子！——Syuanpi.css</span></a></div></div><div class="tagcloud-postlist"><h2>CSS</h2><div class="tagcloud-post"><a href="/blog/2017/02/13/syuanpi-css/"><time class="tagcloud-posttime">2017 / 02 / 13</time> <span>自己造轮子！——Syuanpi.css</span></a></div></div><div class="tagcloud-postlist"><h2>rust</h2><div class="tagcloud-post"><a href="/blog/2019/12/29/try-actix/"><time class="tagcloud-posttime">2019 / 12 / 29</time> <span>创建一个 rust web server</span></a></div><div class="tagcloud-post"><a href="/blog/2019/10/13/try-wasm/"><time class="tagcloud-posttime">2019 / 10 / 13</time> <span>如果我把 Rust 用在网页呢</span></a></div></div><div class="tagcloud-postlist"><h2>actix</h2><div class="tagcloud-post"><a href="/blog/2019/12/29/try-actix/"><time class="tagcloud-posttime">2019 / 12 / 29</time> <span>创建一个 rust web server</span></a></div></div><div class="tagcloud-postlist"><h2>swift</h2><div class="tagcloud-post"><a href="/blog/2019/06/07/try-swift-perfect/"><time class="tagcloud-posttime">2019 / 06 / 07</time> <span>来自 swift 的跨界执法（零） —— Perfect</span></a></div><div class="tagcloud-post"><a href="/blog/2019/06/23/try-vapor-0/"><time class="tagcloud-posttime">2019 / 06 / 23</time> <span>来自 swift 的跨界执法（一） —— Vapor</span></a></div></div><div class="tagcloud-postlist"><h2>vuex</h2><div class="tagcloud-post"><a href="/blog/2018/01/25/vuex-study-1/"><time class="tagcloud-posttime">2018 / 01 / 25</time> <span>vuex源码理解（一）</span></a></div><div class="tagcloud-post"><a href="/blog/2018/01/30/vuex-study-2/"><time class="tagcloud-posttime">2018 / 01 / 30</time> <span>vuex源码理解（二）</span></a></div></div></div></div><div class="backtop syuanpi melt toTop" id="backtop"><i class="iconfont icon-up"></i> <span style="text-align:center;font-family:Georgia"><span style="font-family:Georgia" id="scrollpercent">1</span>%</span></div><div class="search" id="search"><div class="input"><input type="text" id="search-input" placeholder="谷歌搜索本地模式" autofocus></div><div id="search-result"></div></div><script src="https://cdn.jsdelivr.net/npm/jquery@3.4.1/dist/jquery.min.js"></script><script></script><script src="/blog/script/lib/lightbox/js/lightbox.min.js" async></script><script src="https://cdn.jsdelivr.net/npm/lazysizes@5.1.1/lazysizes.min.js" async></script><script src="/blog/script/lib/pjax/pjax.js"></script><script src="/blog/script/scheme/balance.js"></script><script src="/blog/script/bootstarp.js"></script><script>nlviconfig.theme.toc&&setTimeout(function(){"balance"===nlviconfig.theme.scheme?$("#header").addClass("show_toc"):"banderole"===nlviconfig.theme.scheme&&($(".container-inner").addClass("has_toc"),$(".post-toc .title").addClass("show"),$(".toc-inner").addClass("show"))},1e3)</script></body></html>