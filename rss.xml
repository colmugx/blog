<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    
    <image>
      <url>https://avatars2.githubusercontent.com/u/21327913?v=3&amp;s=466</url>
      <title>Colmugx &#39;s Blog</title>
      <link>https://colmugx.github.io/blog/</link>
    </image>
    
    <atom:link href="https://colmugx.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Wed, 28 Feb 2024 15:01:25 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>把 .NET 搞到 CFWorker</title>
      <link>https://colmugx.github.io/blog/2024/02/17/dotnet-into-wasm/</link>
      <guid>https://colmugx.github.io/blog/2024/02/17/dotnet-into-wasm/</guid>
      <pubDate>Sat, 17 Feb 2024 04:31:53 GMT</pubDate>
      
      <description>&lt;p&gt;早在 .NET 6 时期发布 MAUI 时就已经对 C# 非常感兴趣，加上这几年对游戏开发的学习使得我重新关注这款语言平台&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关联阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;/blog/2023/02/07/maui-musickit/&quot;&gt;田旗插在苹果上但没插好 —— MAUI + MusicKit · Colmugx &#39;s Blog&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;如今 .NET 8 新增了各种能力：例如进一步对 &lt;code&gt;wasm&lt;/code&gt; 的支持（Blazor 美如画），还有 &lt;code&gt;NativeAOT&lt;/code&gt;。再加上微软自从改变了路线开始尊重开源社区，并且先进技术跟得一次比一次快，让我又当场狗叫&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;「.NET is THE NEXT GENERATION」&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;总所周知 CloudFlare Workers 本来是一个服务托管平台，还是跟上一篇讲得差不多：它优先托管基于 &lt;code&gt;NodeJS&lt;/code&gt; 的应用或者 FaaS。但是！它确实也进入了 &lt;code&gt;WASI&lt;/code&gt; 的实验性支持&lt;/p&gt;
&lt;p&gt;所以当我单方面狗叫「WebAssembly is FUTURE」之时，我已经在想：&lt;strong&gt;用 C# 狸猫换太子是不是有戏？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;醉翁之意不在酒啊&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>早在 .NET 6 时期发布 MAUI 时就已经对 C# 非常感兴趣，加上这几年对游戏开发的学习使得我重新关注这款语言平台</p><blockquote><p>关联阅读：</p><ul><li><a href="/blog/2023/02/07/maui-musickit/">田旗插在苹果上但没插好 —— MAUI + MusicKit · Colmugx 's Blog</a></li></ul></blockquote><p>如今 .NET 8 新增了各种能力：例如进一步对 <code>wasm</code> 的支持（Blazor 美如画），还有 <code>NativeAOT</code>。再加上微软自从改变了路线开始尊重开源社区，并且先进技术跟得一次比一次快，让我又当场狗叫</p><p><strong>「.NET is THE NEXT GENERATION」</strong></p><p>总所周知 CloudFlare Workers 本来是一个服务托管平台，还是跟上一篇讲得差不多：它优先托管基于 <code>NodeJS</code> 的应用或者 FaaS。但是！它确实也进入了 <code>WASI</code> 的实验性支持</p><p>所以当我单方面狗叫「WebAssembly is FUTURE」之时，我已经在想：<strong>用 C# 狸猫换太子是不是有戏？</strong></p><p>醉翁之意不在酒啊</p><span id="more"></span><h2 id="在-NET-8，WASI-创建相当丝滑">在 .NET 8，WASI 创建相当丝滑</h2><p>这个事情起源于 .NET 7，这个时候需要一个 SDK：<a target="_blank" rel="noopener" href="https://github.com/SteveSandersonMS/dotnet-wasi-sdk">SteveSandersonMS/dotnet-wasi-sdk: Packages for building .NET projects as standalone WASI-compliant modules</a></p><p>本质还是创建一个 <code>ASP.NET</code> 应用，但是将 <code>ASP</code> 关于网络部分重新以 <code>WASI</code> 实现</p><p>而 .NET 8 开始正经支持，并且提供了新的 workload（按照我们老微软正田字旗的说法叫：工作负载）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">dotnet workload install wasi-experimental</code></pre><p>接着，为了它的 <code>Publish</code> 或者是 AOT(?) 能正常实现，需要自行在环境中安装 <code>wasi-sdk</code></p><blockquote><p><a target="_blank" rel="noopener" href="https://github.com/WebAssembly/wasi-sdk/releases">Releases · WebAssembly/wasi-sdk</a></p></blockquote><p>.NET 在编译的时候会自行去找本地的 <code>wasi-sdk</code>，但前提是这个终端环境中有 <code>WASI_SDK_PATH</code> 变量。所以还是记得先根据 <code>wasi-sdk</code> 的 Readme 中关于 <code>Install</code> 和 <code>Use</code> 部分先做好</p><p>然后就可以 Create 一个项目。当然如果使用的是 Jetbrain Rider 的话，新建项目列表已经将这个 workload 扫出来了</p><p>这个时候打开 <code>csproj</code> 文件搂一眼会发现，<code>Runtime</code> 不是 <code>web</code> 不是 <code>console</code></p><p>而是 <code>wasi-wasm</code></p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;Project Sdk&#x3D;&quot;Microsoft.NET.Sdk&quot;&gt;  &lt;PropertyGroup&gt;    &lt;TargetFramework&gt;net8.0&lt;&#x2F;TargetFramework&gt;    &lt;RuntimeIdentifier&gt;wasi-wasm&lt;&#x2F;RuntimeIdentifier&gt;    &lt;OutputType&gt;Exe&lt;&#x2F;OutputType&gt;    &lt;PublishTrimmed&gt;true&lt;&#x2F;PublishTrimmed&gt;  &lt;&#x2F;PropertyGroup&gt;&lt;&#x2F;Project&gt;</code></pre><p>这个时候如果什么都不做（反正也有个 hello world 能跑），直接编译，会按照经典 .NET 老配方运行 —— 代码将会编程一些中间代码（已经分门别类编译成 dll），最后让小 Runtime 就着 Wasm 环境来跑</p><p>显然我不要这个配方，我要的是单独一个 <code>.wasm</code> 文件以便 wasmedge 或者 wasmtime 直接执行起来，就像上一篇提到的一样</p><p>所以这个时候需要向 <code>csproj</code> 文件再杵一行进去</p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">&lt;Project Sdk&#x3D;&quot;Microsoft.NET.Sdk&quot;&gt;  &lt;PropertyGroup&gt;    &lt;TargetFramework&gt;net8.0&lt;&#x2F;TargetFramework&gt;    &lt;RuntimeIdentifier&gt;wasi-wasm&lt;&#x2F;RuntimeIdentifier&gt;    &lt;OutputType&gt;Exe&lt;&#x2F;OutputType&gt;    &lt;PublishTrimmed&gt;true&lt;&#x2F;PublishTrimmed&gt;+   &lt;WasmSingleFileBundle&gt;true&lt;&#x2F;WasmSingleFileBundle&gt;  &lt;&#x2F;PropertyGroup&gt;&lt;&#x2F;Project&gt;</code></pre><p>再次编译就是单文件版本了</p><p>一般这个时候如果拿去 docker 运行，跑下来会大概 10MB 左右上上和下下，所以可以根据情况再对运行环境有些优化或者调整，例如</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;EventSourceSupport&gt;false&lt;&#x2F;EventSourceSupport&gt;&lt;UseSystemResourceKeys&gt;true&lt;&#x2F;UseSystemResourceKeys&gt;&lt;EnableUnsafeUTF7Encoding&gt;false&lt;&#x2F;EnableUnsafeUTF7Encoding&gt;&lt;HttpActivityPropagationSupport&gt;false&lt;&#x2F;HttpActivityPropagationSupport&gt;&lt;DebuggerSupport&gt;false&lt;&#x2F;DebuggerSupport&gt;</code></pre><p>接着 <code>wasm-opt</code> 也可以用用（这在 <code>rust</code> 已经很常见，还是 <code>wasm-pack</code> 的内置优化项）</p><p>完事，根据 <code>wrangler</code> 的文档就可以把这个 <code>wasm</code> 文件送上去，过一小段时间之后就可以当成一个服务调用</p><blockquote><p>关联阅读：</p><ul><li><a target="_blank" rel="noopener" href="https://blog.cloudflare.com/announcing-wasi-on-workers/">The Cloudflare Blog</a></li></ul></blockquote><p>然而，.NET 8 的 <code>WASI</code> 转正，带来的却是暂时不直接支持 <code>http</code> 应用。即 <code>system.net</code> 并没有提供给 <code>WASI</code> 平台，要稳定支持且更多相关的功能还是得等到 .NET 9</p><p>或者还有一些路线</p><h2 id="事实上，答案就在-rust-version-sdk-里">事实上，答案就在 rust version sdk 里</h2><p>Cloudflare Workers 直接明牌写着：</p><blockquote><p>Write in JS, Rust, C, and C++</p></blockquote><p>又众所周知，CF Workers 实际上就是整了个 <code>V8</code> 在提供服务</p><p>由此可得，<code>Rust</code> 和 <code>C++</code> 的支持指腚有问题。于是我们可以先去看一眼 tutorial 学习一手</p><blockquote><p>关联阅读：</p><ul><li><a target="_blank" rel="noopener" href="https://developers.cloudflare.com/workers/tutorials/hello-world-rust/">Hello World in Rust · Cloudflare Workers docs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/cloudflare/workers-rs">cloudflare/workers-rs: Write Cloudflare Workers in 100% Rust via WebAssembly</a></li></ul></blockquote><p>结果，不仅代码上有明显的 wasm_bindgen，而且 rust 代码中各种要调用环境外扩展标记，证明 rust 确实是在 WebAssembly 中运行</p><p>并且 <code>rustwasm-worker-template</code> 的 README 还清晰的写下了这个：</p><blockquote><p>workers-rs (the Rust SDK for Cloudflare Workers used in this template) is meant to be executed as compiled WebAssembly, and as such so must all the code you write and depend upon.</p></blockquote><p>所以，C# 完整的在 worker 上跑起来不是不可能的。并且有另外一个托管平台 <code>spin</code> 就实现了相应的 SDK</p><p>但在我印象中，.NET 社区的活跃程度应该是离谱的高的，只是玩 .NET 的家人们应该还不屑于这种玩法，以致还没有相应的 NuGet 吧</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9D%82%E8%80%8D/">杂耍</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/NET/">.NET</category>
      
      <category domain="https://colmugx.github.io/blog/tags/WebAssembly/">WebAssembly</category>
      
      <category domain="https://colmugx.github.io/blog/tags/WASI/">WASI</category>
      
      
      <comments>https://colmugx.github.io/blog/2024/02/17/dotnet-into-wasm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>「试试 WasmEdge」（迟到版）</title>
      <link>https://colmugx.github.io/blog/2024/02/08/wasm-is-future/</link>
      <guid>https://colmugx.github.io/blog/2024/02/08/wasm-is-future/</guid>
      <pubDate>Thu, 08 Feb 2024 09:32:49 GMT</pubDate>
      
      <description>&lt;p&gt;22 年我在找一个开源的可以直接部署的 Serverless(FaaS) 方案。短时间尝试了 OpenFaaS 和 Knative，但这两个分别都有某些地方并不符合当时的需求&lt;/p&gt;
&lt;p&gt;接着发现了 WasmEdge，这是一个利用 &lt;code&gt;wasm/wasi&lt;/code&gt; 的运行时，支持被嵌入式执行&lt;/p&gt;
&lt;p&gt;当我看到它第一眼，加上原本我对 &lt;code&gt;WebAssembly&lt;/code&gt; 的理解，我直接在站起来单方面宣布：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;WebAssembly is FUTURE&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>22 年我在找一个开源的可以直接部署的 Serverless(FaaS) 方案。短时间尝试了 OpenFaaS 和 Knative，但这两个分别都有某些地方并不符合当时的需求</p><p>接着发现了 WasmEdge，这是一个利用 <code>wasm/wasi</code> 的运行时，支持被嵌入式执行</p><p>当我看到它第一眼，加上原本我对 <code>WebAssembly</code> 的理解，我直接在站起来单方面宣布：</p><p><strong>WebAssembly is FUTURE</strong></p><span id="more"></span><h2 id="WebAssembly？">WebAssembly？</h2><p><code>WebAssembly</code> 它是一种低级的类汇编语言，具有紧凑的二进制格式，在 wasm 虚拟机以接近原生的性能运行。原本是设计给在浏览器上运行，利用各种原生语言统一接口，让高密集和其他领域原生积累可以在浏览器上运行</p><blockquote><p>关联阅读：</p><ul><li><a href="/blog/2019/10/13/try-wasm/">《如果我把 Rust 用在网页呢》</a></li></ul></blockquote><p><code>WebAssembly</code> 的设计看起来并不止是浏览器，明显很适合运行无状态，无中心的云函数，非常适合「用完就丢」的一次性场景</p><p>而当时的云函数因为独特的场景需求，大部分 Serverless 平台必定优先支持 <code>NodeJS</code> 或 <code>Golang</code>，其他语言就得看情况</p><p>但如果是 <code>WebAssembly</code>，情况就不是这么个情况了</p><p>首先它可以被集成运行，<code>wasi</code> 提供了让 <code>wasm</code> 操作宿主的可能性，最直觉的例子就是网络调用</p><p>接着，<code>WebAssembly</code> 本质是为了让原本各有所长的原生语言生态可以低成本在浏览器设计的沙箱中运行，这意味着只要可以静态编译成 <code>WebAssembly</code> 的语言都可以加入到这个行列</p><h2 id="WasmEdge？">WasmEdge？</h2><p>WasmEdge 运行时为其包含的 <code>WebAssembly</code> 字节码程序提供了良好定义的执行沙盒环境。该运行时提供了对操作系统资源（例如文件系统、套接字、环境变量、进程）和内存空间的隔离和保护</p><p>在 <code>WebAssembly</code> 领域，<code>rust</code> 是目前最佳选择（私心：还有一个<code>MoonBit</code>），而「Serverless 第一公民」的 <code>NodeJS</code> 并不在这个列表中</p><p>但是 WasmEdge 提供了 <code>QuickJS</code>，得以继续「继续Serverless」</p><p>所以，可以试试玩玩：采用 NodeJS 容器和 wasm runtime 分别 hello world</p><h2 id="Walkthrough">Walkthrough</h2><p>因为 WasmEdge 给 <code>QuickJS</code> 提供的插件并没有完全覆盖 <code>NodeJS</code> 提供的所有类库，但是 http 还是可以使用。（毕竟我试过目前最不复杂的 koa 都寄了）</p><p>这次同样用 ssr 分别做一次例子，但这次用 React 18（因为某些原因，我对 SolidJS 失去了耐心）</p><h3 id="Standard-Docker-Image">Standard Docker Image</h3><p>随便用 vite 开一个项目，然后基础镜像用 node 20，打包运行。好像已经没什么好讲的了</p><p>唯一的区别就是，在一般情况下，在 demo 环节都会使用 <code>Express</code> 做服务端程序，但是这里问题很大，只能改成 <code>NodeJS</code> 提供的最 low level 的 <code>http</code></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">createServer((req, res) &#x3D;&gt; &#123;  res.setHeader(&#39;Content-type&#39;, &#39;text&#x2F;html&#39;);  res.on(&#39;error&#39;, (e) &#x3D;&gt; &#123;    console.log(&#39;res error&#39;, e)  &#125;)  const html &#x3D; renderToString(    &lt;DataProvider data&#x3D;&#123;data&#125;&gt;      &lt;App assets&#x3D;&#123;assets&#125; &#x2F;&gt;    &lt;&#x2F;DataProvider&gt;  )  res.end(html)&#125;).listen(4396, () &#x3D;&gt; &#123;  console.log(&#39;listen 4396...&#39;)&#125;)</code></pre><h3 id="Runtime-WasmEdge">Runtime - WasmEdge</h3><p>由于运行环境是 <code>QuickJS</code></p><p>本质上其运行的方式就是把 <code>QuickJS</code>打包成 wasm，接着用这个 wasm 「解释」<code>JavaScript</code></p><p>在之前有一篇文章已经提到过 <code>QuickJS</code> 的一些注意点，这次也不例外，包括 <code>noExternal</code></p><blockquote><p>关联阅读：</p><ul><li><a href="/blog/2022/12/12/quickjs-ssr/">《我早就想拿 QuickJS 做 SSR 了》</a></li></ul></blockquote><p>所以这一次也必须把要服务端渲染一开始要在服务端运行的 js 打成单文件，然后直接交给 WasmEdge QuickJS Runtime 执行</p><p>并且在 Docker Image 环节也有所不同 —— 其他打法是依赖一个镜像打包，本质还是运行在某个系统之上，而 <code>WebAssembly</code> 是依托于 <code>contained shim</code> 运行的某一个 <code>runtime</code> (WasmEdge, Wasmtime, Wasmer)</p><pre class="line-numbers language-docker" data-language="docker"><code class="language-docker">FROM buildbase AS buildCOPY server.js .RUN wget https:&#x2F;&#x2F;github.com&#x2F;second-state&#x2F;wasmedge-quickjs&#x2F;releases&#x2F;download&#x2F;v0.5.0-alpha&#x2F;wasmedge_quickjs.wasmRUN wget https:&#x2F;&#x2F;github.com&#x2F;second-state&#x2F;wasmedge-quickjs&#x2F;releases&#x2F;download&#x2F;v0.5.0-alpha&#x2F;modules.zipRUN unzip modules.zip# This line builds the AOT Wasm binaryRUN &#x2F;root&#x2F;.wasmedge&#x2F;bin&#x2F;wasmedgec wasmedge_quickjs.wasm wasmedge_quickjs.wasm# 从这里开始「打包」wasm image，无论什么语言编译的 wasm 都差不多FROM scratchENTRYPOINT [ &quot;wasmedge_quickjs.wasm&quot;, &quot;server.js&quot; ]COPY --link --from&#x3D;build &#x2F;src&#x2F;wasmedge_quickjs.wasm &#x2F;wasmedge_quickjs.wasmCOPY --link --from&#x3D;build &#x2F;src&#x2F;server.js &#x2F;server.js</code></pre><h2 id="Above-All">Above All</h2><p>首先最直观的感觉就是大小，Node 这个镜像大小已经不想讲了，而 wasm 版本，在 docker desktop 查看，其运行的时候「镜像」大小在 10MB 左右，并且其运行占用花费地非常少</p><p>但是有一个明显的问题，我目前还没有排查是 docker desktop 的性能还是这本就是 <code>wasi</code> 的问题 —— <strong>它运行效率很慢</strong>。使用传统 <code>linux</code> 镜像的版本运行时非常迅速，像直接本地运行，<code>stream</code> 模式也非常快，而 <code>wasi</code> 版本采用 <code>stream</code> 模式时都会卡加载，并且 <code>css</code> 文件永远没能正常下载</p><p>但我个人意见，其意义非常大 —— 它可以以非常小成本，利用 <code>WebAssembly</code> 统一运行的特性，运行某些程序在边缘网络（Edge）上。例如 <code>ffmpeg</code> 可以被编成 <code>wasm</code>，那么就意味着可以利用边缘资源甚至几个节点的残余资源用来解码或者转码。<strong>而更大的意义可能是可以用来运行专项的小模型</strong></p><p>就像 <code>WasmEdge</code> 其实举最多的例子并不是什么小服务 FaaS，而是模型推理，并官方提供 <code>tensorflow</code> 等推理框架插件集成</p><p>这波 AI 的推背感感觉是来真的。我认为接下来 Multi-Agent 的形态将会跟微服务或者「核心云 - 边缘网」差不多的结构：<strong>使用参数较少，在 CPU 运行优秀的，针对「特定领域特调」的大模型采用 <code>wasi</code> 运行在边缘计算用于降低延迟提供服务（其实就像现在会运行在边缘的 AIoT 一样），然后采用一个或几个通用大模型用于决策或者强化学习</strong></p><p>事实上 python 的执行相对于某几个能贴地飞行的语言来说其能力胯成马，但如果是这样的决策组合可能会是未来的形态，因为相对的，成本会低一些</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/WebAssembly/">WebAssembly</category>
      
      
      <comments>https://colmugx.github.io/blog/2024/02/08/wasm-is-future/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>启动画面！更新！</title>
      <link>https://colmugx.github.io/blog/2024/02/03/renew-homepage-splashscreen/</link>
      <guid>https://colmugx.github.io/blog/2024/02/03/renew-homepage-splashscreen/</guid>
      <pubDate>Sat, 03 Feb 2024 09:28:41 GMT</pubDate>
      
      <description>&lt;p&gt;上一次更新主页已经是 21 年了&lt;/p&gt;
&lt;p&gt;每次都觉得 Riot Games 在潮流设计这部分一直走在前列，例如早在 kda 发布《MORE》的时候开始使用镭射渐变，依稀是来年季中赛还是世界赛开始使用粗犷主义（brutalism），直到现在看 valorant 都是。结果粗犷主义在 23 年才逐渐渗入更多的范围，变得比较容易能看到&lt;/p&gt;
&lt;p&gt;（但是国内的平面设计还在明度渐变字……唉……「程序员」和「设计师」）&lt;/p&gt;
&lt;p&gt;这一年多以来都一直在计划和修改我的主页风格设想，去年就想整体跟随博客都迁移到 brutalism。终于迟来一年，修改了启动画面&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/splashscreen-2.gif&quot; alt=&quot;splashscreen-2&quot;&gt;&lt;/p&gt;
&lt;p&gt;顺便支持了之前没有支持的移动端响应式。只能说这个 23 年过得差点让我失去道心&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>上一次更新主页已经是 21 年了</p><p>每次都觉得 Riot Games 在潮流设计这部分一直走在前列，例如早在 kda 发布《MORE》的时候开始使用镭射渐变，依稀是来年季中赛还是世界赛开始使用粗犷主义（brutalism），直到现在看 valorant 都是。结果粗犷主义在 23 年才逐渐渗入更多的范围，变得比较容易能看到</p><p>（但是国内的平面设计还在明度渐变字……唉……「程序员」和「设计师」）</p><p>这一年多以来都一直在计划和修改我的主页风格设想，去年就想整体跟随博客都迁移到 brutalism。终于迟来一年，修改了启动画面</p><p><img src="/blog/Image/splashscreen-2.gif" alt="splashscreen-2"></p><p>顺便支持了之前没有支持的移动端响应式。只能说这个 23 年过得差点让我失去道心</p><span id="more"></span><p>这是之前的启动动画</p><p><img src="/blog/Image/splashscreen-1.gif" alt="splashscreen-1"></p><p>非常经典的当时所设想的 TFD Style，使用的还是已经不知道什么时候结束维护的 Syuanpi.css</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%97%A5%E5%B8%B8/">日常</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2024/02/03/renew-homepage-splashscreen/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>「成为玩家」2023</title>
      <link>https://colmugx.github.io/blog/2024/01/01/to-be-a-gamer-2023/</link>
      <guid>https://colmugx.github.io/blog/2024/01/01/to-be-a-gamer-2023/</guid>
      <pubDate>Mon, 01 Jan 2024 14:40:33 GMT</pubDate>
      
      <description>&lt;p&gt;回顾整年，我在犹豫和怀疑是否还能称为「成为玩家」—— 似乎一整年都跟游戏没什么关系，我也没有相对应的付出&lt;/p&gt;
&lt;p&gt;好巧不巧，写文章前闪念到岩田聪 GDC2005 年那场分享《Heart of a Gamer》，让我想起来一些东西&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;游戏的存在只是为了一个意义，那就是快乐，给所有人带来快乐。&lt;/strong&gt; —— 岩田聪&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回想今年的经历，至少可以拟合成一条斜率在 (0, 1) 的斜线。所以先暂时给标题加上引号，因为我可能需要有一些证明&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>回顾整年，我在犹豫和怀疑是否还能称为「成为玩家」—— 似乎一整年都跟游戏没什么关系，我也没有相对应的付出</p><p>好巧不巧，写文章前闪念到岩田聪 GDC2005 年那场分享《Heart of a Gamer》，让我想起来一些东西</p><blockquote><p><strong>游戏的存在只是为了一个意义，那就是快乐，给所有人带来快乐。</strong> —— 岩田聪</p></blockquote><p>回想今年的经历，至少可以拟合成一条斜率在 (0, 1) 的斜线。所以先暂时给标题加上引号，因为我可能需要有一些证明</p><span id="more"></span><h2 id="FLASH">FLASH</h2><p>今年再一次结束独居的日子，开始跟家人住在一起</p><p>我知道大多数人都因为「家人不懂」或「家人不了解」从而不太愿意跟家里人聊天</p><p>不过我渐渐有了新的理解：<strong>有时候因为家人不经意的一句话，会因此得到启发，甚至改变当下的困境</strong></p><p>本来我在抱怨工作而导致的兴致下降，间接影响到今年对游戏开发的理解和学习。而家人的一句话让我感到欣慰：</p><blockquote><p>你今年只是以另一种形式在参与游戏：<br>你让一位<strong>对游戏没有任何认识的人</strong>理解游戏的种种方面，并且爱上游戏</p></blockquote><p>这大概也是「融合学科」带来的启发。当然也不可否认，讲解任天堂能占的便宜确实足够大</p><h2 id="KEEP-HELPFUL">KEEP HELPFUL</h2><p>我在更早的时候知道「代码之外」这个播客，但我一直没有决定去听，一直到昨天开始从第 0 期开始听（以下若干章节的思考起点可能都来源于这期播客）</p><p>其中谈到了帮助别人以及会花更多时间做一对一，这跟我在坚持的东西很接近：</p><blockquote><p>只要你愿意了解且我知道，我会分享所有我知道的一切</p></blockquote><p>我还能比较高兴在早几年 hexo 很流行的时候我做了一个主题。虽然主题本身并不流行，主题的诞生现在想起来已经是 hexo 流行期的末期</p><p>刚好那段时间知乎也比较活跃，所以我能经常在知乎收到一些私信，一开始是关于 nlvi 的一些疑问，渐渐地私信就开始物种丰富：「我的网速很卡」、「我想直播的时候用 ipad 当画板」、一些前端问题、还有「我现在很迷茫」然后把他简历就直接发了过来……</p><p>关于 nlvi 的问题，有一部分是可以在 wiki 找到的会指路到 GitHub Wiki，剩下一部分能答也答了。除此之外其他问题基本上也回答了，而关于那个「我现在很迷茫」，当我发了一通话之后，过了几天收到一个回复：</p><blockquote><p>谢谢你给我说了这么多，你真好</p></blockquote><p>现在偶尔也会收到类似咨询的邮件，基本上能回的也都回了</p><p>我也说不好是什么时候开始做这些事情，受谁的影响（估计多半还是 <a target="_blank" rel="noopener" href="https://levy.vip">Levy</a> ）。只是从这个时候我开始相信 <strong>「知识本身并没有价值，知识被实用了，被产品化了，才能体现价值。」</strong></p><p><strong>或许我没有对某个知识具象化，但如果你可以做，这对我来说也是值得高兴的事情</strong></p><p>到后来在这个基础上又增加一些东西：有时候人家可能一时迷茫，也许跟知识没有关系。或者说就像 Randy 说的那样：你去找心理医生说我得不到技术成长，心理医生只会一脸懵b</p><p>但可能就因为你把你的理解分享给他跟他聊了一通之后，或许就能解决对方的问题</p><p>在我「短暂的」 TL 生涯中，就曾经发生过这么件事情：</p><blockquote><p>P：我觉得很迷茫，我不知道我要做些什么<br>C：这个「做什么」指的是技术上的还是职业上的<br>P：两个都很迷茫，我不知道我可以做什么，我也不知道以后能做什么<br>C：那你有什么喜欢的事情或者你最近一次想弄的东西是什么<br>P：最近一次想试试自己部署 NGINX，我觉得 NGINX 很神奇……<br>C：那你做了吗？<br>P：没有<br>C：要不试试先做，先能部署起来，然后尝试代理地址。先尝试对它有兴趣，慢慢你就会想知道它还可以怎么玩，“我是不是可以考虑 docker image”，“我是不是可以用别名代替地址”，渐渐地问题越来越多，<strong>产生问题了才能解决问题</strong>，渐渐你会因为尝试喜欢 NGINX 顺带了解到很多东西。而不喜欢更没关系，至少选择题上排除了一个选项<br>P：我大概懂什么意思了，在没有方向的时候先尝试一个最近的答案，如果发现答案不合适也刚好可以排除这个路线。我之前也尝试问了 xx（原本的 TL），但他总是跟我说“不知道就去想”，整得人越来越迷茫<br>C：YOU DONT KNOW WHAT YOU DONT KNOW，我只能是把我可能得经验分享给你</p></blockquote><p>更多相关的东西，等放到《我的招聘理念》再讲</p><p>不过，我可能会有一段时间会违背我在坚持的东西 —— 这个博客暂时对视觉敏感群体不友好。虽然也不能怪 Pantone Color 2024 是 <code>Peach Fuzz</code>，明度比较高。谁让一开始就给自己制定了这个玩法呢</p><h2 id="宿命论">宿命论</h2><p>我原本是不相信这个的</p><p>但当有一天发现，当觉得自己在「逆天改命」之后沾沾自喜的时候，尝试复盘一下，然后就会发现，好像这个时候会所谓的「逆天改命」也是必然的，它有非常充要的条件让你做出了这次「逆天改命」</p><p>这一切就像有人已经帮你写好了剧本一样，即使偶尔的意外，复盘的时候也会觉得会遇到这几次意外也像是被安排好的</p><p>并且有时候这些东西会像一个故事的情绪曲线一样，眼下觉得「这 B 东西真是糟透了」，随之而来却又一路向上。这个时候复盘会发现，好像还真因为遇到这个糟透的东西才能碰上后面美好的东西</p><p>于是就没什么好说的了。当「一切都被安排好」的情况下，其实不管做什么，都是在演绎剧本</p><p>我们能做什么呢？反正不管怎样肯定「水到渠成」对吧？<strong>OF COURSE NOT!</strong></p><p>即使知道了所谓的「真相」，我认为也应该保持自己最佳状态完成任何事情。「突变」控制不了，「尽力完美」是可以的</p><h2 id="DIVERSITY-INCLUSIVE">DIVERSITY &amp; INCLUSIVE</h2><p>有人说：前端不需要懂业务也能做</p><p>还有人说：不需要对代码有过分的追求，能用就行。你花时间把代码写得满意，下一个接手的人也会觉得是答辩</p><p>还有人说：不要对技术有过分的追求，不要追求极致，不仅没有效果，还在分裂团队</p><p>朋友有一次吹 b 说他们有一个同事，纯血 vue 使徒。这么说的原因是在他只知道一个 vue，但其实只是一个 user。在他看来的前端都是组件，甚至用 vanilla js 都能满口生命周期</p><p>还有狼叔今年的总结，列了一些自己曾经的特点，好像也在念我的身份证</p><p>最后，狼叔「懂了俯视问题、更加圆滑」。我虽然不知道自己是不是能克服「职场冲动」，但我突然理解了微软价值观「diversity and inclusive」的另一种含义：「包容」「多样性的」所谓「技术人」</p><p>放过别人，也是放过自己。在不合适的地方争吵，不如去合适的地方碰撞思考</p><h2 id="连续感与保持乐观">连续感与保持乐观</h2><p>有时候奇妙的「连续感」让人感觉很安心</p><p>之前就认为「是时候去真正了解游戏」然后到了现在的工作环境。说实话，不可能得不到帮助。不管是各种非 KPI 的公司级别内部分享，或是各种活动</p><p>直到现在一次又一次的失落，信仰正在崩塌，很难让人重新找回信心和热情，以致于今年的<a href="/blog/2023/07/20/passion-of-coding/">《写代码还有激情吗?》</a></p><p>但最近一段时间，我听了 Randy 关于离职微软的分享，听了 yyx 关于自己的分享，他们总在强调一件事情：</p><blockquote><p>用热情创造东西总是很有趣<br>写代码这个事情真好，并不是写代码很好，而是写代码能生产真好，甚至能给世界带点什么真好</p></blockquote><p>这个时候我想到了，写代码改变世界，做游戏是创造世界</p><p>上面一章「FLASH」提到的家人的无意识提示，其实还有另一个：</p><blockquote><p>我就是很好奇为什么马里奥总能让人觉得很快乐<br>而且《马里奥派对》，还有那个什么《瓦里奥》也是，总能让人不经意笑出声<br>他们是怎么做到的？</p></blockquote><p>瞬间我的脑子像连通了回路一样，从「写代码改变世界」到「做游戏创造世界」到「想创造世界的根本原因」，再接上之前看了 <a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SC4y1c7ju">〖FEDAY〗我的大前端世界观 - 黄玄 Hux_哔哩哔哩_bilibili</a>，再到后来偶然看了一场线上 GameJam……</p><p>当种种串到一起之后，也许就是自我感动罢了，但还是会热泪盈眶且心潮澎湃</p><p>我真是太幸运了，瞬间感觉这个世界好像也没有那么令人焦虑。因为世界上还有很多志同道合的人也在追求自己的目标，他们也会有无数身边的朋友和家人在支持他们。我也是</p><h2 id="CREATIVE">CREATIVE</h2><blockquote><p>创造东西成本最低的方式就是写代码</p></blockquote><p>像上一篇提到的那样，大多数人其实并不是喜欢创造一些东西，只是甚是因为程序员的工薪比较高，而他们的目的也只是「混出头」，对于优秀的追求并不高，混上「管理者」之后对于程序的水平在微不足道的情况下又节节败退的人比比皆是</p><p>我反正是不愿意的，我只会觉得「能做这个」真 JB 酷，能「让一切充满想象力」真 JB 酷</p><p>总之，关于这部分在 <a href="/blog/2023/12/20/about-effective-acceleration/">《关于「有效加速主义」》</a> 已经意见输出挺多的了</p><p>即使现在没办法完成一个我非常满意喜欢的 Product，能通过代码解决我工作上的问题，用代码解决代码问题，好像也还不错？从刚参加工作的 shoot，到现在的 banshee 等有的没的</p><h2 id="黑神话悟空">黑神话悟空</h2><p>当时最经典的场面莫过于《黑神话：悟空》公布和《原神》上线</p><p>这两个投资都巨大的游戏在市场上却是两级分化的评价：《黑神话：悟空》是国产 3A 的未来，《原神》臭不可闻</p><p>最后，《原神》不断逆转口碑，成为更多「持续性运营游戏」的模版和学习对象，而转眼间《黑神话：悟空》也会在今年上市</p><p>我不玩 soul like，不玩 sekiro，但是我会支持这一次历史性时刻</p><p>加上我少有的支持某些规则的颁布，即使这样会打破目前这些畸形的「游戏公司」长久以来的经营策略</p><p>对于资本来说，他们会暂时不关心这个市场。我很高兴，因为他们本来就<strong>屁都不懂</strong></p><p>我很期待全新的游戏市场</p><h2 id="《谐律之章》（Harmony-Chronicles）">《谐律之章》（Harmony Chronicles）</h2><p>我的 JRPG 计划我并没有想好名字叫什么，因为这对我和这个项目来说非常遥远 —— 有很多计划和各种信息，有玩法，有风格，但是没有启动过</p><p>所以这个名字是 ChatGPT 给的，毕竟有一个很酷的名字总比一个叫 Project Harmony 的文件夹好</p><p>所以算是第一次公开？再公开一点？</p><blockquote><p>这是一个靠音乐和声音驱动的世界，所有人不仅享受声音带来的生存资本，每个人也都享受音乐</p><p>这个世界的音乐会被分为两个部分：主流音乐和地下音乐。主流音乐和地下音乐在很长时间都是对立的 —— 地下音乐认为主流音乐呆板不时髦，主流音乐认为地下音乐是“不和谐音”。</p><p>诞生于西欧中世纪音乐地区的少女，和出生自西欧中世纪音乐却成长于中国民族音乐地区的少年，携带各自的目标和信仰开始旅行并寻找答案。</p><p>因为成长路径不同：少女最擅长的是电子音乐(trap / future bass)，少年最擅长的是中国民乐。</p><p>少女的目的是为地下音乐正名，少年的目的是将地下音乐赶出视野……</p></blockquote><p>这里女主是一个反差：有端庄印象的宫廷音乐却使用 Trap；女主定位是天才少女，从小学习管风琴，长大却带着双排键键盘</p><p>音乐流派是对立：我们总能听到有人不喜欢电子音乐，有人不喜欢传统民乐</p><p>我觉得反差和对立是很有趣的，如果有机会的话会一直以这个思路一直做下去</p><p>而且提供了合并的空间：DJ 和琵琶存在合奏。用电吉他进入民乐领域的UP主其实现在也存在（但我21年就有这个想法）</p><p>并且我有一个可能是一个大胆的想法：这是一个双主线游戏，即使最后会时间线收束。毕竟其实如果是老 JRPG 或者老迪士尼来看，这个结局会往哪个方向走应该很好猜吧</p><p>So</p><h2 id="JUST-DO-SOMETHING">JUST DO SOMETHING</h2><p>想干就干</p><p>先修改一下主页，加上 <a target="_blank" rel="noopener" href="https://github.com/colmugx/cheatshooter">konami code</a></p><p>实现是很简单的，但对于游戏玩家来说，konami code 是浪漫的</p><p>接着，把之前的坑都一个一个先 POC，先从 <code>setsuna</code> 开始，然后通过 <code>setsuna</code> 开始项目管理……</p><p>还有，让自己尽量得到休息，即使真的很忙，也要休息。也需要重新练习琵琶了</p><p>没错，当我决定故事线和主角定位之后，我开始学习琵琶了，拜了一个我心底里非常敬佩的琵琶首席为师</p><p>老师也很好，她完全了解我的意图之后，给我设计了一种非常规的课程安排，当然我也没辜负老师的期望</p><p>（其实还是辜负了，纯血天赋不努力型）</p><h2 id="STAY-PASSIONATE">STAY PASSIONATE</h2><p>有一天回家，家门的指纹识别失败了两次，第三次才打开</p><p>我也不知道什么时候开始我对这类事情已经不会感到不耐心，转而是戏谑了一句：</p><blockquote><p>刚跟这个 B 门打了把马里奥</p></blockquote><h2 id="如果我不写程序我会在做什么">如果我不写程序我会在做什么</h2><p>一个播客留下来的问题，也值得我思考</p><p>说实话，很难回答</p><p>我自认为有足够 talent，但是我直到现在从事的所有工作都无法发挥我的 talent。我应该是一名超级横向玩家？</p><p>以前的我可能会很焦虑，例如如果我万一失业了怎么办？我有一天吃不上程序员的饭了怎么办？如果我没饭吃了怎么办？</p><p>但如果今天来看这个问题的话，我应该不会焦虑了，我相信一切都会变好</p><p>如果吃不上「程序员」的饭的话，那就不吃了，留给那些所谓的「程序员」吃吧</p><br /><p>虽然现在还是可以证明我还有「资格」使用这个标题</p><p>但或许这个标题以后都不会再用了</p><p><strong>IT’S TIME TO GO!</strong></p>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2024/01/01/to-be-a-gamer-2023/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于「有效加速主义」</title>
      <link>https://colmugx.github.io/blog/2023/12/20/about-effective-acceleration/</link>
      <guid>https://colmugx.github.io/blog/2023/12/20/about-effective-acceleration/</guid>
      <pubDate>Wed, 20 Dec 2023 12:41:39 GMT</pubDate>
      
      <description>&lt;p&gt;我确实是「前端已死派」。不过是片面已死，而且死得好&lt;/p&gt;
&lt;p&gt;我觉得经历过前几年的互联网都应该知道，市场对于「前端」的需求是有点畸形的。大量的电商微商，无论是各行各业都在追求「数字化」而制造出很多所谓「ToB产品」，再接着是很多公司「嗅」到一种莫名的商机，开始制造这些价值很低的「ToB产品」并进行 SaaS 化、PaaS 化……大批量的为了以此赚快钱的外包……这制造了一个非常务虚的市场，使得这几年前端环境都很乱，大批量没有任何软件知识的人通过一些非常荒谬的培训之后开始自诩「程序员」上岗……这其中还不包括就是看中程序员工资高但本身毫无追求的「冒充程序员」&lt;/p&gt;
&lt;p&gt;所以当经济支持不了这样的市场之后，大规模的裁员变得显而易见，许多公司所谓的「大前端」开始分解&lt;/p&gt;
&lt;p&gt;所以我说的前端已死，指的是这些毫无意义，不学无术，能轻易替换的前端。因为他们只是在使用 &lt;code&gt;Ant Design&lt;/code&gt; 和 &lt;code&gt;Element-UI&lt;/code&gt; 进行无意义的拼凑而已&lt;/p&gt;
&lt;p&gt;甚至 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://levy.vip&quot;&gt;Levy&lt;/a&gt; 曾经跟我分享：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;我认识一个前端说：前端不需要懂业务也能做&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;关于部分会换到另一篇进行更细致的讨论，把它带出来只是想说明我时刻都在自我怀疑和开始不解。没有人对「科技向善」有感，没有人对「技术发展」有感，没有人对「WebNN」、「WebAssembly / WebGPU」有感。我有时会听到别人问我，用 &lt;code&gt;rust&lt;/code&gt; / &lt;code&gt;elixir&lt;/code&gt; 能不能赚钱，甚至我见过太多人打开 &lt;code&gt;ChatGPT&lt;/code&gt;，在输入框输入「如何利用xx赚钱」甚至是「有什么办法让我有钱」……&lt;/p&gt;
&lt;p&gt;直到我遇到了「有效加速主义」&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>我确实是「前端已死派」。不过是片面已死，而且死得好</p><p>我觉得经历过前几年的互联网都应该知道，市场对于「前端」的需求是有点畸形的。大量的电商微商，无论是各行各业都在追求「数字化」而制造出很多所谓「ToB产品」，再接着是很多公司「嗅」到一种莫名的商机，开始制造这些价值很低的「ToB产品」并进行 SaaS 化、PaaS 化……大批量的为了以此赚快钱的外包……这制造了一个非常务虚的市场，使得这几年前端环境都很乱，大批量没有任何软件知识的人通过一些非常荒谬的培训之后开始自诩「程序员」上岗……这其中还不包括就是看中程序员工资高但本身毫无追求的「冒充程序员」</p><p>所以当经济支持不了这样的市场之后，大规模的裁员变得显而易见，许多公司所谓的「大前端」开始分解</p><p>所以我说的前端已死，指的是这些毫无意义，不学无术，能轻易替换的前端。因为他们只是在使用 <code>Ant Design</code> 和 <code>Element-UI</code> 进行无意义的拼凑而已</p><p>甚至 <a target="_blank" rel="noopener" href="https://levy.vip">Levy</a> 曾经跟我分享：</p><blockquote><p>我认识一个前端说：前端不需要懂业务也能做</p></blockquote><p>关于部分会换到另一篇进行更细致的讨论，把它带出来只是想说明我时刻都在自我怀疑和开始不解。没有人对「科技向善」有感，没有人对「技术发展」有感，没有人对「WebNN」、「WebAssembly / WebGPU」有感。我有时会听到别人问我，用 <code>rust</code> / <code>elixir</code> 能不能赚钱，甚至我见过太多人打开 <code>ChatGPT</code>，在输入框输入「如何利用xx赚钱」甚至是「有什么办法让我有钱」……</p><p>直到我遇到了「有效加速主义」</p><span id="more"></span><h2 id="什么是「有效加速主义」">什么是「有效加速主义」</h2><p>有效加速主义基于热力学第二定律 —— 熵增原理提出来的</p><p>即使局部熵减，宇宙系统而言也是持续熵增，因为熵减的过程会带来额外的能量损耗，即也是熵增。生命复制消耗自由能转为熵，进化也是这个原则里的其中之一</p><p>很巧合，看了一个视频：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1e64y1V7mo">人类什么时候被AI送走？_哔哩哔哩_bilibili</a></p><p>视频有提到，在薛定谔的《生命是什么》之中，记录这么一段话</p><blockquote><p>生物这一辈子，总是在努力降低自己的熵</p><p>熵最大的状态即是它死亡的状态</p></blockquote><p>熵增其实还算比较好理解，就是事物从有序变无序。「死亡状态是熵最大的状态」，指的是当动物死亡的时候，对于这个个体来说已经无法做任何事了，所以只会朝着无限混乱发展下去</p><p>所以人这一生总是在做让无序变有序的事件：让自己整洁、让自己学会使用更多工具……</p><p>一切生物在追求进化时，都首先有保底的路线：自然繁殖</p><p>但是人类之所以能称为高级动物，是因为即使其他动物可以使用工具，例如水獭拿到贝壳之后会拿它去拍石头，或者抓一块石头去拍壳类——它们只能是「拿到什么用什么」，而人类可以基于工具创造工具，用更新的工具解决更新的问题，<strong>并且能解决的问题类型和数量会随着时间和获得的素材呈指数级增长</strong></p><p>另一边，E/acc 的官网 <a target="_blank" rel="noopener" href="https://effectiveacceleration.tech">Effective Accelerationism</a> 是这么讲的：</p><blockquote><p>e/acc is not an ideology. It is not a movement. It is simply an acknowledgement of truth.</p><p>But it is also a blow against technocratic control, against the doomers and decelerationists who would have us consume less free energy and create less entropy. Top down control only lowers the dimensionality of civilization.<br>（但它也是对技术官僚控制的一种打击，对那些希望我们消耗更少自由能量并创造更少熵的末日预言者和减速主义者的反击。<strong>自上而下的控制只会降低文明的维度</strong>。）</p></blockquote><p>E/acc 的提出，可能的原因也是有一些声音在反对技术或者通用人工智能发展得太快，亟待重新审视方向和相关的约束。但这个理论应该并不局限于 AI，我认为适用很多东西，包括我所在的前端</p><h2 id="一直以来的疑问或许得到了解释">一直以来的疑问或许得到了解释</h2><p>不管什么领域，实际上都一直在做「无序到有序」。若干年前我在知乎（懒得找）曾回答过一个前端发展相关的问题，大概是：</p><blockquote><p>一开始没有前端，就是网页设计，那个时候只不过是切切图，从 fireworks 到 dreamweaver</p><p>再后来开始对交互提出了需求，所以开始有 CSS3 和 JQuery，布局也从 table 变成更灵活的 div + css。但网页依然还是网站程序员在做</p><p>棘轮继续转，又对交互提出了需求，简单的脚本已经顶不住更多的交互，开始需要像传统应用一样给代码分组和使用设计模式</p><p>棘轮继续转，又对交互提出了需求，并且对即时性也提出了要求。所以开始需要单页了，vue 官配一家子和 react 野生一家子，需要更强大的工程化</p></blockquote><p>以下是我续写的：</p><blockquote><p>再往下又对交互性和及时性提出了要求，这个时候已经更多的计算都在端侧了，所以开始产生了 PWA 之类的实现</p><p>再往下又对交互提出了要求，这个时候开始不满足 JavaScript 的密集计算性能了，并希望已经成熟的人类智慧积蓄继续发光发热，所以 WebAssembly 开始发展</p><p>再往下又对交互提出了要求，这个时候已经不满足让浏览器管渲染了，需要能直接调用 GPU 做一些更精细的渲染工作，于是轮到了 WebGPU</p><p>再往下又对交互提出了要求，这次要将当时没活成的 VR 推成 XR……</p></blockquote><p>这个时候人类，或者相关的软件工程师，总是尽力在将无序变有序，其中还不包括我这段时间一直在尝试往前推进的「前端领域驱动设计」—— 让代码架构和逻辑「从无序到有序」</p><p>抛开所有「重复造轮子」和「KPI轮子」不谈，在「造轮子」这件事上，就是人类正在追求「无序到有序」。正如上面的回答，每一次技术迭代和更新，看着都像是消费升级，但有没有一种可能：<strong>技术只能是这样油门焊死发展下去的</strong></p><p>HTML5 之前的 HTML，<code>DOCTYPE</code> 那可真是百花齐放，17 年去 DJI 面试的时候还被问过 DTD 的事。<strong>而 HTML5 之后，不管是标签还是规范，一切都统一了</strong>。而接下来的 <code>WebGPU</code>，或是 <code>WebNN</code>，其实都是因为技术发展而开始有新活可整</p><p>就像游戏引擎、图形学、计算硬件的关系，游戏引擎的诞生就是为了让游戏开发更有序和便捷，同时可以让游戏的技术能使用当前最前沿的技术，甚至对当前技术提出挑战。当一个个挑战解决之后，<strong>原本因为了用来玩 Quake 开始产生需求的显卡已经发展到甚至可以用来让 AGI 开发 Quake 了</strong>，虽然有点夸张</p><p>「指数发展文明」从人类组合的第一个工具开始就已经在加速发展，这或多或少又间接解答另一个困扰我很久的问题：我这一路活到现在，如果仔细回想一下，似乎总有迹象能说明「我这一路都像是有人早已设计好的，甚至我以为这一切的结果是因为我这一刻会发力也是被设计好的」</p><p><strong>技术的发展似乎也是随着时间肯定会被逐渐发现，只不过是谁先发现而已</strong>，例如勾股定理</p><p>但关于「自然繁殖文明」，这玩意其实应该依然还存在 DNA 里。因为我始终很难理解，<strong>为什么直到现在还是会有人会想不断的生孩子，并且将自己的欲望和做不到的事强加给下一代，让下一代能完成</strong></p><p>无法理解</p><h2 id="刚好我又看了另一个东西">刚好我又看了另一个东西</h2><p>综上所述，「有序到无序」是否也可以看成 <code>O(n)</code> 到 <code>O(1)</code></p><p>这个时候让我看到了这个：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1SC4y1c7ju">〖FEDAY〗我的大前端世界观 - 黄玄 Hux_哔哩哔哩_bilibili</a></p><p>（老实说我当时玩知乎的时候还挺粉 Hux 的）</p><p>这个视频的一开始让我觉得有点好笑。其实这个角度说，我觉得有点好笑在于：Web 是前端，前端为什么是 Web。编译器有编译前端和编译后端，编译前端算「前端」吗？</p><p>不过，大体上可以将这个视频总结为：「前端工程师」身份认同正在逐渐消退。写页面叫前端，用 <code>React</code> 和 <code>Vue</code> 的叫前端，<strong>那开发 <code>React</code> 和 <code>Vue</code> 的人算前端吗？</strong></p><p>接着又引用到了另一个跟 AI 相关的分享，来自陆奇的《我的大模型世界观》：</p><blockquote><p>社会性拐点的核心，是一项大型成本，从边际成本变成固定成本</p></blockquote><p>我是赞同的，因为我逐渐发现，我正在离「页面」越来越远。虽然我的工作依然有页面和交互的内容，而且做页面的速度早就没有增长。那我上班时间都花在哪了？答案是上一篇提到的类似的那些工具，以及上上篇提到的各种为了架构化的框架</p><p>而所谓「正格前端」，可能需求会越来越少，但并不是已经不需要交互了。简单说一下发生在我身边的现状：<strong>所谓的内容管理后台，现在已经交给 langChain + LLM 了</strong></p><p><code>omni-frontend</code> 这个概念提出来也很精彩。也像我之前曾经给前端下的定义：只要靠近用户的那一端就是前端。那作为一个日常也在使用终端设备的人，自己是最知道最想要的下一代交互是怎样的。能为终端用户做的事情还是太多了</p><p><code>WebNN</code> 的诞生就是希望能在端侧跑一些小模型甚至随着计算能力的发展，形态越来越大。但无所谓，它诞生的目的就是能更即时得到交互结果，就跟明明有成熟的云计算又诞生出边缘计算一样</p><p>所以，有谁让你停止追求，把油门松开，大胆回答一句 QNMD 就行了。人活这一遭就应该尽自己的理解狠狠加速</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%80%9D%E8%80%83/">思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/AI/">AI</category>
      
      <category domain="https://colmugx.github.io/blog/tags/E-acc/">E/acc</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/12/20/about-effective-acceleration/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>用 rust 实现 i18n converter</title>
      <link>https://colmugx.github.io/blog/2023/12/16/build-xls2json-with-rust/</link>
      <guid>https://colmugx.github.io/blog/2023/12/16/build-xls2json-with-rust/</guid>
      <pubDate>Sat, 16 Dec 2023 14:05:17 GMT</pubDate>
      
      <description>&lt;p&gt;软件国际化必然需要翻译文件。虽然我也很想用类似 &lt;code&gt;locize.com&lt;/code&gt; 之类的服务管理翻译，这样 &lt;code&gt;i18next-locize-backend&lt;/code&gt; 直接游戏结束&lt;/p&gt;
&lt;p&gt;可惜用不得，只有一个甚至早期管理还很乱的 excel 文件，所以需要解决「如何把它变成 json」的问题&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;插件类型应用必然使用抽象工厂，早在设计 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/FEMessage/upload-to-ali&quot;&gt;FEMessage/upload-to-ali&lt;/a&gt; 服务端就这么用&lt;/li&gt;
&lt;li&gt;将文件对应为统一结构，以扩展的形式输出对应要求格式文件&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;calamine&lt;/code&gt; 解析 &lt;code&gt;xls(x)&lt;/code&gt; 文件&lt;/li&gt;
&lt;li&gt;使用 &lt;code&gt;rayon&lt;/code&gt; 直接让列表多线程&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>软件国际化必然需要翻译文件。虽然我也很想用类似 <code>locize.com</code> 之类的服务管理翻译，这样 <code>i18next-locize-backend</code> 直接游戏结束</p><p>可惜用不得，只有一个甚至早期管理还很乱的 excel 文件，所以需要解决「如何把它变成 json」的问题</p><h2 id="TL-DR">TL;DR</h2><ul><li>插件类型应用必然使用抽象工厂，早在设计 <a target="_blank" rel="noopener" href="https://github.com/FEMessage/upload-to-ali">FEMessage/upload-to-ali</a> 服务端就这么用</li><li>将文件对应为统一结构，以扩展的形式输出对应要求格式文件</li><li>使用 <code>calamine</code> 解析 <code>xls(x)</code> 文件</li><li>使用 <code>rayon</code> 直接让列表多线程</li></ul><span id="more"></span><h2 id="原始需求">原始需求</h2><p>因为确实需求很简单：将一个有规则的 excel 文件按照 i18next 可用的格式转成 json 文件。第一行是标题，除了第一列是 key，第二列开始是每个语言（例如简体中文、美式英语…）</p><p>所以这里大致有两个问题：</p><ol><li>获取传入参数</li><li>解析 excel 文件</li></ol><p>第一个还行，可以使用 <code>clap</code>。但这里不是一个非常复杂的 cli 应用，避免麻烦，直接读取 <code>env::args()</code> 分段即可</p><p>而第二个也直接找现成的解析库。今非昔比， rust 生态已经很好了。所以这里选择已经在 README 里暴打其他语言同行遥遥领先的 <code>calamine</code>（但不支持 write），大概是这样用的</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use calamine::&#123;Reader, Xlsx, open_workbook&#125;;fn main() &#123;  let mut excel: Xlsx&lt;_&gt; &#x3D; open_workbook(&quot;file.xlsx&quot;).unwrap();  if let Some(Ok(r)) &#x3D; excel.worksheet_range(&quot;Sheet1&quot;) &#123;      for row in r.rows() &#123;          println!(&quot;row&#x3D;&#123;:?&#125;, row[0]&#x3D;&#123;:?&#125;&quot;, row, row[0]);      &#125;  &#125;&#125;</code></pre><p>搞的很快啊，POC 一下子就弄完了。但是！本体 Qt 程序也有一样的需求，毕竟一心同体</p><p>虽说 <code>QTranslator</code> 和 <code>QtLinguist</code> 很强，但对我们来说只解决把 tag 取出来提供到 excel，转成 <code>.ts</code> 文件还是需要一个程序完成</p><p>那就格局大一点，excel to any，万一哪天需要 xml（来自后来人的说明：Qt 组直接以最简单最直接最不需要考虑产品化的思路干出一个序列/反序列全套程序，所以这个用不上了）</p><h2 id="如今实现">如今实现</h2><p>所以核心思路演变为：</p><ul><li>将每一组翻译变成一个通用结构</li><li>以扩展的形式读取这个通用结构列表，写出扩展想实现的输出</li></ul><p>非得拽一下，就是 <code>parser</code> -&gt; <code>interpreter</code></p><p>所以问题拆解成两个实现：</p><ul><li>一个通用的 converter</li><li>若干个 extensions (e.g. i18next-extension)</li></ul><h3 id="Converter">Converter</h3><p>开始解决第一个问题：excel -&gt; 「AST」</p><p>刚刚有提到这个文件的格式：</p><blockquote><p>第一列是 key，第二列开始是每个语言对应的翻译</p></blockquote><p>这个时候我们可以用一个结构体描述</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct LangPosition &#123;  name: String,  position: usize&#125;</code></pre><p>开始构建工作列表。假设这里有 6 种语言，那么就可以包装成 <code>[LangPosition; 6]</code></p><p>但是对于程序执行中不可能知道具体数量，所以构建一个 <code>Vec&lt;LangPosition&gt;</code>，通过扫标题来获取「有多少语言」。类似这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let header &#x3D; range.rows().next().ok_or(Error::Msg(&quot;Empty sheet&quot;))?;let mut lang_list &#x3D; Vec::&lt;LanguagePosition&gt;::new();for (i, cell) in header.iter().enumerate() &#123;    if let Some(language) &#x3D; cell.get_string() &#123;      &#x2F;&#x2F; 把语言和列索引加入 HashSet      lang_list.push(LanguagePosition &#123;          language: language.to_string(),          position: i,      &#125;)    &#125;&#125;</code></pre><p>现在已经知道了每个语言的对应关系，当需要生成某个语言的翻译文件，只需要让 <code>Extension</code> 处理这个 <code>LanguagePosition</code> 即可</p><p>但并不是，这里只是有某个语言和它的位置，现在需要做的是把 <code>key</code> 和某个语言的 <code>value</code> 对应起来并变成一个列表，所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct Atom &#123;  &#x2F;&#x2F; key  key: String,  &#x2F;&#x2F; 与之对应的 i18n value  value: String,&#125;</code></pre><p>接下来要遍历 <code>Vec&lt;LanguagePosition&gt;</code>，并且「按照单个语言为单位，通过 Extension 执行输出」。这里会用到一个 crate：<code>rayon</code></p><p><code>rayon</code> 是一个并行计算库，即可以使遍历这种事以多线程的方式运行，且无数据竞争。这对这个需求来说非常好 —— 每个语言的处理其实都很独立</p><p>所以这里要做的就是：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use rayon::prelude::*;lang_list.par_iter().for_each();</code></pre><p>按照 <code>row[0]</code> 是对应的 key，而 <code>row[position]</code> 则是对应 language 的翻译，就可以很方便给每种语言生成 <code>Vec&lt;Atom&gt;</code></p><p>接着顺便将这个列表丢给 <code>Converter</code> 的 <code>generate</code> 方法，<code>generate</code> 方法会调用对应的 Extension</p><p>所以应该补充一下，<code>Converter</code> 的结构：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct Converter &#123;  processor: Option&lt;Box&lt;dyn Extension&gt;&gt;,&#125;</code></pre><p>ok，来活了！为什么 <code>Option</code></p><p>其实这里要的很简单：初始化 Converter 的时候可以先不提供，由 <code>converter.register</code> 注册 Extension 并形成链式调用出去</p><p>这样做的目的是，当以后会有多个 Extension 想并行处理，则直接改成 <code>processors</code> 并且 <code>register</code> 可以变成以一种 <code>processors.push</code> 的形式</p><p>所以初始化 <code>Converter</code> 的时候，<code>processor</code> 可以是 <code>None</code>，并且当 Extension 是 <code>None</code> 时也可以直接处理异常，甚至是啥都不做，提醒一下然后直接退出</p><p>但是 <code>dyn Extension</code>？</p><h4 id="dyn-impl">dyn / impl</h4><p><code>dyn</code> 指动态分发，在运行时确定真正的返回类型。而 <code>impl</code> 与之对应即静态分发，编译期决定返回类型</p><p>换句话说，当要实现多态时，事实上是很难甚至是没办法知道「到底实现 Trait 的是谁」，只有真正运行起来才知道</p><p>但不管运不运行，只要是「鸭子模型」就都无所谓。而在程序之间传递的变量甚至是返回值，其实是可以知道「这个 <code>Struct</code> 就是实现了这个 <code>Trait</code> 甚至要求实现」，所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">fn register(self, ext: impl Extension + &#39;static) &#123;&#125;</code></pre><p>而且，dyn，dynamic，意味着编译时也无法确定 size，所以只能进堆，所以需要 <code>Box</code>，在 2018 之前处理这种情况是 <code>Box&lt;Trait&gt;</code>，在 2018 之后就变成了 <code>Box&lt;dyn Trait&gt;</code></p><p>为什么 2018？因为这俩是在 2018 Edition 新加的</p><h3 id="Extension">Extension</h3><p>一切准备好之后，意味着单个工作流内，会有一个<code>Vec&lt;Atom&gt;</code>等着挨处理，这个时候 Extension 只要要求实现 <code>transform</code> 就好了，或者说至少实现 <code>transform</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">trait Extension: Sync &#123;  &#x2F;&#x2F; 要求是 String 方便下一步写入文件  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String&#125;</code></pre><p>另外再实现 <code>ToString</code>，这一步是为了用户交互时可以 <code>print</code> 出当前正在使用什么扩展</p><p>其实应该实现 <code>Display</code>的，但是实现 <code>Display</code> 需要处理所有权的问题。例如我把 Extension 提供给 <code>register</code> 之后，所有权也对应转移。这个时候还要考虑 <code>Copy</code> 或者 <code>Clone</code> 就显得很麻烦</p><p>所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">trait Extension: ToString + Sync &#123;  &#x2F;&#x2F; 要求是 String 方便下一步写入文件  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String&#125;</code></pre><p>剩下要做的，就是看需求实现对应的 Extension，例如 <code>I18NextExt</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct I18NextExt;impl Extension for I18NextExt &#123;  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String &#123;&#125;&#125;</code></pre><p>实际上在 Extension 和 Language 还做了一些额外的工作，但跟核心思路无关且不太好说，应该就这样差不多了</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/12/16/build-xls2json-with-rust/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我必须立刻在 Tauri 跑 WebRTC</title>
      <link>https://colmugx.github.io/blog/2023/07/26/tauri-signal-server/</link>
      <guid>https://colmugx.github.io/blog/2023/07/26/tauri-signal-server/</guid>
      <pubDate>Wed, 26 Jul 2023 14:39:55 GMT</pubDate>
      
      <description>&lt;p&gt;按照需求，本来实现 &lt;code&gt;WebSocket&lt;/code&gt; 的目的是收发 &lt;code&gt;Banshee&lt;/code&gt; 的消息（主要是收）&lt;/p&gt;
&lt;p&gt;后面突然灵光一闪：上个 &lt;code&gt;WebRTC&lt;/code&gt; 怎么样？于是开始一段「为了醋包饺子」的心路历程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虽说原本是为了本地调试，但这套技术很明显内网都能用&lt;/li&gt;
&lt;li&gt;如果有一个「授权」对话，那么就可以在内部进行「远程问诊」&lt;/li&gt;
&lt;li&gt;测试或者验收遇到什么问题，望闻问切的第一步是&lt;strong&gt;望&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Remote Display / Remote Desktop&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;TL-DR-9&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;调整 &lt;code&gt;WebSocket&lt;/code&gt; 支持的实现&lt;/li&gt;
&lt;li&gt;实现信令服务器部分&lt;/li&gt;
&lt;li&gt;因为流量都在内网，所以不需要转发（STUN）&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>按照需求，本来实现 <code>WebSocket</code> 的目的是收发 <code>Banshee</code> 的消息（主要是收）</p><p>后面突然灵光一闪：上个 <code>WebRTC</code> 怎么样？于是开始一段「为了醋包饺子」的心路历程：</p><ol><li>虽说原本是为了本地调试，但这套技术很明显内网都能用</li><li>如果有一个「授权」对话，那么就可以在内部进行「远程问诊」</li><li>测试或者验收遇到什么问题，望闻问切的第一步是<strong>望</strong></li><li><strong>Remote Display / Remote Desktop</strong></li></ol><h2 id="TL-DR-9">TL;DR</h2><ul><li>调整 <code>WebSocket</code> 支持的实现</li><li>实现信令服务器部分</li><li>因为流量都在内网，所以不需要转发（STUN）</li></ul><span id="more"></span><h2 id="什么是-WebRTC">什么是 WebRTC</h2><p>WebRTC（Web Real-Time Communications）是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。对于原生客户端（例如 Android 和 iOS 应用），可以使用具备相同功能的库</p><p>一言以蔽之：跟打电话一样</p><h2 id="调整实现">调整实现</h2><p>虽然 rust 有 <code>WebRTC</code> 实现，数据处理可以直接在应用后端搞定，但为了方便（浏览器支持才是原生支持），我希望将数据转发到应用前端，使用 <code>TypeScript</code> 完成</p><p>所以上一篇提到的 <code>WebSocket</code> 实现需要调整：监听 tauri 的 <code>Event</code> 并从 <code>WebSocket</code> 转发出去；监听 <code>WebSocket</code> 跟 <code>WebRTC</code> 相关的信息并从 tauri 的 <code>Event</code> 转发出去</p><p>麻就麻在这，有两套观察者互相套起来了</p><p>TODO: 已经忘记具体是什么问题了，总之我是这么解决的</p><h3 id="只要阻塞就拆线程">只要阻塞就拆线程</h3><p>tauri 的 <code>Event</code> 同样会因为监听的关系出现上一篇文章关于 <code>socket.recv</code> 的问题，一旦阻塞就拆线程</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">spawn(async move &#123;    &#x2F;&#x2F; FTN mean Frontend to Native    t.listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        sender            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);</code></pre><p>但是如果这么写的话，就会被编译器叼柒：<code>sender</code> 的生命周期可能没那么长（闭包还异步闭包）</p><p>彳亍。先借一下广播解决一下这个问题：广播跟 <code>sender</code> 同一层作用域，通过广播来转发这层数据，回收时间一致</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (tx, _) &#x3D; broadcast::channel(100);spawn(async move &#123;    t.get_win().listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        tx            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);</code></pre><p>接着，广播收到包之后，就要转发给 <code>WebSocket</code> 让它发出去</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let mut rx &#x3D; tx.subscribe();spawn(async move &#123;    let mut sender &#x3D; sender.lock_owned().await;    while let Ok(msg) &#x3D; rx.recv().await &#123;        if sender.send(msg).await.is_err() &#123;            break;        &#125;    &#125;&#125;);</code></pre><p>跟住就又碌柒：如果这么写，<code>tx</code> 的所有权早在刚刚 <code>send</code> 那层就转移了(move)</p><p>彳亍。先解决问题：<code>clone</code> 一份</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (tx, _) &#x3D; broadcast::channel(100);let tx_for_tauri_send &#x3D; tx.clone();spawn(async move &#123;    t.get_win().listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        tx            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);let mut rx &#x3D; tx.subscribe();spawn(async move &#123;    while let Ok(msg) &#x3D; rx.recv().await &#123;        if sender.send(msg).await.is_err() &#123;            break;        &#125;    &#125;&#125;);</code></pre><p>这个解决方式只能说是为了快速实现而写的，我认为它有很大重构空间（但重构也不更新文章）</p><h2 id="实现信令服务">实现信令服务</h2><p>这个需求的场景相当于永远只有固定一方拨（<code>banshee</code> 侧），固定一方接(<code>cockpit</code> 侧)，所以这里的「信令」服务相当于只转发了 <code>SDP</code> 和 <code>ICE</code>，其他啥都没做</p><p>因为 tauri 这边已经将前端和后端用 <code>Tauri Event</code> 打通，接入前端跟 <code>Tauri App</code> 用 <code>WebSocket</code> 打通，所以只需要在接入前端侧实现 <code>Offer SDP</code> 并将 <code>mediaDevices.getDisplayMedia</code> 的数据 <code>addTrack</code>，拿到 <code>ICE</code> 发送出去</p><p>而 tauri 这边只需要等收到 <code>Offer SDP</code> 之后换一个 <code>Answer SDP</code> 回去即可在内网环境内传输音视频</p><p>因为这部分哪里都是一样的就不贴实现，全靠 <code>RTCPeerConnection</code></p><h2 id="References">References</h2><ul><li><a target="_blank" rel="noopener" href="https://webrtc.org/getting-started">https://webrtc.org/getting-started</a></li><li><a target="_blank" rel="noopener" href="https://github.com/webrtc-rs/webrtc">https://github.com/webrtc-rs/webrtc</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/tauri/">tauri</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/07/26/tauri-signal-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我必须立刻在 Tauri 跑 WS</title>
      <link>https://colmugx.github.io/blog/2023/07/25/tauri-ws-server/</link>
      <guid>https://colmugx.github.io/blog/2023/07/25/tauri-ws-server/</guid>
      <pubDate>Tue, 25 Jul 2023 14:29:19 GMT</pubDate>
      
      <description>&lt;p&gt;其实开发一个程序思路一直都是一致的，并不会因为是前端就会差/简单多少。再加上之前因为有「多端」这个「产品概念」之后，所以程序上一直在解决一个问题：如何将 Web 之外的逻辑固定下来？于是有了 &lt;code&gt;Banshee&lt;/code&gt;，下次细说&lt;/p&gt;
&lt;p&gt;既然有一个框架了，并且也选择使用跟 &lt;code&gt;Angular&lt;/code&gt; 类似的 root 级 DI 这种路线之后，开始有一个想法：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;流向很清晰，这个时候有一个测试监控一体机是不是实现方便作用不小？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;于是有了 &lt;code&gt;Banshee Cockpit&lt;/code&gt;，但它也跟 &lt;code&gt;Banshee&lt;/code&gt; 一样，下次细说&lt;/p&gt;
&lt;p&gt;又到了技术选型环节：早在三年前就尝试的 electron 方案 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/electron-react-koa-template&quot;&gt;electron-react-koa-template&lt;/a&gt;（已归档），当时是为了直接在树莓派运行智能闹钟程序时顺便提供 API 以远程操控，所以让 &lt;code&gt;electron&lt;/code&gt; 附带的 &lt;code&gt;node&lt;/code&gt; 跑起来一个 &lt;code&gt;koa&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;でも、选型依然是我目前的经典搭配：Tauri + Solid。那首先要解决的有两个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;还是一样，需要跑一个 server&lt;/li&gt;
&lt;li&gt;因为需要收发 &lt;code&gt;Banshee&lt;/code&gt; 的信息，所以需要 &lt;code&gt;WebSocket&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;h2 id=&quot;TL-DR-10&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;你可以直接用 &lt;code&gt;Rust&lt;/code&gt; 提供的基础库，但我用 &lt;code&gt;axum&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;集成起来很方便，麻烦的是 &lt;code&gt;Rust&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;摆烂了，&lt;code&gt;Rust&lt;/code&gt;对于内存的执着有种让人想一拳打爆屏幕的冲动&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>其实开发一个程序思路一直都是一致的，并不会因为是前端就会差/简单多少。再加上之前因为有「多端」这个「产品概念」之后，所以程序上一直在解决一个问题：如何将 Web 之外的逻辑固定下来？于是有了 <code>Banshee</code>，下次细说</p><p>既然有一个框架了，并且也选择使用跟 <code>Angular</code> 类似的 root 级 DI 这种路线之后，开始有一个想法：</p><blockquote><p>流向很清晰，这个时候有一个测试监控一体机是不是实现方便作用不小？</p></blockquote><p>于是有了 <code>Banshee Cockpit</code>，但它也跟 <code>Banshee</code> 一样，下次细说</p><p>又到了技术选型环节：早在三年前就尝试的 electron 方案 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>（已归档），当时是为了直接在树莓派运行智能闹钟程序时顺便提供 API 以远程操控，所以让 <code>electron</code> 附带的 <code>node</code> 跑起来一个 <code>koa</code></p><p>でも、选型依然是我目前的经典搭配：Tauri + Solid。那首先要解决的有两个问题：</p><ol><li>还是一样，需要跑一个 server</li><li>因为需要收发 <code>Banshee</code> 的信息，所以需要 <code>WebSocket</code></li></ol><h2 id="TL-DR-10">TL;DR</h2><ul><li>你可以直接用 <code>Rust</code> 提供的基础库，但我用 <code>axum</code></li><li>集成起来很方便，麻烦的是 <code>Rust</code></li><li>摆烂了，<code>Rust</code>对于内存的执着有种让人想一拳打爆屏幕的冲动</li></ul><span id="more"></span><h2 id="选个框架">选个框架</h2><p>原因还是跟三年前一样，从 NIO 开始是没必要的，集成一个服务端框架更方便使用。</p><p><code>Rust</code> 现在「主流」的服务端框架有三种：</p><ul><li>actix-web</li><li>rocket</li><li>axum</li></ul><h3 id="actix-web">actix-web</h3><p>作为我最喜欢的框架（在该文章之后已经易位），有活肯定是第一个想到，就是<strong>不知道怎么塞进去</strong>比较可惜</p><p>更大的原因是因为 actix 和 tauri 使用了两套异步逻辑，即使让 actix 运行起来了效果也不好。GitHub 也有一个类似的<a target="_blank" rel="noopener" href="https://github.com/tauri-apps/tauri/discussions/2942">相关讨论</a></p><p>而且还有一个我之前没发现的，作为客户端问题也很大的问题：这 B 东西体积有点大</p><h3 id="Rocket">Rocket</h3><p>Rocket 集成起来非常简单，只需要在 tauri 的 <code>main</code> 程序挂一个 <code>tokio</code> 入口或者是 <code>launch</code>，并且在 <code>setup</code> 把相关的上下文带进去，很轻松就完成</p><p>当我拿出香槟 🍾 打开的一瞬间，我发现有一个更大的问题：Rocket 不支持 <code>WebSocket</code>…</p><p>直接抬走</p><h3 id="axum">axum</h3><p>在 AI 时代之前获取信息全靠「漫反射」，但 AI 之后就不一样了</p><p>孤陋寡闻的我只知道两个框架，两个框架之后就没活了。但现在我可以打开之前跟我<a href="/blog/2023/04/02/chatgpt-novel/">一起写小说</a>的 <code>Bing AI</code>，从那得知还有一个体积不大性能也不错的新秀 <code>axum</code>。当我看到开发它的组织是 <code>tokio-rs</code>，直接上了</p><h2 id="跑个-server">跑个 server</h2><p>跑起来确实也没什么感觉，虽然可以直接跟着当前线程执行，但我还是为了方便还是多开一个线程跑 server，毕竟不是 <code>JavaScript</code> 不阻塞</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F; create servertauri::async_runtime::spawn(async move &#123;    server::create_server(&amp;main_window).await;&#125;);</code></pre><p>剩下的跟直接用 <code>example</code> 没有区别，直接跑个 Hello World 也就这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">async fn create_server() &#123;    let app &#x3D; Router::new().route(&quot;&#x2F;&quot;, get(handler));    let addr &#x3D; SocketAddr::from(([127, 0, 0, 1], 3000));    println!(&quot;listening on &#123;&#125;&quot;, addr);    axum::Server::bind(&amp;addr)        .serve(app.into_make_service())        .await        .unwrap();&#125;async fn handler() -&gt; Html&lt;&amp;&#39;static str&gt; &#123;    Html(&quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;)&#125;</code></pre><p>因为我们的需求是跑一个 <code>WebSocket</code>，按照 example 改改可以得到这个</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub async fn create_server(win: &amp;Window) &#123;    let app_state &#x3D; AppState &#123;        communication: Communication::new(win.clone()),    &#125;;    let server_app &#x3D; Router::new()        .route(&quot;&#x2F;cockpit-connect&quot;, get(ws_handler))        .with_state(Arc::new(app_state));    let port &#x3D;        find_available_port().expect(&quot;No available port found in default, please provide a port.&quot;);    let addr &#x3D; SocketAddr::from(([127, 0, 0, 1], port));    println!(&quot;Server running on port &#123;&#125;&quot;, port);    axum::Server::bind(&amp;addr)        .serve(server_app.into_make_service())        .await        .unwrap();&#125;async fn ws_handler(ws: WebSocketUpgrade, State(state): State&lt;Arc&lt;AppState&gt;&gt;) -&gt; impl IntoResponse &#123;    ws.on_upgrade(move |socket| handle_socket(socket, state))&#125;async fn handle_socket(socket: WebSocket, state: Arc&lt;AppState&gt;) &#123;    while let Some(msg) &#x3D; socket.recv().await &#123;        match msg &#123;            &#x2F;&#x2F; 这个需求不使用 text 传输            Ok(Message::Binary(data)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 想用可以这么用            &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;            &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)            &#x2F;&#x2F; &#125;            Ok(Message::Close(_)) &#x3D;&gt; &#123;               println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            Err(e) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理            _ &#x3D;&gt; &#123;&#125;        &#125;    &#125;&#125;</code></pre><h2 id="rust-经典臭问题">rust 经典臭问题</h2><p>到这会发现，如果使用了 <code>socket.recv</code> 还想在 <code>socket.send</code>，<code>socket</code>这个参数开始有「所有权问题」，你只能在<code>socket.recv</code>的作用域内用<code>socket.send</code>。这就相当抽象：只能回复是吧</p><p>好在这不是一个非常见问题，毕竟在不同作用域里处理信息和发送信息是一个非常常见的需求。搜了一圈，发现可以用 <code>stream::StreamExt</code> 和 <code>SinkExt</code> 拆分一个流</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (sender, mut receiver) &#x3D; socket.split();while let Some(msg) &#x3D; receiver.next().await &#123;    match msg &#123;        &#x2F;&#x2F; 这个需求不使用 text 传输        Ok(Message::Binary(data)) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        &#x2F;&#x2F; 想用可以这么用        &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;        &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)        &#x2F;&#x2F; &#125;        Ok(Message::Close(_)) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        Err(e) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理        _ &#x3D;&gt; &#123;&#125;    &#125;&#125;</code></pre><p>现在看起来收发自由了，但是当进入到 <code>receiver</code> 时，整个应用会像冻结了一样，下面的逻辑都无法执行到，也就变成了：只要没收到信息，所有要发送的信息都发不出去…</p><p>好在这也不是一个非常见问题，因为好像除了 <code>JavaScript</code> <s>这种垃圾语言</s>都是这样的 —— 都是同步阻塞类型</p><p>所以我暂时先这么做：将处理信息的逻辑送到另一条线程</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">spawn(async move &#123;    while let Some(msg) &#x3D; receiver.next().await &#123;        match msg &#123;            &#x2F;&#x2F; 这个需求不使用 text 传输            Ok(Message::Binary(data)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 想用可以这么用            &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;            &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)            &#x2F;&#x2F; &#125;            Ok(Message::Close(_)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            Err(e) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理            _ &#x3D;&gt; &#123;&#125;        &#125;    &#125;&#125;)</code></pre><p>现在基本上做到了收发自由</p><h2 id="References-2">References</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/tokio-rs/axum">https://github.com/tokio-rs/axum</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/tauri/">tauri</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/07/25/tauri-ws-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>写代码还有激情吗?</title>
      <link>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/</link>
      <guid>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/</guid>
      <pubDate>Thu, 20 Jul 2023 13:27:31 GMT</pubDate>
      
      <description>&lt;p&gt;在今年的上半年，看以前以码为友的群，群主在逼问一个群友。详情看这个吧&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://2nthony.com/posts/passion-of-coding&quot;&gt;写代码还有热/激情吗? - 2nthony&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话，代码这个事情想到还是会激情澎湃，每天还是能维持非常活跃的「创作」思维。但是写代码，还是淡了&lt;/p&gt;
&lt;p&gt;原因有很多，体力、生活、工作……&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在今年的上半年，看以前以码为友的群，群主在逼问一个群友。详情看这个吧</p><p><a target="_blank" rel="noopener" href="https://2nthony.com/posts/passion-of-coding">写代码还有热/激情吗? - 2nthony</a></p><p>说实话，代码这个事情想到还是会激情澎湃，每天还是能维持非常活跃的「创作」思维。但是写代码，还是淡了</p><p>原因有很多，体力、生活、工作……</p><span id="more"></span><h2 id="关于体力">关于体力</h2><p>别不承认，确实会随着年龄增长而感觉力不从心。刚毕业的时候能因为热情莽它个凌晨3点，第二天8天照样醒来去上班。相当于一天 <strong>仅需要 6 小时</strong> 睡眠时间就可以满足一天的生活</p><p>现在是做不到了，回到家会明显感受到疲倦。可以说现在上班因为「不纯粹」导致花费太多的精力，下班了再看到电脑只会想起白天的事情，故大多数时间不想使用电脑</p><p>也可以说剩余的精力确实无法支持了，以至于其实很多时候都会想「如果有机器能直接让我的想法变现就好了，不是要无中生有变成产品，我可以颅内编程」</p><h2 id="关于工作">关于工作</h2><p>Actually，上班时还是有写一些东西。这两年都在实现「无框架化」的操作。</p><blockquote><p>AVR is evil – Phodal</p></blockquote><p>写了两个东西：</p><p>第一个是对业务的沉淀，实用型库。大多数 infrastructure 类型的例如 <code>Request</code>, <code>Tracking</code> 都是 Adaptor Pattern</p><p>第二个是框架化的实践。我希望把整洁架构和六边形架构都融合到前端项目中来，因为我们接下来的项目属于是中型长线更新型项目，严格意义上并不算「前端」，所以有完整的测试和 DDD 明显会更好。主要技术还是 DI 和单例，CQRS, ES 我们都会包含到框架里</p><p>并且很明显，第二个产品会提供 adaptor port 给第一个产品，也就是第一个产品的 <code>Request</code> 和 <code>Tracking</code> 等等也会有 adaptor 接到框架，也就是 Application - Adaptor - Adaptor…</p><p>但显然两个框架都在我手里，interface 是一样的就完事儿了</p><p>除此之外还有一个远程观察/调试工具也正在开发，我觉得很有意义。例如远程请求拦截，观察应用运行状态，甚至直接观察操作（WebRTC 可以做到）</p><p>第二第三是计划开源，到时候看内部情况</p><h2 id="关于生活">关于生活</h2><p>确实生活的影响也很大，除了说自身身体之外，生活上的事情也会影响到我。但我确实不喜欢讨论自己的生活</p><p>其实可以盘算一下，我已经立项的项目到现在都过了多久</p><ul><li>nlvi 3.0：19年，直接放弃</li><li>nlvi Next：20年，没有进展</li><li>resumer：20年，因为简历直接没有需求所以不做</li><li>kazusa：20年开始，22年调整方向，至今只是能读取文件</li><li>setsuna：20年提到，21年还在技术选型，至今没有像样的逻辑</li><li>ayaka：22年提出，只能说实现一个 SPA Blog 的话能勉强算是一个 POC</li><li>evolution pong：21年刚到游戏公司，想如果以 pong 为原型不断加入玩法看能有什么效果的实验，但只完成基本功能</li><li>……</li></ul><p>坑多，每个坑的规划（项目管理）做得不好，加上设计不充分。导致每次打开电脑想开始某一段开发时，总会被各种问题困扰或者无法推进，最终只会是「先想想还没想好」而终止开发</p><p>加上现在会投入很多时间给自己的生活，可能原本周末会坐下来，即使只是坐着没有推进，但还是会验证一两个技术问题。而现在……</p><h2 id="所以">所以</h2><p>flappy bird。只要点击屏幕，bird 就会稍微抬头；但只要放弃点击屏幕，bird 就会下坠，而且是重力下坠</p><p>当我觉得「还是要放弃吗」的时候，我会去看看曾经的自己，看看曾经也对此有过激情的朋友们：包括不限于 yuexun, 2nthony，或是 Randy</p><p>其实我已经慢慢变得对信息不太敏感，也不知道现在该去哪里看什么东西。我也曾经让 4ark 推荐我一些 RSS</p><p>当我发现 yuexun 还会去参加 RustConf 的时候我还是会先是羡慕，然后想</p><p>我是否还是程序员？</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%80%9D%E8%80%83/">思考</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>跟 ChatGPT 共同创作？</title>
      <link>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/</link>
      <guid>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/</guid>
      <pubDate>Sun, 02 Apr 2023 08:59:50 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;/blog/Image/bingai-dalle.jpeg&quot; alt=&quot;Bing 调用 DELL-E 生成结局场景&quot;&gt;&lt;/p&gt;
&lt;p&gt;不讲虚的，直接开始&lt;/p&gt;
&lt;p&gt;正文在最后一个章节，爱看不看&lt;/p&gt;
&lt;p&gt;如果你选择阅读，希望你可以猜测一下：哪部分内容由 AI 生成的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips: 不一定是成片的内容，全程有来有回&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-2&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配合的版本是 Bing AI&lt;/li&gt;
&lt;li&gt;出于这B的限制，文章除了是多次对话拼接而来，还需要应对实时更新问题&lt;/li&gt;
&lt;li&gt;联网、实时的 ChatGPT 更令人害怕&lt;/li&gt;
&lt;li&gt;颠覆了原本我对 NLP 原本的理解&lt;/li&gt;
&lt;li&gt;用于文学创作还是太硬，它依然还是“计算机思维” —— 效率达成目的&lt;/li&gt;
&lt;li&gt;AI 经常忘记上标点（别利用这一点去猜，我手动补上了）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;就是一个字：害怕，非常害怕&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="/blog/Image/bingai-dalle.jpeg" alt="Bing 调用 DELL-E 生成结局场景"></p><p>不讲虚的，直接开始</p><p>正文在最后一个章节，爱看不看</p><p>如果你选择阅读，希望你可以猜测一下：哪部分内容由 AI 生成的？</p><p><strong>Tips: 不一定是成片的内容，全程有来有回</strong></p><h2 id="TL-DR-2">TL;DR</h2><ul><li>配合的版本是 Bing AI</li><li>出于这B的限制，文章除了是多次对话拼接而来，还需要应对实时更新问题</li><li>联网、实时的 ChatGPT 更令人害怕</li><li>颠覆了原本我对 NLP 原本的理解</li><li>用于文学创作还是太硬，它依然还是“计算机思维” —— 效率达成目的</li><li>AI 经常忘记上标点（别利用这一点去猜，我手动补上了）</li></ul><h2 id="总结">总结</h2><p>就是一个字：害怕，非常害怕</p><span id="more"></span><p>我用的是 Bing AI，并不是说 GPT3.5 或是 GPT4 不好，而是后者对我来说有点麻烦，不如微软爹的东西直接打开就能用，加上本来就是 Microsoft Edge 的用户，不存在专门下个浏览器</p><p>大多数情况下我们配合得还算很好的，基本上即使分成了很多个会话（我有时候会想看更多发展，会打开三个标签页同时接一样的内容），虽说生成的内容不是很喜欢，<strong>但大致思路是很接近的，甚至 AI 给我提供了一些事件和制造节奏的思路</strong></p><p>过程上真的一边写一边笑，在想这怕不是日系故事有套路，都这么写；AI 是不是先知道了「暗恋和表白」的结果所以一有机会就 A 上去；这个发展真的，我来我也这么做（x</p><p>加上我的提示语其实不多，而且这个属于创作类型的使用类型，所以很有意思</p><p>实际上在预训练时就已经把几乎「能看的所有东西」都过了一遍，知书达理，博学多才应该是「非常正常」的事，<strong>直到我看到它去搜索</strong>了「日本高中毕业」、「薰衣草的寓意」等等我们在续写过程中出现的一些关键词，并像原本聊天问答一样经过理解之后<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，这时<strong>不是对所有搜索到的资料进行一个总结，而是继续代入回「小说」这个语境再继续续写工作</strong>，并且它依然能把它续写的相关内容画上虚线。我看着对话底下的「了解详细信息」，真的令人感到害怕。</p><p><img src="/blog/Image/bingai-1.png" alt="Bing AI 搜索剧情发展所需信息"><br><img src="/blog/Image/bingai-2.png" alt="Bing AI 根据信息续写"><br><img src="/blog/Image/bingai-3.png" alt="Bing AI 信息来源"></p><p>总的来说，我非常喜欢这次尝试结果，因为不管是剧情发展，还是人物性格，人物关系，我觉得 AI 都大致上是真的了解到的</p><p>只不过措辞和文字相对真正的作家可能显得稚嫩不成熟，加上我从来不看网文小说…</p><p>再挖个坑？因为这个小说的人物设计、背景、以及一些东西的含义我是真的设计过的，如果凑合的话，要不真的写一部正经的？这波自己写</p><h2 id="正文">正文</h2><p>叠甲：由于已经记不清到底打开了多少个对话才有这些内容，为了让每个对话（虽然上限是20条，但大多数都是到12 13就因为你用过就会懂的原因 AI 直接跳出）之间联系比较自然，衔接的部分一般都是我自己补上去的，但有时候太跳脱了，我也只是当做测试不会花太多时间，文案会显得很粗糙。<s>当然你也可能看不出衔接。</s></p><p>并且我会尽量给这些内容打个小节？也许它并不合适</p><blockquote><p>PROMPT:<br>我们现在开始故事接龙。接下来我会简单介绍一些背景和信息点：“女主会按照风铃草来设计，包括不限于性格，形象，名字等等。男主人公是一个非常普通的高中生，其他部分都交给你设计包括男主姓名。这是一个日系校园恋爱故事，故事发生在日本高中的毕业季，女主是喜欢一个同班的男同学也就是男主人公，一直暗恋不敢表白。最后在毕业那天，女主已经在想放弃和好好跟高中的生活告别了，但在离开校园大门前，发现男主正拿着一束风铃草在校门口等她。” 你可以搜索各种你认为需要的公开的资料。如果你准备好了就回答准备好了。我先写，你来续写。</p></blockquote><h3 id="1">1</h3><p>家里的院子里有一片风铃草，那是我妈妈种的。她说过，风铃草有着迷人的优点，并希望我能像风铃草一样。但她始终没有告诉我那是什么。</p><p>又是一个清晨，阳光穿过厚厚的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。这是我的同班同学，我们从小学就一直是同学，也是无话不说的闺蜜。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你从来不把发带直接扎在头发上，而是做成像边夹一样别在头上呢！”</p><p>“嗯，因为我觉得这样更有特色一点吧，而且我喜欢浅蓝色，就像风铃草一样”我笑着回答。</p><p>“风铃草？话说你家门口的那片植物是不是就是风铃草？”薰突然像是一个问题孩子，“风铃草是不是还有一个名字叫忘忧草？”</p><p>“忘……忧……草”我心里不断地想着这个词。是啊，我应该怎么面对我的忧愁呢……</p><p>我很在意一个人，他是我的同班同学，名叫悠太，是一个很普通的男生。他没有什么特别出众的地方，也不是什么学霸或者校草。但他看起来总是很安静，很专注，很有思想。他喜欢看书，喜欢音乐，喜欢观察周围的事物。他的眼神总是很深邃，很温柔，很有魅力……</p><p>“你是不是又在想那个男生了？你看你又是这样，突然魂就不知道飞到哪儿去了！”</p><p>我突然如惊醒一般，连忙转头看了一眼薰，她的五官都快以鼻子为中心挤成一团了，我感受到了薰涌上来满满的怨念。</p><p>“我真的很不明白你为什么对他这么在意！”薰越想越气，“他对所有人都爱理不理，这么多年也没见他参加过什么活动。他甚至会因为别人去打扰他而发脾气！”</p><p>“你快别这么说。”我拉了拉薰的衣角。</p><p>只听到薰话音刚落，薰的脸色又变得非常的甜美阳光，“你看那个连，长得好帅，不仅成绩很好，琴棋书画都很擅长。还有还有！身上总有一股迷人的，每天不重样的清香。”</p><p>我就这么看着薰光滑而圆润的脸上，又从一脸花痴相进行了一次一百八十度的渐变，“而且人家还很关心你！他对你多好啊！那么多喜欢他的女孩子他从来都不看一眼！我真的好羡慕你！噢~你是不是在吊着人家！你要是不喜欢人家能不能直接说！你不喜欢有的是人喜欢！”</p><p>“薰，你别说了，我真的不喜欢连。”我无奈地说道，“他虽然很优秀，很帅，很有才华，但是他不是我的类型。我对他没有任何感觉，也不想吊着他。”</p><p>“那你为什么不拒绝他呢？”薰不解地问道，“他已经向你表白了好几次了，你每次都说要考虑一下，你这样不是在耽误人家吗？”</p><p>“好了我们先不要聊这个话题了！”我们就这样走着走着，不知不觉到了校门口，“明天就是毕业典礼了，你有想过毕业以后的事情吗？”</p><p>“我还没有想过哎，你想过了吗？能不能告诉我你的计划啊铃酱~”</p><h3 id="2">2</h3><p>“我啊，我——”</p><p>“钟同学——”啊，这个声音，我跟薰回头一看，是连。</p><p>“早上好，钟同学，山本同学。”</p><p>“早上好连同学。”我下意识地瞟了一眼薰，果然她整个人都已经迷糊了。</p><p>“钟同学，你今天的发夹真可爱，很适合你呢。”</p><p>“谢谢”，我迅速回避掉他的眼神，心想：求求你能不能不要再在意我啊……我要怎么逃走啊……</p><p>“钟同学，我能跟你说一句话吗？”连突然说道，“其实我有一件事情想跟你说，很重要的事情。”</p><p>“什么事情？”我紧张地问道，“你说吧。”我隐隐约约感觉到，他又会说……</p><p>“其实……”连犹豫了一下，“其实我一直很喜欢你，我想跟你在一起。”</p><p>“啊……”我惊讶地看着他，不知道该怎么回答。</p><p>“钟同学，你不用马上回答我，你可以考虑一下。”连温柔地说道，“但是请你不要拒绝我，给我一个机会吧。”</p><p>“我们要快点去教室了！马上就开始上课了！”我给薰使了一个眼色。但薰好像没有看到，她一直在盯着连看。</p><p>“薰！！！”我大喊了一声，“马上上课了！！”</p><p>“啊…啊！我们要先去上课了！”薰依然还是眼巴巴的盯着连边看边说道，“不好意思啊，铃酱她总是这样……”</p><p>“快走啦！”，我拉着薰就跑了起来，往楼里奔去。</p><p>“等等，钟同学！”连追了上来，“你还没有回答我呢！”</p><p>“对不起，连同学，我现在不能回答你。”我说道，“我还有很多事情要考虑，我需要一些时间。”紧接着我拉着薰头也不回地往前跑。</p><p>好像已经甩开了，我心里这么想到。于是我们渐渐放慢脚步朝着自己的教室走去。</p><p>“铃兰，你怎么能这样呢？”薰责备我说，“你不是说你不喜欢他吗？怎么每次都这样！”</p><p>“可是……”我无奈地说，“可是他对我这么好，我真的又不忍心拒绝他。”</p><p>“那你就这样拖着他吗？”薰皱着眉头说，“你知道吗，你这样做对你自己也不好。”</p><p>“那我们就别再说这个了。”我打断了她，“我们还是聊回毕业典礼吧。你有没有准备什么礼物给老师和同学呢？”</p><p>“嗯……”薰想了想，“其实我还没有准备呢。你呢？”</p><p>“我也没有呢。”我说道，“不过我想送一些手绘的卡片给大家，上面画上他们的头像和一些祝福的话。亲手做的礼物也许更有意义呢”</p><p>“哇，你真是太有心了！”薰感动地说道，“你这样做一定会让大家都很开心的！”</p><p>“谢谢你。”我笑了笑，“其实我也有点舍不得毕业呢。毕竟我们在这里度过了三年多的时光，有过很多难忘的回忆。”</p><p>我们就这样聊着聊着，到了教室。教室里已经有不少同学了，他们都在互相打招呼。</p><p>我不急不缓移动到自己的座位上，坐下挂好自己的书包，突然感觉好像有谁看了我一眼。</p><p>我捕捉到悠太朝我脸上射出的视线，悠太似乎也发觉到了，瞬间收回他的眼神。他坐在窗边的座位上，手里拿着一本书，看得很专注。他没有跟任何人说话，也没有收到任何礼物。他就像一个孤岛，与周围的世界隔绝。透过窗户微弱的阳光溅射在他的身上，一切都如此平静和静谧。</p><p>“真的让人很好奇啊，他到底每天都在想些什么呢？”我不禁这样想。</p><p>“你又在看他，那个奇怪的男生。”薰走过来指着悠太摇头说道，“一点毕业的气氛都没有，他不会是觉得这样很酷吧？”</p><p>“可能他不喜欢这种场合吧。”我说道，“或者他有什么心事呢。”</p><p>“心事？”薰疑惑地问道，“他有什么心事啊？”</p><p>“我也不知道。”我摇摇头，“只是猜测而已。”</p><p>“我真的无法理解，你总是向着他。他明明也没对你做过什么事。”薰漠不关心地刷着她的手机。</p><p>“铃兰！铃兰！”薰突然非常激动地缠住我的胳膊，“快看快看！我收到了一封大学的录取通知书！”</p><p>“哇！你收到了录取通知书啊！”我惊讶地说道，“你可真是个幸运儿呢！”</p><p>“嘿嘿嘿~”薰得意地笑道，“那是当然啦！”</p><p>“那你被哪所大学录取了呢？”我问她。</p><p>“嗯……”薰想了想，“其实我报了好几所大学，这封是其中一所的。你呢？”</p><p>“我啊……我还没有收到任何录取通知书呢。”</p><p>“啊，真的吗？”薰关切地问道，“你不要着急，你一定会收到的。你是一个很优秀的女孩子，你的成绩也很好。我相信你会被你想去的大学录取的。”</p><p>“谢谢你。”我说道，“你真是个好朋友。”</p><p>“不客气。”薰笑着说道，“你要加油哦。”</p><p>我跟薰拥抱了一下，感受到了她的温暖和支持。我心里有些感动也有些紧张。我不知道我的未来会怎样，我能不能实现我的梦想，我能不能遇到我的爱人。但是我知道，无论如何，我都不会忘记我的高中生活。</p><h3 id="3">3</h3><p>就在这时，铃声响了。老师进来了。他手里拿着一本书和一张纸。</p><p>“同学们，请安静一下。”老师说道，“我想跟大家做一个小测试。”</p><p>“啊？小测试？”大家都惊讶地各自议论纷纷。</p><p>“这个小测试不是为了考核你们的知识，而是为了考核你们的心情。”老师说道，“这个小测试只有一个问题，就是：你对高中生活有什么感想？”</p><p>“这个问题……”大家都沉默了。</p><p>“你们可以用任何形式来回答这个问题，可以是文字，可以是图片，可以是音乐……只要能表达出你们的真实感受就行。”老师说道，“你们可以用纸笔来做这个小测试，时间限制在十分钟内。”</p><p>“老师，这个小测试有什么意义吗？”有人问道。</p><p>“这个小测试的意义就是让你们回顾一下自己的高中生活，感受一下自己的成长和变化。”老师说道，“也让你们有一个机会跟自己和大家说再见。”</p><p>“再见……”大家都低声重复了一遍。</p><p>“好了，开始吧。”老师说道。</p><p>大家都开始做起了小测试。有的人用手机打开了相册，翻看着自己的照片。有的人用纸笔写下了自己的心情。有的人用耳机听着自己喜欢的歌曲。</p><p>我决定用画画来回答这个问题。我想通过画表达我的高中生活的点点滴滴，我的快乐和悲伤，我的收获和失去，我的梦想和现实。</p><p>于是，我开始画起了薰衣草……</p><p>我觉得它很适合我，我知道他可能不会注意到我，也不会喜欢我，但是我还是忍不住对他抱有希望。我想用薰衣草来表达我的心情，也许他能感受到我的心意。</p><p>我画出了一片薰衣草田，上面有一只小鸟在飞翔。小鸟代表着自由和梦想，它可以飞向任何地方，也可以找到自己的伴侣。我希望自己也能像小鸟一样，能够追求自己的梦想，能够遇到自己的爱人。</p><p>我画出了一座小屋，里面有一张桌子和一把椅子。小屋代表着安静和思考，它可以让人放松和沉淀。我喜欢在小屋里看书，听音乐，画画。这些都是我跟悠太有共同的爱好，也是我们之间唯一的交集。我希望自己能在小屋里跟他相遇，能够跟他分享我的想法和感受。</p><p>我画出了一颗大树，上面挂着一个风铃。大树代表着坚强和成长，它可以抵御风雨和寒冷。我在高中生活中经历了很多困难和挫折，但是我没有放弃，而是努力学习和进步。</p><p>我把这些元素都组合在一起，形成了一幅美丽的画面。这就是我的高中生活的写照，也是我的心灵的映射。我对这幅画感到很满意，也很感动。这就是我的答案。</p><p>“你画得真好啊！”薰走过来看了看我的画说道，“这是什么花啊？”</p><p>“这是薰衣草。”我说道，“你不知道吗？”</p><p>“哦，原来是薰衣草啊。”薰说道，“它跟我的名字很像呢。”</p><p>“是啊。”我说道，“你知道它的花语吗？”</p><p>“不知道呢。”薰说道，“你告诉我吧。”</p><p>“它的花语是‘等待爱情’。”我说道。</p><p>“等待爱情？”薰重复了一遍，你觉得爱情是什么呢？“</p><p>“我觉得爱情是……”我想了想，“是一种心灵的契合，是一种灵魂的共鸣，是一种无法言喻的感觉。”</p><p>“哇，你说得好深刻啊！”薰赞叹道，“你是不是已经遇到了你的爱情呢？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰奇怪地问道，“你怎么会不知道呢？”</p><p>“因为……”我低下了头，“因为我喜欢的人可能不喜欢我。”</p><p>“啊，真的吗？”薰惊讶地说道，“你喜欢的人是谁啊？”</p><p>“他是……”我刚想开口，就听到了老师的声音。</p><p>“同学们，时间到了，请大家把自己的小测试交给我。”老师说道，“我会把你们的答案都收集起来，作为我们班级的纪念。”</p><p>大家都把自己的小测试交给了老师，老师一一收下，并且给出了一些评价和感想。轮到我的时候，老师看了看我的画作，赞叹道：</p><p>“铃兰同学，你的画真是太美了！你用薰衣草来表达了你对高中生活的感想，很有创意和深意。你是一个很有才华和情感的女孩子，你的画让我感动了。”</p><p>“谢谢老师。”我说道，“您也是一个很好的老师，您教了我很多知识和技巧。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了我的画作，然后走向了悠太。悠太也拿出了他的小测试，交给了老师。</p><p>我看到老师也很惊讶地看着悠太的画作，问道：“悠太同学，你的画也很美啊！你用风铃草来表达了你对高中生活的感想，很有——”</p><p>“什么？风铃草？！”正在走神的我突然听到了老师说悠太画的是风铃草，吓了一跳，本能地发出了“啊！”的声音。</p><p>“你怎么了？铃兰同学？”老师站在悠太座位边上朝我的方向看，“你刚刚遇到什么问题了吗？”</p><p>“没……没什么。”我尴尬地说道，“我只是有点惊讶而已。”</p><p>风铃草？为什么他会画风铃草呢？难道他也喜欢风铃草吗？还是他有什么别的寓意呢？</p><p>“惊讶什么？”老师问道。</p><p>“惊讶……”我瞟了一眼悠太的画作，“惊讶悠太同学画的是风铃草。”</p><p>“为什么会惊讶呢？”老师又问道。</p><p>“因为……”我不知道该怎么回答，只好编了一个理由，“嗯……我也喜欢风铃草，我也没想到悠太画的也是花。”</p><p>“哦，是这样啊。”老师笑了笑，“那真是巧合呢。你们两个都很有眼光，风铃草是一种很美丽的花，也很有寓意。”</p><p>老师转向了悠太，“你用风铃草来表达了什么感想呢？”</p><p>“没什么，就是单纯想画风铃草。”悠太说道，语气淡淡的，一如既往的冷静回答，仿佛人类的感情与他无关。</p><p>“就是单纯想画风铃草？”老师有些不解地问道，“你就没有什么特别的感想？”</p><p>“没有。”悠太摇摇头，“可能风铃草很好看，很有意思。”</p><p>“好看，有意思？”老师又问道，“展开讲讲？”</p><p>悠太想了想，“我喜欢风铃草的颜色，浅蓝色，很清新，很舒服。我喜欢风铃草的形状，像小铃铛，很可爱，很有趣。”</p><p>“原来如此。”老师点点头，“你对风铃草的描述很细致，很生动。你是一个很有观察力和感受力的男孩子，你的画让我印象深刻。”</p><p>“谢谢老师。”悠太说道，“您也是一个很好的老师，您教了我很多知识和技能。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了悠太的画作，然后走向了其他同学。我倾听着他跟老师的对话，心里有些疑惑也有些失落。他为什么只是单纯想画风铃草呢？他没有什么特别的感想吗？他对高中生活没有什么回忆和感情吗？他对我没有什么期待和祝福吗？</p><p>为什么他会画风铃草呢？难道他真的只是单纯想画而已吗？还是他有什么别的原因呢？</p><p>我想起了他平时的样子，总是一个人坐在角落里，看着书或者听着音乐，从不跟任何人交流。他总是那么冷漠，那么孤独，那么神秘。</p><p>他到底在想些什么呢？他到底喜欢些什么呢？他到底喜欢谁呢？</p><p>我突然感觉到一阵心跳加速，一阵脸红。我赶紧低下了头，不敢再看他。</p><p>是不是我想多了，也许他真的只是想画风铃草而已吧。或许他喜欢风铃草般的女孩子，跟我没有一点关系。或许……或许他根本就——</p><p>从来没把我放在眼里。</p><p>我突然感到一阵心痛，像是被刀刺了一下。我不敢再看他的眼睛，我不敢再听他的声音，我不敢再靠近他的身边。我只想逃离这里，逃离他，逃离自己。</p><p>就这样熬过了一整个上午，而我一整个上午都没有在听课。</p><p>“铃兰，你怎么了？”薰走过来，拍了拍我的肩膀，“你脸色很不好啊。”</p><p>“没……没什么。”我勉强笑了笑，“我只是有点累而已。”</p><p>“累？”薰关切地问道，“我们休息一下，正好，我们一起吃午饭吧。”</p><p>薰把我拉了起来，我跟薰走出了教室，向着室外走去。我回头看了一眼悠太的方向，发现他正看着我。我们的目光在空中相遇，然后又迅速分开。我感觉到我的心又跳了一下，然后又沉了下去。</p><p>这就是我们之间最后的交流吗？这就是我们之间最后的告别吗？</p><p>我不知道。我也不想知道。</p><p>我只想忘掉他。忘掉他的存在，忘掉他的影子，忘掉他的画作。</p><h3 id="4">4</h3><p>“今天天气好像是有点糟糕呢……我还以为早上只是太早了云层有点厚而已呢~”我尝试着找一个话题掩盖此刻的心情。</p><p>“你反应很大啊？”薰看着我有点虚弱的表情，也不忘记嘲笑我，“你该不会以为，那个男生真的是在意你吧？怎么你还不让人家喜欢风铃草了，你也不是风铃草啊。”</p><p>是噢，总不能因为我的名字带着铃，妈妈喜欢风铃草，我就强行占有了这个世界的风铃草吧。我不断这么安慰自己。</p><p>“当然不是，”我赶紧解释，“我没有在想风铃草的事”</p><p>“没有在想风铃草的事？”薰不信地说道，“那你刚才为什么会吓得那么厉害？”</p><p>“我……”我支支吾吾地说道，“我只是觉得很巧合而已。”</p><p>“巧合？”薰反问道，“你觉得这是巧合吗？”</p><p>“嗯，是啊。”我点点头，“这不是很正常的吗？”</p><p>“我的意思是，”薰摇摇头，“他都没有为你做过什么事情，你怎么就以为人家对你有意思。”</p><p>“我也没有这么想。”我忙否认道，“我只是觉得他很有才华。”</p><p>“哦，是这样啊。”薰不以为然地说道，“那你为什么不去告诉他呢？”</p><p>“告诉他？”我吃了一惊，“你是说，告白？”</p><p>“对啊，告白。”薰说道，“你不是喜欢他吗？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰无奈地摇摇头，“铃兰，你真是太胆小了。你知道明天结束，你可能再也见不到他了吗？”</p><p>“我知道。”我低下了头，“但是，我怕。”</p><p>“你怕什么？”薰问道，“你怕被拒绝吗？”</p><p>“不……”我摇摇头，“我怕失去他。”</p><p>“失去他？”薰不解地说道，“你本来就没有拥有过，你还能失去什么？”</p><p>“我……”我咬了咬嘴唇，“我怕失去这份感情。这份对他的喜欢，对他的敬佩，对他的思念。如果我告诉他，如果他拒绝了我，或者接受了我，那么这些感情就会消失。就像风铃草一样，随风而逝。”</p><p>“铃兰……”薰轻轻地叹了口气，“你真是太傻了。你知道吗？感情不是用来藏着的，而是用来表达的。如果你真的喜欢他，就应该勇敢地告诉他。也许他也喜欢你呢？也许他也在等你呢？也许你们可以在一起呢？虽然我还是不理解为什么你对他会这么在意。”</p><p>“可是……”我还想说什么，但被薰打断了。</p><p>“没有可是。”薰说道，“铃兰，如果你再不行动，就真的会后悔一辈子的。相信我，你不会想要那样的结果的。”</p><p>“薰……”我看着她真诚的眼神，感觉到她对我的关心和鼓励，但我还是拒绝了薰。</p><p>“还有一天时间呢，让我再好好想想吧”我把头低下来，感觉内心像一场风暴，翻滚着各种矛盾和冲突……</p><p>薰看着我，无奈地摇了摇头，她知道我是个固执的人，不会轻易改变主意的。她只好放弃了劝说我，转而换了一个话题。</p><p>“对了，铃兰，你知道吗？”薰说道，“今天下午有一个画展，好像是一个社团的作品展示。”</p><p>“社团？作品展示？”我稍微把头微微侧倾表示好奇，“绘画社？”</p><p>“是呀是呀，”薰从书包里拿出了一张传单，上面写着“致我们的高中生活”，还有一幅画作的缩略图。</p><p>“去看看吗？”薰说道。我看着薰，从她的脸上看到了非常感兴趣五个大字。</p><p>“去看看？”我疑惑地问道，“去哪里看？”</p><p>“去画展啊。”薰说道，“今天下午三点到五点，在学校的美术馆。我们一起去吧。”</p><p>“快点，快点。”她催促道，“我们还有半个小时就到画展开始了。我们不能迟到。”</p><p>“等等，等等。”我挣扎着说道，“我还没准备好呢。”</p><p>“没关系，没关系。”薰说道，“有我在呢。放心吧，一切都会好的。”</p><p>她带着我跑出了教室，向美术馆的方向飞奔而去。</p><h3 id="5">5</h3><p>我们跑到了美术馆的门口，看到了一排排的人在排队进入。我们也赶紧加入了队伍，等待着进入画展。</p><p>我看了看海报，上面有一幅画作，是一群高中生在校园里欢笑着。他们有的拿着书本，有的拿着乐器，有的拿着画笔，有的拿着球拍。他们的表情都很自然，很快乐，很真实。</p><p>“这幅画是谁画的啊？”我问道，“好厉害啊。”</p><p>“不知道呢。”薰说道，“可能是绘画社的社长吧。他应该是个很有才华的人。”</p><p>“是吗？”我说道，“你对他很感兴趣吗？”</p><p>“不是啦。”薰摇摇头说道，“我只是对他的画感兴趣而已。我想看看他还画了什么。”</p><p>“哦，这样啊。”我说道，“那我们快点进去吧。”</p><p>我们终于排到了门口，进入了美术馆。里面有很多画作，都是绘画社的成员们用心创作的。每幅画都有一个标题和一个简介，介绍了画作的背景和意义。</p><p>我们一边走一边看，不时地发出惊叹和赞美。有些画作让我们回忆起了自己的高中生活，有些画作让我们感受到了别人的高中生活。每幅画都有自己的故事和情感。</p><p>“你看，你看。”薰突然拉住了我的手，指着一幅画说道，“这幅画好熟悉啊。”</p><p>画作是一幅风景画，画面上是一片风铃草田，还有一对男女的背影。男生手里拿着一束浅蓝色的风铃草，单马尾女生则把头靠在男生的肩膀上。两人看起来很恩爱，很幸福。</p><p>我下意识地看了一眼右下角，一边看一边轻声读了出来：“《风铃草之恋》，作者：藤原悠——”</p><p>我突然倒吸一口凉气，感觉后背开始一点点发凉，又像是被谁揪住了一样，接着又觉得非常的不可思议——很自然地用双手捂住了自己的嘴和鼻子。</p><p>“这是……真的……？”我的眼神反复在画布上的内容和右下角的标签之间来回移动，一遍又一遍的确认。</p><p>“这是悠太画的？”薰凑近瞧了瞧，“还真的是！真没想到他还是绘画社的成员，原来他这么有东西！”</p><p>接着薰又用手肘顶了一下我的手臂，“哎哎，你说，他画得是真好，但是他是不是只会画风铃草啊？”</p><p>“但是，”薰说道，“多美啊，多浪漫啊。这就是他对爱情的理想吧。你说，这个女孩会不会就是他喜欢的人呢？”</p><p>我死死地盯着这幅画，感觉到我的心被刺了一下。这就是他心中的风铃草之恋吗？这就是他心中的女孩吗？那么，我在他心中又是什么呢？</p><p>“喂，喂！”，薰突然摇了一下我，“姐妹你别傻愣着鸭！开麦！开麦姐妹！”</p><p>“啊……啊！”，我突然如梦惊醒，扭头看了一眼薰，“没……没什么事……画得很好……是……看起来很幸福…嗯…对……”。我低下头，仿佛在想什么事情，又什么都没想。</p><p>“铃兰，你在说什么啊？”薰摇摇头说道，“你今天怎么了？”</p><p>“没有”，我非常轻声的回答了薰的问题，但这个声音已经微小到似乎仅仅是通过骨传导传递到我的耳朵而已。</p><p>“你觉得这个女孩，会是你吗？”薰挽着我的手，头微微低下，似乎在尝试观察头发背后的我此刻的表情。</p><p>我突然猛地一抬头，“什么？我？女孩？我？”</p><p>“是啊！”薰微微靠在我的肩上，“老师给我们的那道题，他画了风铃草。现在放在眼前的这幅画，内容也是风铃草……”</p><p>“其实我总是嘴上说说，但是我能感觉到，他可能对你有意思。”薰的头突然离开了肩膀，微微地晃动了一下，又贴到了肩上，“其实我都看到好多次，他总是在不经意间偷偷看你，又突然地甩断视线……”</p><p>我听着薰的话，心里一阵乱糟糟的。我真的很喜欢悠太，但是我从来没有勇气告诉他。我只是默默地关注着他，欣赏着他的才华，羡慕着他的自信。</p><p>我以为他心里有别的女孩，也许是那些漂亮的，聪明的，活泼的女孩。我以为他和我之间，只有风铃草这一点微不足道的联系。不，他不知道我的名字跟风铃草有关系，这根本不是联系。</p><p>“你说得对。”我终于开口说道，“这幅画真的很美，很浪漫。这就是悠太对爱情的理想吧。”</p><p>“那你呢？”薰问道，“你对爱情的理想是什么？”</p><p>“我……”我犹豫了一下，“我想……和喜欢的人在一起……就好了。”</p><p>“那你想好了没有？”</p><p>“想好……想好什么？”</p><p>这时薰的头彻底离开了我的肩膀，直勾勾的盯着我，“去做你想做的事！”</p><p>“可是……”我还想说什么，但是被薰打断了。</p><p>“别可是了。”薰重复道，“你要抓住机会啊。”</p><p>“可是……”我还想说什么，但是被薰拉着就往画展的出口走去。</p><p>“我们去哪里？”我问道，“不看了吗？”</p><p>“还看什么画展啊。”薰说道，“你都不是很想继续看了，我们回去找他啊。”</p><p>“找他？”我惊讶地问道，“找他干什么？”</p><p>“找他告白啊。”薰说道，“你不是喜欢他吗？你不是想和他在一起吗？”</p><p>“我……”我瞪大了眼睛，不敢相信自己的耳朵。</p><p>“你怎么了？”薰看着我，一脸的不解。</p><p>“你……你让我去告白？”我结结巴巴地问道，“你是认真的吗？”</p><p>“当然啦。”薰说道，“这不是很正常的吗？”</p><p>“不……不正常啊。”我说道，“这太突然了啊。我怎么能去告白啊。”</p><p>“为什么不能呢？”薰问道，“你有什么顾虑吗？”</p><p>“顾虑？”我说道，“顾虑太多了啊。万一他拒绝我怎么办？万一他嘲笑我怎么办？万一他觉得我很烦怎么办？万一他已经有喜欢的人怎么办？”</p><p>“哎呀，你想太多了。”薰说道，“你要有点自信啊。你又不是没有优点，你又不是没有魅力，你又不是没有人气。你为什么要自卑呢？”</p><p>“可是……”我依然被薰再次打断。</p><p>“画展先看到这吧，我们回教室。”</p><h3 id="6">6</h3><p>我们从美术馆出来，看到天空突然下起很大的雨，我们急忙跑到一个屋檐下，躲避着雨水。雨水顺着屋檐起伏间的缝隙，成股地滚了下来，重重地砸向了地面。</p><p>“哎呀，怎么会突然下这么大的雨啊。”薰抱怨道，“我们没有带伞啊。”</p><p>“是啊。”说完便观察周围的情况，看看能不能找到一条不会淋雨的路线回到教室。</p><p>“有了！”我突然喊了出来，“我们可以先沿着这个建筑边缘走，然后再穿过这个通道，中间可能有一点点路会淋到，但应该没问题。你可以吗？”</p><p>“我可以！我们先这样吧，先回到教学楼再想想怎么回家。”薰点了点头表示同意我的建议。</p><p>“那我们先这样，跑起来！”</p><p>我们跟着我的计划，沿着建筑边缘跑去，但是雨越下越大，我们的衣服和头发都被打湿了。我看了看薰，她的脸上有些苦恼，但也有些兴奋。她的眼睛在雨中闪闪发光，像是一颗星星。</p><p>“你没事吧？”我关心地问她。</p><p>“没事，就是有点冷。”她笑了笑，“不过这样也挺有意思的，就像是冒险一样。”</p><p>“是啊，我们好像是在逃亡。”我也笑了起来，“不过我们要快点，不然会感冒的。”</p><p>“嗯。”她点点头，加快了脚步。</p><p><strong>我们终于穿过了通道，来到了教学楼前。教学楼是一座四层的建筑，外墙是白色的，窗户是蓝色的。教学楼的门口有一个大大的屋檐，可以遮挡雨水。我们跑到屋檐下，松了一口气。</strong></p><p>“太好了，我们终于到了。”我说。</p><p>“是啊，真是太幸运了。”薰说，“不过我们现在怎么办？我们都湿漉漉的。”</p><p>“对啊。”我看了看自己的头发，“不过还好，我们先回教室休息，再找找有没有什么东西可以擦干。”</p><p>我们沿着走廊向教室走过去，当我们走到门前，只见到有一个身影正从我们教室里打算出来。“看，是连，他来我们教室干什么？”薰拽了拽我并朝前指了一下。</p><p>有点被打湿的我看到连之后感到愈发的寒冷，心想：“他来干什么啊！”</p><p>“钟同学，山本同学。你们？”连看到我们之后，一脸诧异，“你们是淋雨了吗？你们没事吧？”</p><p>接着连一个箭步闪现到一个课桌前，迅速地抄起了桌子上的毛巾，朝我们走了过来。</p><p>连把毛巾掸开，接着对折了一遍。然后一手抓住毛巾，打算朝着我的头发扑过来。</p><p>我下意识地躲闪了一下，“请不要这样，我自己来，把毛巾给我就好”。连微微笑了一下，放下举过我头顶的手，并把毛巾递到我的面前，“给~”</p><p>我迅速接过毛巾，又把毛巾摊开，熟练的将毛巾包住自己的头发，稍微用力搓了一下。</p><p>“好香”，应该是包住头发的一瞬间，挤压出了原本停驻在毛巾间的空气，顺带着毛巾散发出来的淡淡的清香。我一边一边搓着自己的头发，一边重新回溯毛巾是从哪张课桌拿过来的。</p><p>“给，你也要擦一下”，我把毛巾递给了薰。薰接过毛巾，照着我的动作又重复了一遍。</p><p>“谢谢你”，我低头向着连说道，同时心里又很担心他又要“故技重施”。</p><p>“你也太贴心了叭！”薰擦完头发之后，小心翼翼的把毛巾对折一遍，又对折一遍，变成一块小方块，想要还给连，“你怎么会想到给我们准备毛巾！”</p><p>“不客气。那个”连注视着我，仿佛又要说出那句。</p><p>“不，先别”我及时打断了连，“如果你还要说‘喜欢我’之类的话，不好意思，对不起”</p><p>“好吧，你还是拒绝我了吗？”连看着有点失望。</p><p>“我不能马上回答你，不好意思”我把整个身子扭向了一边，面对着白色墙壁。</p><p>“好吧，我先走了，你们要小心，不要感冒”，说完，连离开了教室。</p><p>薰把我转了过来，刚要开口，我打断了薰。</p><p>“我知道你又要说教我了，你这次想说什么？”我摆脱了薰的手掌，缓慢向我的座位走去。</p><p>“你真的……你真的”，薰顺势将手托住自己的脸颊，“我真的……我真的……”</p><p>“行了，我明白的”，当我走到我的座位旁，正要坐下时，看到课桌靠窗的一边，倚着一把雨伞。</p><p>“这是谁的雨伞？”我把伞拿了起来看了一眼，接着我突然灵光一闪，想到了毛巾，“毛巾呢？薰，毛巾在你那吗？”</p><p>薰把毛巾递了过来，“我是真的佛啦，铃兰，你是真 NB 啊，你真该死啊！”，薰好像有点要急哭了的样子，“你要是不稀罕舔狗，能不能让他舔舔我啊！”</p><p>“你在说什么啊！！！”我冲着薰喊了一声。没想到薰竟然突然对我是这个态度，我突然感到有一丝失望，顺手把毛巾抽回来。</p><p>“人家给你送毛巾，给你准备雨伞，你却这样对人家”，薰突然就哭了起来，“我真的……我看着好心痛，连真的好可怜……可怜的汤姆猫……”</p><h3 id="7">7</h3><p>“毛巾确实是从我桌子上拿的……”，我边回忆边念念有词，“伞和毛巾，到底是谁放在我桌子上的？”</p><p>此时教室里除了我们，没有其他人。教室也非常干净，黑板被擦得一点粉笔痕迹都没有，甚至还在反光，感觉能隐约看到我们的影子。窗户也紧闭着，只能透过窗户看到灰蒙蒙的天，以及雨水努力敲打玻璃发出清脆的声音。白色的窗帘也不会摆动，一切就像时间凝固了一般。</p><p>“还能有谁！当然是连拿过来的啊！你想一下刚刚除了我们俩，还有谁！”薰冲着我又嚷了一声，接着又软了下来，嘴里小声念叨着，“多好啊……多好啊！！！”</p><p>我起身走到薰的身边抱住了薰，试图让薰冷静下来，“好了，是我不好”。</p><p>“铃兰，你怎么能这样呢？”薰再一次责备我，用了跟早上一样的话语。但这次是抽泣的。</p><p>“我不想让他产生误会。”我小声的在薰耳边说，一边用手擦拭薰眼角上的泪痕。</p><p>“我不说了，我不说了，我什么都不想说了。”薰抬起头，用力吸了一下鼻子，“如果我是你的话，就好了。”</p><p>“我们先回家吧”，我拿着伞和毛巾。心想着，先把毛巾带回去洗干净，烘干。明天再连同雨伞一起带过来，看看是谁的吧。</p><p>于是，我手里拿着毛巾，然后挽着薰的手臂，另一只手拿着雨伞，带着她离开了教室。</p><p>我们走出了教学楼，来到了校门口。雨还是没有停，但是没有刚才那么大了。我打开了雨伞，为我们遮挡着雨水。薰紧紧地挽着我的手臂，靠在我的肩膀上。我能感觉到她的呼吸和体温，让我心里一阵暖意。</p><p>我们一起走出了校门，向东边走去。路上，我们没有说话，只是默默地感受着彼此的存在。我不知道她在想什么，也不知道自己在想什么。我只知道，这一刻，我很幸福。</p><p>看着走了三年的小路还是坑坑洼洼，路过的街道还是这么吵吵嚷嚷……</p><p>“还有两次”</p><p>“嗯？”薰贴着我，发出了娇贵的声音。</p><p>“我说，这条路，我们可能只会再多走两遍了。”我也靠着薰说道。</p><p>“嗯……”</p><p>我们就这样相互依着往前走，感觉走了没多久，眼帘里映入最熟悉的围墙，我到家了。</p><p>“你可以吗？薰？”我把手从薰的手臂间抽了出来，又很迅速地牵住了薰，“剩下的路，你可以自己走吗？”</p><p>“我可以的”薰伸手想接过雨伞，“你回家吧，我们明天见。”</p><p>我把伞转移给薰，自己跑回了家里。在家门口屋檐下转了个身，朝着薰挥了挥手。</p><p>“我回来了”，边脱鞋边跟家里打招呼，但好像家里也没有人。</p><p>我穿过了门厅，来到院子前。外面的风真的好大，门外的风铃草正在坚强地承受雨的洗礼，在努力的对着风向摆动自己，试图也想让自己平静下来。</p><p>雨敲打地面的声音，横风掠过的声音，以及顽强抵抗横风的风铃草，清脆的撞击声……各种声音在我的耳边，持续回响……</p><p>“风铃草，到底是什么意思？铃兰跟风铃草有没有关系？妈妈到底是想要让我知道什么？”我蹲了下来，抱住自己的腿，看着风铃草，陷入了沉思……</p><h3 id="8">8</h3><p>终于。</p><p>毕业典礼当天，还是到了。</p><p>还是像往常一样起了一个大早，像往常一样洗漱，像往常一样穿上自己的校服。</p><p>不过，这是最后一天穿校服了。</p><p>一切准备就绪，来到家门口。还是像往常一样在门口等着薰的出现。</p><p>阳光穿过薄薄的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。</p><p>等到薰走到身边，我马上挽住薰的手臂。今天不管怎样，我都想这样走去学校。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你今天，竟然扎在头发上了！”</p><p>“单马尾的你，好可爱啊！！”，薰一边走一边用脸蹭着我的肩膀。</p><p>我们还是这么互相依着，踏着路面被风雨打下来的樱花，继续往前走。</p><p>“真不敢相信，我们就要毕业了。”薰叹了口气，“我们可能就此分开了，你会不会想我呢？”</p><p>“当然会啊。”我紧紧地挽着薰的手臂，“你是我最好的朋友，我怎么会不想你呢？我们以后还可以保持联系啊，还可以见面啊，还可以一起玩啊。”</p><p>“是啊，是啊。”薰点点头，“我们一定要保持联系，一定要见面，一定要一起玩。我们永远都是最好的朋友。”</p><p>“对啊，对啊。”我附和着说，“我们永远都是最好的朋友。”</p><p>我们就这样走着走着，不知不觉到了校门口。今天的校门口格外热闹，很多同学都提前到了学校，有的拿着相机拍照留念，有的拿着卡片写下祝福语，有的拿着花束准备送给喜欢的人。</p><p>“毕业典礼马上就开始了，我们先去体育馆吧。”我拉着薰，穿过人群，朝着体育馆走去。</p><p>我们穿着校服，戴着毕业帽，坐在体育馆的座位上。台上是校长和老师们，他们正在发表着毕业致辞，祝贺我们的成绩，鼓励我们的未来。台下是我们的同学们，他们有的在认真地听着，有的在偷偷地聊着，有的在悄悄地哭着。我看了看身边的薰，她也看了看我。我们都没有说话，只是微微地笑了笑。我们的眼神里，有着无尽的情感。</p><p>毕业典礼结束了，我们拿到了毕业证书，和老师们握手道别。然后，我们走到了操场上，和同学们拍照留念。我们拍了班级合影，社团合影，好友合影。我们拥抱着彼此，说着感谢和祝福。我们流着眼泪，笑着说再见。</p><p>“铃酱，我不想离开校园！”薰眼巴巴的看着我，感觉又要哭出来了，“我真的好舍不得学校，舍不得这段时光，舍不得你……”</p><p>说实话，我也很留恋这三年时光，这里有我最美好的回忆，最珍贵的友情，最深刻的感情。我也不想离开这里，不想离开他们，不想离开他。</p><p>但是我不想继续再多待一秒，因为……</p><p>“薰，结束了，我们回去吧”，我看着薰，此刻的我不知为何能做到如此冷血，说出这番话。</p><p>“我不！我不要！”薰向后退了一步，用力的摇了摇头，“我真的好舍不得，我想去多拍一些照片，我想去我们第一次上课的地方，我想去音乐室，我想……”</p><p>“那我在校门口等你好吗？”我打断薰的话语，并看着薰，眼睛发出渴求的信号，心里一直想着，千万要接收到并能理解。</p><p>“好…好吧……”薰不舍地说道，“那你要等我噢！无论如何要等我噢！！！”，接着薰回头，一头扎进楼里。渐渐的，看不到人影。</p><p>我也回头，朝着校门口走去。“我就站在门口等着薰回来吧”，边走边这么想着。</p><p>当我走出大门，看到写着学校名字的铭牌前站着一个人。</p><p>“是悠太！他怎么站在这里！”我突然感觉自己的心率正在飞快上升，又快一点，再快一点……</p><p>悠太笔直地站在校门口，仿佛在等着谁。</p><p>“那是什么！”我看到了悠太，背在身后的手上，似乎拿着什么东西。</p><p>“风……风铃草！？”我突然感到一丝窒息感，“为什么？他在这里干什么？他在等他喜欢的人出现吗？”</p><p>悠太好像看到了我，笔直地朝我走了过来。</p><p>“怎么办怎么办怎么办怎么办怎么办怎么办怎么办”我不知道自己该干什么，但是他正在一步步逼近，我应该怎么办，我束手无策。</p><p>“钟铃兰……”，悠太开口了。</p><p>“啊，啊！”我抬头看了一眼悠太，“你也，你也太失礼了吧藤原同学！你怎么能直接叫人家的姓名！”</p><p>“对不起，你在等人？”</p><p>“嗯……我在等薰。”我说。</p><p>“薰？”他有些惊讶，“她还没走吗？”</p><p>“她还想去看看学校。”我说。</p><p>“哦，这样啊。”他说，“那你们……你们要一起回家吗？”</p><p>“是的。”我说，“我答应了薰，我们要一起走回家，最后一次。”</p><p>“你……”他欲言又止，似乎有什么话想要说，又不敢说出来。</p><p>“我什么？”我问。</p><p>“你……你喜欢我吗？”</p><p>他终于说出了那句话。</p><p>“我……我……”我感觉到我的脸正在变得越来越热，我不知道该怎么回答。我下意识地很想用手扇扇自己的脸散热，但我不敢。我的心里有千言万语，却说不出一个字。</p><p>“对不起，我向你道歉。是我冒犯了。”悠太低下头，扭捏了一下，“那个……嗯……”</p><p>悠太把双手从后面移向了前面，双手捧着一束花。是浅蓝色的……是风铃草。</p><p>“我猜你有所疑惑”，悠太解释道，“你想说，现在根本没有风铃草。是的，现在确实还不到风铃草的花期。”</p><p>我的大脑一片空白，我不知道他想干什么。</p><p>“其实我一直在偷偷喜欢着你，但是我又很害怕。我知道，我在别人眼里，是一个没有朋友的怪人，所以我怕。”悠太换了个姿势，继续说道。</p><p>“我一直想表达我的心意，但是如果被拒绝了，这些感情就会消失。就像风铃草一样，随风而逝……”</p><p>“可是，如果毕业了我都不能说出我想说的话，我可能会一直后悔下去，后悔一生……所以我给自己一个期限，也在逼迫自己，不管怎样，即使毕业了，我也要在毕业当天，说出我的想法。你真的很好……”</p><p>悠太突然牵扯住我的眼神，我好想躲开，但又忍不住建立起联系。</p><p>“你很温柔，你对其他同学非常好，你也总是先想着别人……你很勤奋，我经常看到你在那家面包店打工，你在前台对着客人的甜美的微笑，让我内心感到治愈……你很坚强，体育课的长跑项目，你不小心摔倒了，还坚持站起来，走着也要走完全程……”</p><p>“我真的，我只能默默为你做点事情，虽然你也许永远都不会知道，那些是我做的。”</p><p>“这么说！！！”我突然恍然大悟，眼睛里突然有些温热，“不会是！昨天毛巾和雨伞？！还有之前的那些—— 我以为——”</p><p>“其实还有一些，”悠太的突然脸也红了起来，“总之，当你需要的时候，我就会在。”</p><p>“好吧，就到这里吧。这个送给你”，悠太双手捧着风铃草，递到我的面前。</p><p>我接过了风铃草，刚想开口。</p><p>“以后我们应该还会再相见吧，如果可以的话。祝福你，祝你在大学生涯里继续追逐你的梦想。”，说完，悠太转过身，准备离开。</p><p>“藤……悠太！”我叫住了他。</p><p>悠太回头看了一眼，微微一笑，“还有什么事吗？”</p><p>“那个……”我犹豫了一下，不知道该怎么说，“对了，如果毛巾是你的……”</p><p>我赶紧放下包，找到那条白色的毛巾。它已经失去了原本的味道，现在跟我衣服的味道一模一样。</p><p>我拿着毛巾追了上去，递给悠太。“这是你的毛巾，我希望你能收下。”</p><p>悠太微微一笑，收下了毛巾，并礼貌性地点了下头，然后回头想继续走。</p><p>“还有！！”我再一次叫住了悠太。</p><p>“还有什么事吗？”</p><p>“还有……”我把花束换到了自己的左手，并举起了自己的右手，向前伸去，手背向上，手指尖向下压低了15度……</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>看了一个 b站 视频，一个知乎回答，还有一个不知道是什么打不开 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/AI/">AI</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/AI/">AI</category>
      
      <category domain="https://colmugx.github.io/blog/tags/ChatGPT/">ChatGPT</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>重新学习 JavaScript</title>
      <link>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</link>
      <guid>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</guid>
      <pubDate>Tue, 14 Feb 2023 12:13:14 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;孔子曾说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“温故而知新，可以为师矣”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Confucius 曾经也说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？&lt;/p&gt;
&lt;p&gt;想一想，从 16 年到现在一直用 &lt;code&gt;TypeScript&lt;/code&gt;，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且，孔子还说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知之者不如好之者，好之者不如乐之者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我决定邀请各位，请让你&lt;strong&gt;身边&lt;/strong&gt;的人一起学&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）</p></blockquote><p>孔子曾说：</p><blockquote><p>“温故而知新，可以为师矣”</p></blockquote><p>Confucius 曾经也说过：</p><blockquote><p>“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”</p></blockquote><p>意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？</p><p>想一想，从 16 年到现在一直用 <code>TypeScript</code>，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 <code>JavaScript</code></p><p>并且，孔子还说过：</p><blockquote><p>知之者不如好之者，好之者不如乐之者</p></blockquote><p>所以我决定邀请各位，请让你<strong>身边</strong>的人一起学</p><span id="more"></span><h2 id="环境">环境</h2><p>虽然直接使用浏览器方便一些，但我们现在应该本地都有一个 <code>node</code>，这可能对我们来说更为方便。顺便的可以温习一遍简单的 <code>File IO</code>，毕竟这是几乎所有语言入门都需要接触的部分</p><p>本文环境配置如下：</p><ul><li>OS：最新最时尚最卡的 MacOS Ventura</li><li>node: v16.13.2</li></ul><h2 id="基本类型">基本类型</h2><p><code>JavaScript</code> 是一款“函数式” <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 解释型脚本语言，所以这部分我们可以使用 Node REPL</p><p>打开终端，输入这个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node</code></pre><p>首先是基本类型：<code>JavaScript</code> 有<strong>三种</strong>基本类型：<code>string</code>, <code>number</code>, <code>boolean</code></p><p><code>string</code> 叫字符串，如果有其他编译型语言经验的话可能一时会觉得奇怪，但在 <code>JavaScript</code> 没那么讲究，字符串就是基础类型</p><p>字符串由一对引号包起来，也没那么多讲究 —— 单引号双引号都可以</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &#39;I love you&#39;&#39;I love you&#39;&gt; &quot;I love you, too&quot;&#39;I love you, too&#39;</code></pre><p>如果你的字符串出现了必要的单引号（例如 do not 的缩写），这时为了避免歧义，应该用一种引号（双引号）来作为语法识别，这样字符串内就可以使用另一对引号（单引号）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &quot;I don&#39;t hate you&quot;&quot;I don&#39;t hate you&quot;</code></pre><p><code>number</code> 叫 number，数字，同样也没那么多讲究 —— 不分 32 位 64 位，不分整浮点，甚至双精，甚至 <code>decimal</code></p><p>配合一些基本的操作符（operators），我们可以把 REPL 作为计算器使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 1+12&gt; 1*11</code></pre><p>计算机的世界，计算没有大括号（{}），没有中括号（[]），只用小括号表示优先级，嵌套越深则越优先。举个例子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 4 * (40 - (2 - 12) + 40 * 2)520</code></pre><p>这个时候你再试试除以 0。不过我们小学都学过，除法里是不能除以 0 的。但是学编程，就是要敢猜敢试。放心，不会起火</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 520 &#x2F; 0Infinity</code></pre><p>看，尝试得到了新的理解。这个式子也许对你还有另一种含义：<strong>爱与无限之间，只有一个「无条件」</strong></p><p><code>boolean</code> 指布尔值，指一对真实反义词，例如对和错，真和假，0和1。通常用在逻辑分支</p><p>计算机是严格的，对就是对的，错就是错的。<strong>但你们之间，没有绝对对错</strong></p><p>懂行的人别急，确实还有两种：<code>undefined</code> 和 <code>null</code>，它们一般情况下指「没有」，但他们严格来说不是一个意思：<code>null</code> 指这个值是空的，但本身也是一个值；<code>undefined</code> 是真的没有，且未知</p><p>就像你现在问你身旁的人问你今天有没有想TA，你回答 “没有”。虽说可能真的没想你，但其实心里还有你</p><p><strong>而有些人想都没得想！</strong></p><h2 id="函数">函数</h2><p>在复习函数之前先随便复习一下定义变量</p><p>严格 ES6 之前我们只会用 <code>var</code>，但如今我们都默认有两种定义方式：<code>var</code>, <code>let</code>，还有一种定量定义方式：<code>const</code></p><p>变量指定义之后，值还能改；定量指定义之后，值无法修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var lovedGame &#x3D; &#39;League of Legends&#39;lovedGame &#x3D; &#39;JX Online 3&#39; &#x2F;&#x2F; 世界上最好的 MMORPLGconst lovedOne &#x3D; &#39;You&#39;lovedOne &#x3D; &#39;Her&#39;&#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</code></pre><p>严格讲，<code>var</code> 和 <code>let</code> 有一点区别，<code>let</code> 有声明使用顺序（死区）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和作用域限制，换句话说更“安全”，所以现在对于新手来说，无论如何优先使用 <code>let</code></p><p>接下来到函数，一般声明一个函数会有两种方式，一种是正常的函数声明，一种是基于语言特性的声明</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1.function fn() &#123;&#125;&#x2F;&#x2F; 2.const fn &#x3D; () &#x3D;&gt; &#123;&#125;</code></pre><p>第二种其实就是一种「把函数也当做一个变量/定量」的思路，具体区别不展开<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>调用一个函数很简单</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn() &#x2F;&#x2F; 函数有参数就照着传</code></pre><p>Ok，小节实践，尝试以下函数并调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function calc(n) &#123;  return ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n&#125;&#x2F;&#x2F; 也可以这么写，是不是更帅了const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n</code></pre><p>（可以在 REPL 运行）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * nundefined</code></pre><p>REPL 是这样的，输入的下一行永远是返回值。接下来输入调用看看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; calc(1)520.1314&gt; calc(51)520.1314&gt; calc(564)520.1314</code></pre><p>你们也是这么简单纯粹吧 —— <strong>不要总问是不是变丑了，不管你变成怎样，都会一直爱你</strong></p><h2 id="实践">实践</h2><p>接下来就不用 REPL 了，因为接下来想整 <code>Network</code> 和 <code>File IO</code>。纯 <code>JavaScript</code> 这个语言是不带 IO 实现的</p><p>这一次就随便练一下写文件好了，我们的目的是：获取一个网络上的资源，并写下来</p><p>首先创建一个文件，就叫 <code>love.js</code>，随便放在你能找到的地方</p><p>先定义一些变量，照着复制就完事了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fileName &#x3D; &#39;love.txt&#39;</code></pre><p>接下来是引入一个<code>fs</code>包</p><p>由于现在已经是 <code>import/export</code> stable 的时代，所以包引用哪种都可以</p><p>但如果使用 <code>module</code> 模式的话需要将 <code>package.json</code> 的类型更改为 <code>module</code></p><p>我们直接执行，也不引入 npm 概念，所以我们这里用 <code>CommonJS</code></p><p>在最顶上（<code>fileName</code> 的上方）写入</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 文件系统const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 路径模块（用于系统各种跟路径相关的工具）const path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 网络const http &#x3D; require(&#39;https&#39;)</code></pre><p>接着我们在最开始写的变量（<code>fileName</code>）下面新增一行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 将要保存文件的路径（自动拼接绝对路径）const currentDir &#x3D; path.resolve(__dirname, fileName)</code></pre><p>然后是网络请求，我们一般都会封装成一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  http.get(    &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,    res &#x3D;&gt; &#123;      let data &#x3D; [];      res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;        data.push(chunk);      &#125;);      res.on(&#39;end&#39;, () &#x3D;&gt; &#123;        return data.toString()      &#125;);    &#125;)&#125;</code></pre><p>最后一行写上文件写入就行啦（注：这个示例跳过错误边界）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request())</code></pre><p>接下来在终端运行它吧！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node .&#x2F;love.js</code></pre><p>然后报错了！</p><p>这个时候我们应该学会看错误，这也是编程的基础。<strong>有错就说明清楚，然后调整，这样才能和谐相处</strong></p><blockquote><p>The “data” argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined</p></blockquote><p>这里说的是获取到一个 <code>undefined</code>，这个是不支持写入的</p><p>Actually，我们会给一个未知变量做边界控制，这里简单的直接短路吧<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request() || &#39;&#39;)</code></pre><p>这个时候不报错了，我们去看一下这个目录下生成的 <code>love.txt</code> 文件吧！</p><p>当我们兴奋地打开之后发现，<strong>这是一个空文件</strong></p><p>千万不要想着「我的努力我的付出，得不到回应」</p><p>不要灰心，学习编程的过程就是不断发现问题，不断解决问题。<strong>感情也是如此</strong></p><p>但我们要的不是对「你错在哪儿了？」进行一个精准的回答，而是 <strong>code review</strong></p><p>通过 review 我们会发现，<code>request</code> 写错了 —— 异步函数在这里不能直接获取返回值</p><blockquote><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p></blockquote><p>而网络对于一个 node 程序来说，就是一个异步工作</p><p>发现问题，开始解决问题</p><p>对于异步工作，我们总会很习惯的使用 <code>Promise</code> 来解决「回调嵌套」问题，使得代码看起来「同步」，而且可以非常直觉的处理「返回值」。换句话说，就是把整个函数的调用都放进了异步队列</p><blockquote><p>Promise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象</p></blockquote><p>所以，对 request 进行修改吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  return new Promise(resolve &#x3D;&gt; &#123;     http.get(      &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,      res &#x3D;&gt; &#123;        let data &#x3D; [];        res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;          data.push(chunk.toString())        &#125;);        res.on(&#39;end&#39;, () &#x3D;&gt; &#123;          &#x2F;&#x2F; 文件里有被转义的换行符，这里转回来          resolve(data.toString().replace(&#x2F;\\n&#x2F;g, &#39;\n&#39;))        &#125;);      &#125;)  &#125;)&#125;</code></pre><p>同时，「文件写入」语句也要做相应的修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, await request() || &#39;&#39;)</code></pre><p>这个时候再执行一遍！同样没有报错</p><p>但这一次不同了，当我们再一次打开 <code>love.txt</code> 文件时，我们会看到</p><p><img src="/blog/Image/heart.webp" alt="heart"></p><p>所以说，爱有时候也应该像这样：<strong>长久的爱与互相理解，建立在承诺(promise)和等待(await)</strong></p><p>我们已经约好了一直走下去的呀，等一会又怎样嘛</p><p>END -</p><p>（其实如果你有留意到这篇文章分类是在「动物园」下，或许早就知道了）</p><h2 id="Links-2">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266495749/answer/309719982">如何用数学的方法表白? - 知乎</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">异步 JavaScript 简介</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises">如何使用 Promise</a></li><li>本博客</li></ul><p>真是温故知新啊，看看这个引用区 ↓</p><p>全都是年轻不懂事的自己，瞎几把写</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>JavaScript 可以是函数式语言，但是极端还是存在争议，这里过分严谨一些 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我今天给 let 安排了 · Colmugx 's Blog</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我就写个方法，这么麻烦？ · Colmugx 's Blog</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>剧本味也太重了草，事已至此只能做一个违背祖宗的决定了 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9D%82%E8%80%8D/">杂耍</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>田旗插在苹果上但没插好 —— MAUI + MusicKit</title>
      <link>https://colmugx.github.io/blog/2023/02/07/maui-musickit/</link>
      <guid>https://colmugx.github.io/blog/2023/02/07/maui-musickit/</guid>
      <pubDate>Tue, 07 Feb 2023 15:14:05 GMT</pubDate>
      
      <description>&lt;p&gt;众所不周知，在大概 3 4 年前曾经有这么一个项目叫 &lt;code&gt;sona&lt;/code&gt;，这是一个音乐播放器，&lt;code&gt;react native&lt;/code&gt;，连着网抑云。大概长这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/sona-v1.png&quot; alt=&quot;sona&quot;&gt;&lt;/p&gt;
&lt;p&gt;过了这么久，我早就不网抑云，也以现在的眼光再看这个 UI 未免有些稚气，还有点费电资源 —— 整的什么垃圾&lt;/p&gt;
&lt;p&gt;正好，关注了一年多的 &lt;code&gt;MAUI&lt;/code&gt;，纯纯在 Build 看着宣布，然后 GitHub 开库，进 preview，到现在 stable。.NET 都从 6 preview 一直到 7…&lt;/p&gt;
&lt;p&gt;所以先来搂一眼，正好也想复活这个产品，并且不优先解决网抑云，而是解决 Apple Music 和 Spotify，还有 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://Last.fm&quot;&gt;Last.fm&lt;/a&gt;。再决定是改用 maui 重构还是继续用 RN&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-8&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C# 很香，但遗传了 Xamarin 的臭&lt;/li&gt;
&lt;li&gt;安卓 SDK 两个包，噶了一个&lt;/li&gt;
&lt;li&gt;平台能力最好还是用平台原生语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目前的 MAUI，狗都不用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>众所不周知，在大概 3 4 年前曾经有这么一个项目叫 <code>sona</code>，这是一个音乐播放器，<code>react native</code>，连着网抑云。大概长这样</p><p><img src="/blog/Image/sona-v1.png" alt="sona"></p><p>过了这么久，我早就不网抑云，也以现在的眼光再看这个 UI 未免有些稚气，还有点费电资源 —— 整的什么垃圾</p><p>正好，关注了一年多的 <code>MAUI</code>，纯纯在 Build 看着宣布，然后 GitHub 开库，进 preview，到现在 stable。.NET 都从 6 preview 一直到 7…</p><p>所以先来搂一眼，正好也想复活这个产品，并且不优先解决网抑云，而是解决 Apple Music 和 Spotify，还有 <a target="_blank" rel="noopener" href="http://Last.fm">Last.fm</a>。再决定是改用 maui 重构还是继续用 RN</p><h2 id="TL-DR-8">TL;DR</h2><ul><li>C# 很香，但遗传了 Xamarin 的臭</li><li>安卓 SDK 两个包，噶了一个</li><li>平台能力最好还是用平台原生语言</li><li><strong>目前的 MAUI，狗都不用</strong></li></ul><span id="more"></span><h2 id="MAUI">MAUI</h2><p>一句话：MAUI 是另一个 React Native 但 C#，<strong>不是 Flutter</strong></p><p>MAUI 前面有 <code>Xamarin</code>（分平台的不是 <code>Xamarin.Forms</code>），服就服在<strong>微软能把各个平台的 API 都转一份</strong>，这样所有代码都使用 C# 编写，以便享受这个极其变态的编译器。当你创建一个 mac 的 Xamarin 应用，你会发现除了语法是 C#，无论结构还是文件组织都与直接用 XCode 创建出来的项目不能说有点相似，只能说完全一致</p><p>高情商：令人钦佩的软件工程能力；低情商：吃饱了撑着</p><p>所以作为后继者，MAUI 在平台调用依然会是全 C#，不像 flutter 或者 RN 在分别平台使用 swift/kotlin。这样有好坏</p><p>好是因为全 C#，在编写平台逻辑时可以直接使用通用的 <code>interface</code>，或者是 common 写一个 <code>partial</code>，再分平台补充实现。即使在通用代码也可以用 macro 来区分平台生成代码，毕竟不用担心，编译会根据编译目标选择源代码</p><p>坏那也坏，RN 和 flutter 的方式是让平台代码完全使用平台程序，相当于写了一个原生程序，通过桥通信交换信息，这样可以保证平台逻辑是绝对的平台逻辑，《非常原生》。而反过来就是 MAUI 的缺点，谁也不知道到底这个翻译官水平如何</p><h2 id="MusicKit">MusicKit</h2><p>WWDC21 宣布了 <code>MusicKit</code>，WWDC22 宣布了<strong>其他平台</strong>的 MusicKit SDK 和 Apple Music API，至此 Apple Music 可以在其他平台集成，包括 Web</p><p>只不过，据我所知，Apple Music API 和 MusicKit Web 只有很普通的音质，没有 ALAC，没有 Dolby Atmos，其实后者没有应该不奇怪</p><h2 id="Combine">Combine</h2><p>按照平台分，方案如下：</p><ul><li>iOS/iPadOS：系统带着了，直接写，可以参考 <a target="_blank" rel="noopener" href="https://github.com/xamarin/ios-samples/tree/main/ios11/MusicKitSample">Xamarin.iOS 的示例</a></li><li>Android: 使用官方 SDK，一共两个 aar</li><li>其他：只能封装 Apple Music API</li></ul><p>这个项目在 RN 的时候也仅考虑 iOS 和 Android。这次会考虑新增 iPad 和桌面端，但无所谓</p><h3 id="Create-Library-s">Create Library(s)</h3><p>如果按照 React Native 的习惯，可能会创建一个插件项目，接着分别在对应位置做平台实现。但，<code>Xamarin</code> 似乎不是这么做的</p><p>首先需要创建两个 Binding 项目：<code>Android Bindings Library</code> 和 <code>iOS Bindings Library</code></p><p>毕竟只是概念验证，所以这次不实现 iOS，先试试 <code>aar</code> 绑定。这里可以参考微软文档 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></p><p>在安卓，Apple Music 提供了两个 <code>arr</code>：</p><ul><li>mediaplayback：Apple Music 部分，用于获取专辑，音乐信息等</li><li>musickitauth: MusicKit 的验证部分（例如直接使用本地的 Apple Music 进行授权，类似通过 QQ 登录）</li></ul><p>一个一个来</p><h3 id="Droid-MusicKit-mediaplayback">Droid.MusicKit - mediaplayback</h3><p>（似乎 Xamarin 的插件大火都是这么命名的）</p><p>先处理 mediaplayback，按照文档，创建项目之后，把 <code>aar</code> 直接拖进项目，并设置「生成操作设置」</p><blockquote><ol start="5"><li>将 textanalyzer.aar 的生成操作设置为 LibraryProjectZip</li></ol></blockquote><p>Xamarin 虽然是这么设置的，但是在 Visual Studio 2022 <strong>已经没有这个选项了</strong>，取而代之的是 <code>AndroidLibrary</code></p><p>然后就可以开始生成了，<strong>要不怎么说微软 nb 呢</strong> —— .NET 会解析 <code>arr</code> 或者 <code>jar</code> ，将所有签名或者代码结构生成出来，并以类为单位生成一个个 C# 文件，作为 header file 使用</p><p>但，刚说什么来着？</p><blockquote><p>谁也不知道到底这个翻译官水平如何</p></blockquote><p>不出意外的话<strong>马上又要出意外了</strong></p><h3 id="寄！">寄！</h3><p><img src="/blog/Image/maui-musickit-error.png" alt="error"></p><p>mediaplayback 关于音乐部分是原生库（.so），应该是 JNI 部分依赖了 <code>javacpp</code>，而 <code>javacpp</code> 在翻译成 C# 的时候出问题了。尝试解决一下但无法解决，想抄作业全网搜索没有一个相似案例可以抄作业。如果直接用 kotlin 我会受这苦？</p><p>没办法只能退而求其次 —— 本地授权完获取 token 之后，剩下的走 Apple Music API。但即使可以的话，音质可能是收音机水平</p><h3 id="Droid-MusicKit-musickitauth">Droid.MusicKit - musickitauth</h3><p>跟 mediaplayback 一样，把 arr 拖进来，改成 <code>AndroidLibrary</code> 之后编译，很意外的非常顺利，只有几百个警告。<s>在老程序员的眼里，1000 个警告都是无异常</s></p><p>接着，在 MAUI 的项目中打开「引用」目录，右键这个目录添加引用，把 <code>Droid.MusicKit</code> 添加进来，再编译一遍。没有报错的话就是没有报错</p><p><strong>要不怎么说微软 nb 呢x2</strong>，在使用时，可以直接 using 包名</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">using Com.Apple.Android.Sdk.Authentication;</code></pre><p>这里采用的方式是：先在公用逻辑写一半类，接着在对应的平台实现里完成各个平台调用</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth();    &#125;&#125;</code></pre><p>接着到 android 目录，创建一个 <code>MusicKitService.cs</code></p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth()        &#123;            &#x2F;&#x2F; 当前 activity（如果有更好的方式的话欢迎告诉我）            var activity &#x3D; Microsoft.Maui.ApplicationModel.Platform.CurrentActivity;            &#x2F;&#x2F; 应用上下文（React Native 直接在 props 进来的那个）            var context &#x3D; Android.App.Application.Context;            var authenticationManager &#x3D; AuthenticationFactory.CreateAuthenticationManager(context);            var developerToken &#x3D; &quot;&quot;;            var intent &#x3D; authenticationManager                .CreateIntentBuilder(developerToken)                .SetHideStartScreen(false)                &#x2F;&#x2F; 授权页面显示的告示信息                .SetStartScreenMessage(&quot;要想听歌就赶紧授权！&quot;)                .Build();            &#x2F;&#x2F; 跳转 activity（android 原生应该很熟悉）            activity.StartActivityForResult(intent, 100);        &#125;    &#125;&#125;</code></pre><p>最后随便绑定到项目创建时的 Demo 的按钮上，不出意外的话点击按钮就能显示 Apple Music 的授权页面（跳转到 Apple Music 或者让你安装一个）</p><h2 id="总结-4">总结</h2><p>零零散散写了很久，文章周期很长。可能有上文不接下气的感觉</p><p>本来对 MAUI 寄予厚望，现在理性考虑还是不会使用</p><p>一方面是需要踩坑的地方目测得到的就有点多（如果之前没踩过 Xamarin 的话还得算上）；一方面目前社区不活跃，有点冷门的实现自己搞不定</p><p>体感上会比印象中的 React Native 好很多（新解释器和 Hermes 还没用过），但开发成本和理解成本不在一个层面</p><p>总之，看还是会看，暗中观察。用的话现在不会用（但是体感上 Xamarin 真的要比 React Native 好，很纠结…</p><h2 id="Link-2">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/samples/xamarin/ios-samples/ios11-musickitsample/">Xamarin.iOS - MusicKitSample</a></li><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></li><li><a target="_blank" rel="noopener" href="https://github.com/dotnet/maui/discussions/1340">MAUI Binding .aar library</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9D%82%E8%80%8D/">杂耍</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/C/">C#</category>
      
      <category domain="https://colmugx.github.io/blog/tags/MAUI/">MAUI</category>
      
      <category domain="https://colmugx.github.io/blog/tags/MusicKit/">MusicKit</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/02/07/maui-musickit/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>成为玩家 2022</title>
      <link>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</link>
      <guid>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</guid>
      <pubDate>Sat, 31 Dec 2022 08:51:19 GMT</pubDate>
      
      <description>&lt;p&gt;本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了&lt;/p&gt;
&lt;p&gt;边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了</p><p>边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x</p><span id="more"></span><h2 id="我想做的就是-JRPG">我想做的就是 JRPG</h2><p>今年有更多的时间花在系统学习音乐上，为什么</p><p>首先，JRPG 更强调剧情的推进，且有更强烈的 role play（相对于欧美RPG来说，代入日式RPG更需要想象），所以相对来说，JRPG 有一个更抽象的世界观。怎么交代清楚「现在身处一个怎样的环境」，<strong>除了文案旁敲侧击暗示之外，配乐起到非常关键的作用</strong></p><p>自从去年聊完《原神》之后，我发现越来越多的新游戏（所谓的二次元游戏）都开始强调配乐（这个时候我真想吐槽某个游戏吃老本的功力是真的得天独厚）。但毕竟不是谁家都是 HoYoVerse，从一开始就深入跟策划文案磨世界观，和游戏基本到开发末期再“配乐”，本质上还是有所区别</p><p>所以在游戏，音乐有一个更新的称呼：互动音乐（设计），且这是我们能叫出名的国外游戏公司的标配（比如真有你的 SE）</p><p>举个例子，最近的《宝可梦朱/紫》，四个地区分别有自己一个 theme，但每一个 theme 在步行、骑行、水边、特殊场景、战斗所使用的配器均不同，且使用的配器更适合当时的环境 —— 步行更多是一个比较纯净的钢琴，一旦上了摩托就会变成一个带 epic 的管弦，<strong>并且他们无缝衔接</strong>。这让探索旅途中，既体现了地区风格，又带给游玩者一个“更真实”的情绪</p><p>再加个例子，《八方旅人》和《异度之刃3》有一个差不多的设计</p><p>介绍下背景，《八方旅人》讲的是八个不同的角色为了实现各自不同的目标在同一片大陆展开冒险的游戏。在他们分别进 boss 战之前都有一段嘴炮用于剧情铺垫，此时配乐开始使用对应角色一个可以循环的短音乐，进战斗之后开始切为一个从这个短音乐的音阶和节奏型转换为战斗配乐的音阶和节奏型（大多是升音阶，学者中间段先接上前面的 3/4 转 6/8 一路卡到 4/4 进战斗）</p><p>也就是每个角色 boss 战之前配乐是这样的：循环段 -&gt; 过渡 -&gt; 战斗</p><p>这么做的好处同样很清晰：<strong>当你沉浸在故事时，不会因为配乐切换而打断情绪</strong>。同时游戏大多时候在嘴炮期就已经让你感觉到气愤/可怜，而在过渡段自然地滑进 battle theme 之后，玩家的情绪也已经非常自然地提到了激情的状态，巴不得直接就扬了面前这个B</p><p>而《异度之刃3》要提的是冠名怪（You Will Know Our Names-Finale-，这首也是系列第一首使用了完整的互动音乐设计的音乐</p><p>冠名怪的配乐被分成了四段：进去一段，怪进狂暴期一段（血条在火焰之后），濒死一段，<strong>收势两段</strong>。是的，收势分为以 Chain Attack 结束和普通结束。</p><p>上面描写了很多信息，那跟我有锤子关系？巧了，我想做的就是 JRPG。<strong>如果制作人都不知道自己的游戏将会是什么样，那又有谁会知道呢</strong></p><p>所以日后只要写关于游戏简评的文章，都会加上一个新章节：配乐分享</p><p>虽然但是，今年的钢琴没有任何进步。明年除了乐理要继续安排时间学习，要开始翻《配器法》</p><h2 id="好故事还要讲得好">好故事还要讲得好</h2><p>故事对于 RPG 来说非常重要，无论是美式 RPG 还是日式 RPG。关于日式和美式对于故事的区别我跟一些业内人员（世界观设计，文案）算是有过沉重的讨论，这里不谈，可以以后单独写一篇我的观点</p><p>翻看我的微信读书，发现《故事》读了 8 个月，我记得很清楚，其中第五章第六章花费了绝大多数时间。如何「科学」的写出一部能让众人娓娓而谈的小说是一件非常难做到的事情</p><p>这是写故事，好故事所需要的前置条件。再是讲故事，因为不管多好的故事，它终究暂时是在纸上。读小说吸引人的其中一点也在于画面与描写都在每个人的大脑中，每个人都有每个人想要的画面和理解，一千个读者眼中就会有一千个哈姆雷特</p><p>《故事》列举了非常多的影视作品片段作为案例用于解释故事点，实际上对于现代游戏来说…也没问题。现在能端上台面的 RPG 游戏，要求可越来越高了。除了需要成熟或独特的游戏玩法，镜头语言、场面调度等等影视手段也在不断地搬到游戏作品中去，加上这个时代出现了「虚幻5」这样的游戏引擎，越来越多不可能逐渐变成可能</p><h2 id="游戏首先要好玩">游戏首先要好玩</h2><p>今年刚好内部有一个 gamejam，抱着试一试的心态参加了。拿到主题之后，我们首先有一个世界观想法，然后开始写 GDD，开始决定类型、特点、关卡设计、<strong>音乐设计</strong>…</p><p>虽然我们最后因为其他原因没有参赛（报名了但没参赛），但在路演期间，在去试玩其他组的游戏，特别是一个后来成为冠军的游戏时，我突然悟了一个道理</p><blockquote><p>游戏首先要好玩 —— 魏皮特</p></blockquote><p>任天堂也是这样的主张，游戏设计再好，它不好玩就不是好游戏。所以<strong>从最开始我们的路线就是错的</strong> —— 浪费时间在决定是 2D 是 3D，是像素还是写实，<strong>甚至是 gamejam 没有时间考虑的音乐设计</strong>，都是无用功</p><p>也许这是 JRPG 的路线，但对于 gamejam 来说就是不适合，因为流程太长，无法在玩法上一击命中，那么短的试玩时间根本无法给试玩者留下任何印象，他们都是没有耐心的。在开发时也无故增加了许多工作量</p><p>并且我们在常规关卡设计中预计使用「华容道」，这其实已经被证明过多次这是个“偷懒”的游戏设计，如果关卡设计太难，这又会失去更多一部分玩家</p><p>总而言之，从此刻开始悟道什么是纯粹的快乐。明年再来</p><h2 id="减少后悔">减少后悔</h2><p>在复盘整年时，我发现上一节提到了 gamejam，实际上我本就有一个符合主题的游戏 —— 去年学习游戏开发时的原型《Pong Evolution》，真的本质上就完全符合主题</p><p>但为什么会想不起来？<strong>能力不够</strong>。能让我发现这个问题的依然是那个比赛的第一名，让我得到「原来主题还可以这样理解」的启发</p><p>这让我又有一个新的想法：如果我就以一个游戏原型，不断地去参加内部的比赛，每次都为了贴合主题添加新的元素，积累下来会不会非常有意思？</p><p>多做减少后悔，现在我是这样想的</p><h2 id="你做的前十个游戏都是垃圾">你做的前十个游戏都是垃圾</h2><blockquote><p>你做的前十个游戏都是垃圾，所以赶紧做掉吧 —— Jesse Schell</p></blockquote><p>上面提到的 JRPG 确实是我目前在游戏工作中最大的梦想，但我不可能一直吊死在一个项目上，停留在「完美的设计」上，即使这是我最想做好的游戏</p><p>我能理解标题的含义，初出茅庐就做出完成度非常高的作品几乎不可能。与其纸上谈兵不如先做起来。十个必然是一个虚数，其含义是不断地做，坚持做，越做越多，越来越多的错误，越来越多的总结…</p><p>作为程序员应该更能理解。刚开始写一个应用程序的时候，我肯定大多数人都还无法理解设计模式的重要性（说不定现在大多数前端也不理解，所以我还是不认为这些前端是程序员（x</p><p>Wwise 是一个商业软件，自然它也官方适配同样是商业引擎的 Unity 和 Unreal，而对于目前作为我学习伴侣的 godot 就没有这种完美适配。所以在我开始学习「交互音乐设计」同时也在思考「如何设计一个在 godot 比较方便我自己使用的声音管理类？」、「autoload 是否就可以做到？」</p><p>这大概就是「垃圾」的意义</p><p>这个游戏我至今都一直在修改和补充 GDD，但确实不会贸然开始设计程序，因为我的垃圾还没写完（x</p><h2 id="是该有所不一样了">是该有所不一样了</h2><p>去年的这个时候还在抑郁的期间，总结非常的 down</p><p>今年更多被一个压力更大的工作看上了，几乎一整年都在围绕这个工作</p><p>公司给机会了所以尝试开发一个框架。在最开始设计的时候并没有把它当框架设计，今年开始发现业务复杂度越来越「奇妙」之后，决定给它加个核心转成框架，以后讲</p><p>加上在公司活整得很散，所以今年感觉比较疲，几乎所有开坑的产品都是 idle</p><ul><li>kazusa - 游戏剧本编辑器</li><li>setsuna - 个人事项管理</li><li>ayaka - 文档生成器（CSR, SSG）</li><li>hikari - 图片预览器</li></ul><p>是该有所不一样了，原本给自己设计的知识管理工具后面推翻改成游戏剧本/文案编辑器，应该以后更多都会根据自己的需求开发工具</p><p>有太多想做的事情，甚至当前很想去开发《无限暖暖》…</p><p>就这样，今年没有那么多抱怨和抱负，大概是因为正在生病</p>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>web 「性能优化」</title>
      <link>https://colmugx.github.io/blog/2022/12/15/web-optimization/</link>
      <guid>https://colmugx.github.io/blog/2022/12/15/web-optimization/</guid>
      <pubDate>Thu, 15 Dec 2022 14:23:45 GMT</pubDate>
      
      <description>&lt;p&gt;如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢&lt;/p&gt;
&lt;p&gt;而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-13&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少加载体积&lt;/li&gt;
&lt;li&gt;懒加载/延迟加载：利用 import/export 做代码分段&lt;/li&gt;
&lt;li&gt;充分利用 http2 和 vite（开箱即用版 rollup ）&lt;/li&gt;
&lt;li&gt;非常巧合的做法，指跟 React Beta 版文档异曲同工&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢</p><p>而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方</p><h2 id="TL-DR-13">TL;DR</h2><p>总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间</p><ul><li>减少加载体积</li><li>懒加载/延迟加载：利用 import/export 做代码分段</li><li>充分利用 http2 和 vite（开箱即用版 rollup ）</li><li>非常巧合的做法，指跟 React Beta 版文档异曲同工</li></ul><span id="more"></span><h2 id="减少加载体积">减少加载体积</h2><p>前端的静态资源都在依赖网络传输，所以在第一屏尽量加载最小的资源。</p><h3 id="使用-preact">使用 preact</h3><p>这个应用在建立的时候 react 版本是 17，虽然已经有 react 18 但还不 stable。考虑一番之后觉得没有并发和批处理的 react 不够有吸引力。与此同时，preact 10 有：</p><ul><li>更小的体积，即使带着 <code>compact</code> 最后也就不到 10k，保守预估</li><li>更快的运行</li><li>react 16 兼容，沉淀组件直接用不用考虑需不需要升级或适配</li><li><code>&lt;Suspense&gt;</code> 在当时已经稳定</li></ul><p>当时的考虑是：现在用 preact 以后迁移回 react 18 问题也不是很大，所以在 react 18 没有稳定之前都可以用 preact。只不过在 <code>TypeScript</code> 环境下，写类型稍微痛苦了一些 —— 毕竟只有 <code>api</code> 是兼容的，类型可不兼容</p><h3 id="JS-加载">JS 加载</h3><p>首先是编译期处理，举个例子</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; use-noop.tsexport function useNoop() &#123;  return () &#x3D;&gt; &#123;&#125;&#125;&#x2F;&#x2F; page.tsimport &#123; useNoop &#125; from &#39;.&#x2F;use-noop&#39;</code></pre><p>首先我们的规范决定了：工具放在 <code>utils</code> 目录中且<strong>一个文件仅有一个函数，并通过 <code>export</code> 导出</strong></p><p>所以我们在最开始就解决了一个问题：尽可能拆掉首包体积，或是能自然的利用 ES Module Tree Shaking (Rollup)</p><p>接着，由于我们的目标是Chromium(cef) 76 往上，那么<strong>可以直接使用 module 的形式加载</strong>且不需要 <code>polyfill</code></p><h2 id="懒加载">懒加载</h2><p>懒加载内容分两个：</p><ul><li>原本一起打包但已经 split 的 JS 文件</li><li>从网络上加载的媒体资源（图片，视频）</li></ul><h3 id="媒体资源懒加载">媒体资源懒加载</h3><p>这里主要是图片，虽然 Chrome 已经有浏览器级别的懒加载（loading=“lazy”）</p><p>Chrome 会根据当前网络环境决定要加载多远的图片，不过 Chrome 的阈值有点捉摸不透。最后还是决定使用 <code>lazysizes</code>，并且自己控制加载距离 —— 大概就在屏幕外面多一点点</p><p>于是「不必要」的网络请求又节省下来一点</p><h3 id="JS-懒加载">JS 懒加载</h3><p>可以懒加载的 JS 不少，对于我们来说大概有几种：</p><ul><li>首屏用不到的模块，懒加载</li><li>路由，组件懒加载</li></ul><p>首屏用不到的，或者在生产中用不到的模组例如 <code>vconsole</code>、<code>hls.js</code>，在第一次不参与加载</p><p>其次，我们在架构组织上采用分层组织，即页面组件(pages)作为消费层，业务代码根据需求和 <code>feature</code> 一一关联</p><p>我愿称之为渐进式 DDD，因为就是从 DDD 的思想不断简化，再通过磨合时间和程度逐步加上去，最后都习惯并理解「为什么持续维护项目型需要 DDD」</p><p>有机会的话下一篇分享 DDD 在我们实际场景中的运用。这里推荐一个项目叫 <a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh</a>，比较可惜的是这个框架诞生于我们的决定之后</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 这里隐藏掉了部分细节- common  - component  - model  - repository  - service- [feature]  - component  - model  - repository  - service...- pages  - [page]</code></pre><p>这样，<code>page</code> 对于我们来说只是一个组合功能的载体，从而又带来一个好处：<strong>一个页面可以决定哪部分直接添加，哪部分进 lazyload</strong>。加上 <code>preact</code> 已经稳定的<code>&lt;Suspense&gt;</code>，就可以实现不那么生硬的体验效果</p><p>并且所有的 <code>page</code> 都是通过路由 lazyload 的，也就是第一次加载不会加载到别的页面的 JS（这好像已经变成了基操）</p><p>到这其实有个问题：以上关于一个页面拆分懒加载，但它们始终都要在第一屏加载，下载量可是不变的</p><p>所以还有下一步操作，大小尽量砍了，该想怎么弄快了</p><h2 id="利用-http2">利用 http2</h2><p>http2 没有改动 http 的语义，但改动了头部压缩，新增优先级排序和多路复用</p><p>在 http1.1，由于每个请求都会开一个连接，所以早期前端优化有这么一手：把静态资源分布在不同域名下，例如 <a target="_blank" rel="noopener" href="http://img1.example.com">img1.example.com</a>，<a target="_blank" rel="noopener" href="http://img2.example.com">img2.example.com</a>。其实现在观察 github 也能看到类似的做法</p><p>但因为 http2 有了二进制分帧，所以基于此实现了共享TCP，到位了再根据标记和头部重新组装报文。在这之前 http1.1 是一整块纯文本，分区用的换行符（指头部和身体）</p><p>其实以上都「不重要」，只需要知道现在同一CDN下载不阻塞了。所以在 h2 之下，<strong>静态资源可以同时加载</strong>。这就解答了上面关于页面拆分的问题</p><h2 id="异曲同工？">异曲同工？</h2><p>Dan Abramov 也就是 react 的创作者，被小右也就是 vue 的创作者大狙点头之后，对 react beta 文档爆更了 3 天。原因就是被吐槽 TTI 和 TBT 占用时间太长被 vue 的文档吊锤</p><p>所以他对 react beta 文档改动了什么？</p><ul><li>工具函数拆分，改成一文件一函数</li><li>移除过时浏览器支持，从而移除 <code>polyfill</code> 的加载（react 现在也仅支持现代浏览器）</li><li>懒加载资源，例如 <code>@codemirror/lint</code> 和 <code>eslint</code></li></ul><p>所以现代前端优化，好像基础版就这么些操作，大家都是一样的。首先尽可能压低大小（可仅参考 gzip 之后大小），然后尽可能抬高加载速度显示速度（SSR，CDN）</p><p>实在不行，发现瓶颈出现在远端数据，那就上缓存！资源慢缓存资源，数据接口慢缓存数据，什么 service worker 全给它叠起来（x</p><h2 id="Links-3">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/mq2thez/blog/blob/main/upgrade-react-etsy/preact-vs-react.md">Updating React at Etsy</a></li><li><a target="_blank" rel="noopener" href="https://web.dev/browser-level-image-lazy-loading/">Browser-level image lazy-loading for the web</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/geekculture/how-does-dan-abramov-optimize-beta-reactjs-org-after-be-complained-about-website-speed-840b02cf5ee8">How Does Dan Abramov Optimize beta.reactjs.org After Be Complained about Website Speed?</a></li><li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/HTTP--2.html">什么是HTTP/2？</a></li><li><a target="_blank" rel="noopener" href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a></li><li><a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh-js/remesh</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/preact/">preact</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/15/web-optimization/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我早就想拿 QuickJS 做 SSR 了</title>
      <link>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</link>
      <guid>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</guid>
      <pubDate>Mon, 12 Dec 2022 12:33:01 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;鸽了一年，不重要，下一篇解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在几乎现代框架 SSR 默认都是用 &lt;code&gt;node&lt;/code&gt;，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 &lt;code&gt;React&lt;/code&gt; 举例子，SSR 分两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 &lt;code&gt;renderToString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行时水合，也就是不用 &lt;code&gt;render&lt;/code&gt; 而是 &lt;code&gt;hydrate&lt;/code&gt;，因为已经不需要在运行时创建节点，只需要绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以问题就很清晰：默认或者常规手段的 &lt;code&gt;hydrate&lt;/code&gt; 和 &lt;code&gt;renderToString&lt;/code&gt; 都是 JS 函数&lt;/p&gt;
&lt;p&gt;当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：&lt;strong&gt;这 B 是不是可以直接拿来做 SSR ？&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>鸽了一年，不重要，下一篇解释</p></blockquote><p>现在几乎现代框架 SSR 默认都是用 <code>node</code>，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 <code>React</code> 举例子，SSR 分两个步骤：</p><ol><li>静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 <code>renderToString</code></li><li>运行时水合，也就是不用 <code>render</code> 而是 <code>hydrate</code>，因为已经不需要在运行时创建节点，只需要绑定</li></ol><p>所以问题就很清晰：默认或者常规手段的 <code>hydrate</code> 和 <code>renderToString</code> 都是 JS 函数</p><p>当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：<strong>这 B 是不是可以直接拿来做 SSR ？</strong></p><span id="more"></span><h2 id="Why-QuickJS">Why QuickJS</h2><p>毕竟 rust 早就有 v8 绑定，<code>deno</code> 用的就是</p><p>你说得对，但是 QuickJS 是由著名神仙 Fabrice Bellard 所打造的一个小型并且可嵌入的 Javascript 引擎，它支持ES2020规范，包括模块，异步生成器和代理器。在这里，你可以用任何现代的 JavaScript 语言片段在几乎任何语言环境中运行，在自由的环境中邂逅不同的语言和技术栈，同时它还支持 Decimal 提案和运算符重载提案……</p><p>其实就是不挑</p><h2 id="前端">前端</h2><p>流水账，主要是踩坑流程</p><p>前端部分自不必多说，玩了两年半的 <code>solidjs</code>，现在只要不是上班都是用这款（其实上班能夹带私货的时候也用）</p><p><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a> 提供 SSR 各种形态的 demo，但他们都有一个特点：使用非常原生的 <code>rollup</code> 插件作为演示<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，那我正经用也不用这个啊，那不行，就得按 vite 工作流来。</p><p>so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm dlx degit solidjs&#x2F;templates&#x2F;ts</code></pre><p>首先 <code>vite.config.ts</code> 有两处调整：</p><ul><li>solid 插件激活 ssr，这在处理 ssr 输出时有用</li><li><code>noExternal</code>，后面讲为什么</li></ul><p>改完之后大概是这样</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default defineConfig(&#123;  plugins: [solidPlugin(&#123; ssr: true &#125;)],  build: &#123;    target: &quot;esnext&quot;,  &#125;,  ssr: &#123;    noExternal: true,  &#125;,&#125;);</code></pre><p><code>package.json</code> 新增一个 <code>script</code>，不加也行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;vite build --outDir .&#x2F;dist&#x2F;client&quot;,    &quot;build:server&quot;: &quot;vite build --ssr .&#x2F;src&#x2F;entry-server.tsx --outDir .&#x2F;dist&#x2F;server&quot;,  &#125;&#125;</code></pre><p>这里把输出路径都有点调整，目的是把客户端产物和服务端产物分开，不这么做也行。<strong>但入口是肯定分开的</strong>，即使这很基操不需要写下来</p><p>按照 vite 建议的做法，客户端入口从 <code>index.tsx</code> 改为 <code>entry-client.tsx</code>，则服务端入口为 <code>entry-server.tsx</code>，内容每个框架都差不多，按照前端框架的建议做即可</p><p><strong>记得客户端真实入口 <code>index.html</code> 里的 script 路径也要改！</strong></p><p>过一下 build，能看到 dist 下两组目录，下一步</p><h2 id="服务端">服务端</h2><p>Web Framework 不用挑，用的最多的（可能也是两年半），可能也是目前来说依然最虎的 <code>actix-web</code>，需要花心思的是找 binding</p><p>首先用的是 <a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a>，在品鉴这个项目的时候还顺便搜到另一个项目 <a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a>，这是一个类似的操作：通过 QuickJS SSR Vue，可以读读看</p><blockquote><p>Node outperforms QuickJS by a wide margin. Especially with enough cores and memory. However, QuickJS is very small and has very low memory consumption, so running it threaded in a Rust shell makes it possible to have very high throughput using very few resources in comparison.</p></blockquote><p>顺便品鉴完这个项目之后，开始缝合。不出意外的话马上要出意外了</p><h3 id="坑1：">坑1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unsupported keyword: export</code></pre><p>这里可以讲讲为什么上面要 <code>noExternal</code> ，原因很简答，vite 默认你是会用 node 的，加上 type 是 <code>module</code>，结果就是编译后的服务端入口依然有 <code>import</code> 和 <code>export</code></p><p>所以目的很简单：把所有用到的 js 都打成一个文件。并且这里还需要一个操作：去掉最后一行，也就是 <code>export</code> 部分</p><p>默认情况下是在 QuickJS global 环境下 eval 程序，直接当成 <code>REPL</code> 来用就完事了</p><h3 id="坑2：">坑2：</h3><blockquote><p>找不到 setTimeout</p></blockquote><p>一番查找，<code>setTimeout</code> 由 QuickJS 内置 module: os 提供，按道理来说 <code>setTimeout</code> 应该能在 globalThis 直接调用</p><p>没关系，直接 eval 进去吧</p><h3 id="坑3：">坑3：</h3><blockquote><p>不存在 os</p></blockquote><p><strong>这你妈你说你妈呢？</strong> 这怎么可能啊</p><p>只见 Issue 区赫然有这么一行</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs/issues/123">Is there any way to use std, os, and global?</a></li></ul><p>Ok，寄</p><h3 id="Finish">Finish</h3><p>本来看着是 star 最多的库</p><p>算了，还得是直接绑定来得稳定，虽然比较麻烦，相当于换个语言直接使用框架。但高级封装至少比低级封装容易使用</p><p>于是改用这个高级封装：<a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a>，这个就非常纯，需要直接生吃 Document</p><p>简单验证</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let test &#x3D; ctx.eval(&quot;let a &#x3D; 1; let b &#x3D; 2; a + b&quot;).unwrap();assert!(3, test);</code></pre><p>发现没问题，直接搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let result &#x3D; context.with(|ctx| &#123;    let _a: String &#x3D; ctx.eval_file(&quot;ssr&#x2F;dist&#x2F;server&#x2F;entry-server.js&quot;).unwrap();    let result: Object &#x3D; ctx.eval(r#&quot;render()&quot;#).unwrap();    let head: String &#x3D; result.get(&quot;head&quot;).unwrap();    let body: String &#x3D; result.get(&quot;body&quot;).unwrap();    let mut map &#x3D; HashMap::&lt;String, String&gt;::new();    map.insert(&quot;body&quot;.to_string(), body);    map.insert(&quot;head&quot;.to_string(), head);    map&#125;);</code></pre><p>这里转一次 <code>HashMap</code> 的原因是：<code>Object</code> 的类型没有声明，直接 return 出去有静态检查问题，rust 不允许</p><p>但因为是概念验证，先转成已知类型出去顶着用</p><p>编译没问题，继续搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let template &#x3D; read_to_string(&quot;ssr&#x2F;dist&#x2F;client&#x2F;index.html&quot;).unwrap();let html &#x3D; template    .replace(&quot;&lt;!--app-head--&gt;&quot;, result.get(&quot;head&quot;).unwrap())    .replace(&quot;&lt;!--app-body--&gt;&quot;, result.get(&quot;body&quot;).unwrap());</code></pre><p>打印 html，确认内容就是一个完整的 html 文件。<strong>成了！</strong></p><p>那直接上 server-side，简简单单写个 get</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[get(&quot;&#x2F;&quot;)]async fn hello() -&gt; impl Responder &#123;    let html &#x3D; make_html();    HttpResponse::Ok()        .status(StatusCode::OK)        .content_type(&quot;text&#x2F;html&quot;)        .body(html)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123;    HttpServer::new(|| &#123;        App::new()            &#x2F;&#x2F; 静态文件映射            .service(Files::new(&quot;&#x2F;assets&quot;, &quot;ssr&#x2F;dist&#x2F;client&#x2F;assets&quot;))            .service(hello)    &#125;)    .bind((&quot;127.0.0.1&quot;, 8080))?    .run()    .await&#125;</code></pre><p>浏览器输入一个令人熟悉的 <code>localhost:8080</code>，正常运行，JS 绑定也一切正常</p><p>代码会发布在 <a target="_blank" rel="noopener" href="https://github.com/colmugx/quickjs-ssr">colmugx/quickjs-ssr</a></p><h2 id="最后-3">最后</h2><p>这里只是一个简单验证，SSR 的 real world 肯定不是这么两步就能完成，否则就不需要像 <code>next.js</code> 和 <code>SolidStart</code> 这样的上层框架</p><p>并且，除了服务端需要考虑线程池等等这些问题之外，拥有 JIT 的 v8 可能性能上会更优</p><p>但我的目的也很简单，我要的不是 SSR，而是两个需求</p><ul><li>给 <code>ayaka</code> 提供一个静态页面生成的方式，但默认还是像 <code>saika</code> 那样的运行时 fetch</li><li>给 <code>kazusa</code> 提供脚本执行环境，不过这是个 optional，主要维护还是 lua 执行环境，这与既定用户群有关</li></ul><p>别问为什么又来一个 <code>ayaka</code>，问就是灵感来源 <a target="_blank" rel="noopener" href="https://github.com/2nthony/saika">2nthony/saika</a>，而不叫<code>sakuya</code>的原因仅是因为那会在玩原神银趴</p><p>最后，这可能是第一篇来自于这个主题 3.5 版本的文章，想给用 hexo 的这段时间一个完美的休止符，然后去开发有新设计风格的 nlvi 4</p><p>但是重构一半，交互上还是有缺陷，只不过说不影响阅读</p><h2 id="Links">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>solidjs 的 vite 插件来源于 rollup 插件的上层封装 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9D%82%E8%80%8D/">杂耍</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/quickjs/">quickjs</category>
      
      <category domain="https://colmugx.github.io/blog/tags/vite/">vite</category>
      
      <category domain="https://colmugx.github.io/blog/tags/solid/">solid</category>
      
      <category domain="https://colmugx.github.io/blog/tags/ssr/">ssr</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>作为玩家 成为玩家</title>
      <link>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</link>
      <guid>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</guid>
      <pubDate>Fri, 07 Jan 2022 11:21:34 GMT</pubDate>
      
      <description>&lt;p&gt;实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那是一篇极其消极的文章&lt;/li&gt;
&lt;li&gt;本文是一次自我救赎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so，这也许是更合适的“年终总结”&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-11&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虽然还是前端，但身处游戏&lt;/li&gt;
&lt;li&gt;对于以上，为什么&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：</p><ul><li>那是一篇极其消极的文章</li><li>本文是一次自我救赎</li></ul><p>so，这也许是更合适的“年终总结”</p><h2 id="TL-DR-11">TL;DR</h2><ul><li>虽然还是前端，但身处游戏</li><li>对于以上，为什么</li></ul><span id="more"></span><h2 id="因为热爱">因为热爱</h2><blockquote><p>从主观感受聊到游戏设计，这大概就是热爱吧 —— 2021.4.30</p></blockquote><p>我觉得故事不用从盘古开天辟地开始讲起</p><p>非常幸运的是，当时的工作环境中，团队所有人都玩游戏，大部分都玩高品质单机游戏，所以我们业余茶歇都会聊游戏。甚至分享可以讨论游戏，甚至在会议室玩《决斗链接》，两人duel，其他人通过电视观战。而那会面试的时候，我们经常问的“你业余时间一般会做什么”，在得到瞬间的回答“我平时不玩游戏”反而会感到诧异</p><p>在当时，除了会讨论游戏好不好玩之外，我经常又会往下继续讨论。跟另外一位同事经常讨论现在的热点，以及游戏细节，和“我为什么喜欢xx游戏”。那个时候根本没想过会到游戏公司服务，大家只是玩家</p><p>后来遇到一些朋友，无一例外都来自于游戏公司。于是在氛围煽动下，我离开了所处不久的新环境。这里只能说：感谢 VP 的理解和支持，同时我没办法回应你的欣赏，实属抱歉</p><h2 id="“黑暗降临”">“黑暗降临”</h2><blockquote><p>永远不要忘记第一次听《疾如猛火》后潸然泪下的那个中午</p></blockquote><p>作为一个营销碰瓷游戏，在此之前我从来没有关心过，黑暗降临也指的是第一次的营销碰瓷。但在一次内部分享之前，一切都改变了</p><p>分享的大概主题是“原神的音乐设计”，发生在分享之前，游戏新闻也多多少少提到：</p><blockquote><p>《崩坏3》和《原神》的音乐火到出圈</p></blockquote><p>于是，这是我与原神的第一次接触 —— 我打开了原神的主主题（Main Theme）。那个层次的细腻和画面感一下子涌入脑中，光听音乐已经能大概能看到这是一片幻想大陆</p><p>紧接着，我听了一些场景音乐。有个熟悉的特点，场景音乐都分为日间和夜间，这个设计在这之前仅有《异度之刃》系列对我印象深刻</p><p>当天中午，引用的故事发生了。在五声宫调跳进中古调，加上民乐领跑，饱满的感情直接轰入灵魂。因为原神的早期世界观架在欧洲，主题也就偏中古调式。《疾如猛火》就是一首同时具有璃月主题与原神主题的战斗音乐，也就是就东方体裁碰撞西方体裁，民乐器碰撞管弦乐，毫不突兀，又交相辉映……就这样一下子崩不住了。落泪原因简单：在我们生活的这片土地上，真的诞生了品质如此优秀的游戏</p><p>其实很长一段时间我都没有打开过原神，下载过原神。但城邦、人物性格、人际特点几乎都靠音乐云了个七七八八。蒙德有大大小小的西欧建筑，遍地风车，人们过着惬意的生活；繁荣的璃月港口络绎不绝，不仅存在丰富的中华文化，更是做到最大的文化包容；像是一个存在于战争或荒乱的稻妻，人民憧憬和平，满怀希望。在绀田村的表达中更为明显，仿佛妻离子散，每天都盼望家人回家……而每个元素也有独特的风格，雷元素会有重金属或者电子音乐，火元素有急躁的风格或者摇滚，水元素总会用带有故事感的钢琴带情绪……</p><p>且不谈游戏质量，这已经能证明这是成功的游戏音乐了</p><p>这是一个即使现在想起来还是会鼻尖一酸的回忆，<strong>所以我不断提醒自己，不要忘记这个感觉。</strong>《鬼谷八荒》、《风来之国》、《戴森球计划》等等证明了我们是可以做出优秀的游戏，《原神》向我们展示了我们也能做出贴近日系上游品质的游戏。但是 <strong>这个日系游戏并没有屈服于这个 title —— 璃月的刻画告诉了全世界什么是中华文化。</strong> 原本我没有喜欢过任何一个角色，现在有了：<strong>红毹婵娟 —— 云堇</strong></p><p>与其说是爱上了 miHoYo，不如说只是喜欢 HoYo-MiX。我还是不会主动向人推荐《原神》</p><h2 id="“未成年保护”">“未成年保护”</h2><blockquote><p>周五、周六、周日和法定节假日<br>20:00 ~ 21:00</p></blockquote><p>两个朋友同一时间离职，相继去了三个不同的行业：游戏、教育、房地产。于是后面发生了什么已经不用讲了（笑</p><p>虽然 ban 的是网络游戏。但难免有些感慨。国内的游戏环境还是太糟糕了，被各种数值网游污染，导致人们根本没办法理解什么是游戏，怎么对待游戏。现在还有绝大多数人认为游戏 = 打怪升级刷刷刷，他们不懂《双人成行》为什么必须两个人玩；《风之旅人》为什么不告诉玩家 NPC 的由来；《传说之下》为什么不能打怪升级；《我的世界》为什么能成为电子工程摇篮（x</p><p>针对游戏问题，更重要的是成长期的陪伴。任天堂在 2000 年的时候就推出了“防沉迷机制”<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但人家是如何理解防沉迷的？</p><blockquote><p>Wii的“家长监控”模式，最终选择了记录孩子的游戏时间，让他们和家长自行沟通决定游戏时间，用主机里的“游戏履历”督促孩子遵守约定，达到和“断电”同样的目的。</p><p>总之，大部分限制都能调整，只要家长和孩子商量好就行。这是任天堂“家长监控”系统的最大亮点。</p></blockquote><p>任天堂在本来是提供给监护人的信《致监护人》预判了“孩子可能正在寻找解除限制的方式”，并留下了一段话告诉小朋友：</p><blockquote><p>不守诺言，整天玩游戏肯定是不行的<br>但如果是“我才玩了一会……”就被爸爸妈妈说了<br>那或许就是没有好好决定游戏时间的缘故了！</p><p>确定一个规则，然后让爸爸妈妈通过这个软件监督自己，这样就能开开心心玩游戏了</p></blockquote><p>我是相信人在思维最发散的时候是应该接触电子游戏或者沙盘游戏的，而且应该培养一个健康的游戏价值观。<strong>至于那些什么“电子海洛因”的家长，反正每一代都有上瘾的东西。</strong> 尝试反问你的家长，上学的时候有没有沉迷过武侠小说，有没有沉迷过滚铁环，至少我屡试不爽。什么时候为人父母才能懂得：<strong>家庭才是第一教育场所，陪伴才是第一教育资源。</strong> 怪电视，怪游戏，怪玩具，怪邻居都是不可能解决问题的</p><p>你觉得你很忙，没时间陪孩子，把手机一丢让孩子自己玩。即使你手机没有王者荣耀，你的孩子也会因为抖音上瘾。到时候你敢举报抖音吗？你不敢！因为你也正上瘾着呢！</p><h2 id="主程摆烂">主程摆烂</h2><blockquote><ul><li>这个实现不了</li><li>我们最近太忙了，有空看一下</li></ul></blockquote><p>这来自于真实情况，但我只能轻描淡写</p><p>作为发行，确实有很多运营工作是需要我们做的，其中就有游戏中的社区入口。我们对接的两个游戏，一个 webview 不撑满，一个 webview 保留默认工具栏，更甚的是 android 与 iOS 的工具栏位置不同，但它们都会挤压视图空间。而这两个问题本不是问题，对于 unity editor 来说仅仅是一个开关而已。而当我们提出了问题时，对方回复了引用1；而当我们提出解决方式：仅加一条声明，对方回复了引用2</p><p>并且在合作过程中，游戏方经常爱理不理，甚至出现内存泄露时还直接推锅是社区造成的，<strong>并转发崩溃堆栈给我们排查问题，你他妈是认真的吗？</strong></p><p>这让我感受到了，“带着热爱工作”只是我的一厢情愿而已，无论到哪都是如此。我不再出声，用 unity 模拟了我们需要的调试环境（只用了一个 webview，并对 webview 定制），并加入他们不愿意做的退出功能（不愿意取消工具栏的原因是没有工具栏退出不了场景）。以此来解决我们的调试工作经常受阻导致我们自己的开发周期被压缩，最后再进游戏运行一遍确认效果即可</p><p>彼时彼刻我真的很敬仰腾讯游戏，在《腾讯游戏开发精粹2》里他们描述到了，他们在三个游戏引擎都开发了渲染后端，让社区和活动页面都能直接渲染在游戏引擎中。这种做法无论什么角度都是完美的，而我们却还在这种狗屁事情纠缠不清</p><h2 id="浅墨离世">浅墨离世</h2><blockquote><p>愿这本书，能帮助那些热爱游戏编程、怀揣游戏开发梦想，却苦于难以入门的人们，让他们少走弯路。</p><p>愿这本书，能为国产游戏、国产游戏引擎的崛起，开启一扇门，迎接新的黎明。</p><p>我们都还年轻，该做的梦及时去做，该追寻的梦想用力去追寻。</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><blockquote><p>我有一个梦想，将来的某一天，大家都能玩到拥有自己本土文化的优质游戏。</p><p>我有一个梦想，有一天，西游记能出ACT，让老外去体会中国文化西游记中“斗战胜佛”的打击快感，那一定比西方的动作巅峰之作《战神》、《鬼泣》更加深邃。</p><p>我有一个梦想，有一天，上海滩能出沙盒游戏，而不是玩《GTA》感受美国梦，亦或是玩着《热血无赖》体验国外公司强行塞给我们的“中国文化”。</p><p>我有一个梦想，有一天，不少3A大作不需要汉化，因为是我们自己的游戏，配音是中国的，文化也是中国的。</p><p>我有一个梦想，将来的某一天，国产游戏能像中国的其他产业一样，以一个领跑者的姿态，面对全世界，面对全宇宙，器宇轩昂，扬眉吐气。</p><p>这会是由我们一起去完成的梦想。</p><p>等着我们的好消息！</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><p>我不会揣摩已故之人，但能写下如此文字的人最后的结果竟然如此令人遗憾，想必在那瞬间肯定是无比绝望吧</p><p>我对浅墨并不熟悉，在这之前仅通过 opencv 了解过。在这之前因为方向不同，所以对 shader 等等也不关心。在某个周六，兄弟加班出门吃饭时，看到了某座楼下面围起来了，还在叹息：</p><blockquote><p>XX游戏怎么又……（为什么加又）</p></blockquote><p>当知道当事人是如此追梦人时，没有人不是心酸的。但凡在知乎看过那两则招聘文章，即使评论区各种冷嘲热讽，也能感受到作者对这件事抱足了信心。</p><p>也许世界就是这么现实吧。有人正在坚持“技术宅改变世界”，有人在摆烂，有人因为可能过高投入导致评估收益不清晰而在投入之前终止了投入</p><h2 id="最后-4">最后</h2><blockquote><p>在我的名片上，我是一个公司总裁；<br>在我自己来看，我是一名游戏开发者；<br>而在内心深处，我是一名玩家。</p><p>—— 岩田聪 -《玩者之心》- GDC2005</p></blockquote><p>故事是经过排列的，每发生一个事件，这种无助又坚定的心情就加深一层</p><p>《原神》向我们和世界展示了国产优秀的架空世界观和国产游戏音乐，我们再也不用羡慕史克威尔的音乐；《黑神话：悟空》向我们和世界展示了各个角度的正版“斗战胜佛”，我们再也不用羡慕拥有《战神》的圣莫妮卡。未来还有更多可能</p><p>但我们的环境还是很糟糕。所以，我能不能也做点什么，能不能不再是少数人的世界，能不能让更多人理解，即使这对我来说完全陌生。打嘴炮是最简单的，但这件事可能真的入脑了 —— 我开始怀疑我的选择和自己：我真的可以做到吗？我可什么都不会啊！</p><p>就像 2022 年潘通流行色<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>想要表达的那样（老样子，博客换颜色了），也刚好贴近自己和博客一直的追求：<strong>让一切充满想象力</strong>，希望可以继续坚持下去。毕竟，整个评论区可都是“你可以！！”啊</p><p>其实 <code>godot-pong</code> 是有在做的，现在是填充基本规则和做了音效音乐（音乐觉得做废了打算重做所以迟迟没上传）</p><p>希望 2021 年留下来的这篇文章，在未来不会被自己删除，并时刻提醒自己</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/461405.html">https://www.huxiu.com/article/461405.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2022">PANTONE COLOR OF THE YEAR 2022</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>为什么我没想过 EventBus</title>
      <link>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</link>
      <guid>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</guid>
      <pubDate>Wed, 24 Nov 2021 14:32:35 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;以下全是暴论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个发生在今年的对话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：组件通信有几种方式？&lt;br&gt;
A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children&lt;br&gt;
Q：还有吗？&lt;br&gt;
A：postmessage 可以算吗&lt;br&gt;
Q：也行，还有吗？&lt;br&gt;
A：localStorage/sessionStorage 可以算吗？&lt;br&gt;
Q：算半个，还有吗？&lt;/p&gt;
&lt;p&gt;这 TM 不就这些方式还有吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回来一拉清单，各家文章盘点确实还多了一个：&lt;code&gt;EventBus&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>以下全是暴论</p></blockquote><p>这是一个发生在今年的对话：</p><blockquote><p>Q：组件通信有几种方式？<br>A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children<br>Q：还有吗？<br>A：postmessage 可以算吗<br>Q：也行，还有吗？<br>A：localStorage/sessionStorage 可以算吗？<br>Q：算半个，还有吗？</p><p>这 TM 不就这些方式还有吗？</p></blockquote><p>回来一拉清单，各家文章盘点确实还多了一个：<code>EventBus</code></p><span id="more"></span><h2 id="什么是-eventbus">什么是 eventbus</h2><p>简单理解：事件总线，一种订阅/发布模型，即是在希望发生事件处理的地方创造一个监听器(listener)，接着在希望影响到监听器所在位置变化或更新的地方加上发射器(emitter)</p><p>这样的好处是，任何位置都可以透传。因为事件总线（可以）是全局的</p><p>从名字上看，它应该是属于事件驱动设计的产物。这没问题，GUI 一直都跟事件驱动有关，浏览器在交互部分也是这么做的</p><p>那，这么多前端框架有没有使用事件驱动的？有，御三家里的 <code>Angular</code>。除了御三家那更多了，反而数据驱动才是新品种</p><p>OK 目的达成，我就是要绕到这个点上：为什么面试上问 Vue，甚至是 React，我就没想过 EventBus。<strong>因为这本来就跟数据驱动没关系</strong></p><h2 id="为什么我不用-eventbus">为什么我不用 eventbus</h2><p>不带 Vue 玩了这领域有争议。就一个问题：什么时候 React 会触发更新？</p><p>这个时候就应该有个经典公式：view = f(props, state)。也就是当 <code>props</code> 或者 <code>state</code> 发生更新了，<code>view</code> 会更新。或者换句话说，<strong>数据更新了视图会更新</strong></p><p>那这里就有一个问题：如果触发了某个事件，视图会更新吗？<strong>会更个几把！</strong> 要会更新你还需要 <code>setState</code> 吗？这也是为什么 <code>rxjs</code> 在 <code>React</code> 用起来就是没有 <code>Angular</code> 来得无尿点，最核心的一点就是你想通过 <code>rxjs</code> 通知视图更新就肯定需要在订阅做一次 <code>setState</code>，不管你封装了还是在 business code 里订阅一次写一次</p><p>而且我不用还有另一个原因：这东西在我的理解中，就是一个 <code>goto</code> —— 它会把代码弄得非常糟。本来是单向的数据流向，现在会完全不知道某个组件会因为什么而产生更新，流向变得不可观察</p><p>你可能会说，那 context 也是这么传的啊！可 eventbus 可不禁止子组件 call 父组件，不约定好就造成逆数据流</p><p>除此之外，事件名称是一个字符串（暂且只能是字符串），那么这个时候需要保证事件名不要重复。为了解决这个问题可能就会引入一个叫事件表的东西 —— 但你想用到某一个事件时，import 这个常量，毕竟常量背后什么静态值对于事件来说无所谓，对得上就行。这会发生什么问题？在生产过程中这问题发生得不要太多，最经典的就是忘记更新事件表，或者嫌麻烦摆烂直接写，最后发现因为一个大小写导致事件对不上……</p><p>除此之外还有！毕竟是一个订阅发布模型，你订阅了是不是得取消订阅。事件的东西你一旦开了他就会一直留存在内存中，处理不当的话可能会出现两个一模一样的 listener，而这个原因仅是因为上一个没有销毁……当然了最轻的问题就是你的某一个事件处理会响应 n 次，是的这只是最轻的</p><p>总之这非常反思维，在一个数据驱动的环境中，为了一点点 buff 而引入大量 debuff 是否得不偿失。经过一轮网上冲浪后发现，相关讨论不少（指两个）</p><ul><li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/t/event-bus-is-it-a-good-idea/49853">Event bus - is it a good idea?</a></li><li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/androiddev/comments/eksepr/why_some_people_dislike_eventbus/">Why some people dislike EventBus?</a></li><li><a target="_blank" rel="noopener" href="https://tkacz.pro/vue-js-why-event-bus-is-bad-idea/">Vue.js: why event bus is bad idea</a></li></ul><h2 id="你真的需要-eventbus？你用来做什么？">你真的需要 eventbus？你用来做什么？</h2><p>Vue 有 provider/inject，React 有 Context API，这应该够用了</p><p>跟数据有关的 API，Vue 有 Vuex，React 有 React / Recoil。他们本身也会遵循单向数据流</p><p>所以，到底是哪里需要在 React 环境中引入一个不属于数据驱动的东西。或者换个思路（挖个坑）：</p><p><strong>我们是否正在被框架绑定？一个本只是视图层框架，现在还包含了逻辑层？</strong></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B/">编程</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 一起玩吧</title>
      <link>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</link>
      <guid>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</guid>
      <pubDate>Fri, 03 Sep 2021 17:52:52 GMT</pubDate>
      
      <description>&lt;p&gt;稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-5&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;启动页面、得分牌&lt;/li&gt;
&lt;li&gt;加入简单的 AI&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-5">TL;DR</h2><ul><li>启动页面、得分牌</li><li>加入简单的 AI</li></ul><span id="more"></span><h2 id="完成情况">完成情况</h2><p>这把已经像一个游戏了。所以，可以一起玩吧</p><p>以下是记录本次更新一部分内容</p><h3 id="UI">UI</h3><p>目前是加了一个标题场景，但是过于没东西讲。老前端熟悉的 <code>flex</code> 布局思路一通搞完事</p><h4 id="切换场景">切换场景</h4><p>游戏是按场景(scene)来区分页面(非常前端的描述)，比如关卡类游戏一般会做很多 level 的场景。不同的是这可没有所谓的路由，而是直接切换(change)</p><p>这里使用的是：获取场景树，得到实例，切换场景(change_scene)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get_tree()-&gt;change_scene(path);</code></pre><p>这个项目里的实现是：把这种按钮直接做成「组件」，暴露场景接口。在标题场景 <code>connect</code> 所有这个类型的事件，用统一事件处理跳转。这样就封装了跳转场景，方便以后处理设置界面啥的</p><h4 id="记分牌动画">记分牌动画</h4><p>有一个控件 <code>AnimationPlayer</code> ，用来控制能访问到的节点的动画，例如运动、变形。如果使用过 <code>flash</code> 那是相当熟悉 —— 关键帧打起来</p><h3 id="加入-AI">加入 AI</h3><p>周伯通虽然也行，但是自己玩还是得有个「对手」</p><p>现在看到 AI 人就不知觉紧张起来，感觉是个非常难的东西。其实 AI 就只是「人工智能」，其目的就是「假装是个人」，那游戏 AI 就是「假装有个陪你打游戏的人」。只不过现在的「机器学习」确实给游戏 AI 也带来了不少想象力 —— 他们的操作越来越像人的思维方式了</p><p>多智能还得看开发者。例如中小学机器人编程比赛中的经典项目足球项目和灭火项目，</p><blockquote><p>足球项目：最简单的逻辑就是通过传感器（指南针）判断两边方向，超声波测距，忘记什么传感器用来找球。摸到球之后直接把球往对方门里「撞」，完事。</p></blockquote><blockquote><p>灭火项目：都带着指南针和热力传感，主要还是看谁的寻路比较nb</p></blockquote><p>游戏 AI 很早就有，最经典的游戏 AI 还属南梦宫的吃豆人(pacman)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（对于我来说一样属于游戏设计必修课，甚至机器学习也可以）。</p><blockquote><p>一共四个干扰怪物，逻辑都不相同</p><p>红色 blinky：追着豆子，通过寻路算法找距离最近的路线<br>粉色 pinky：追豆子前方第四个格子，通过寻路算法找距离最近的路线。如果向上移动，则是左上方四个格子<br>青色 lnky：blinky 与豆子各自前方射线的交点，并两倍延长的点<br>橙色 clyde：追豆子到方圆 8 格内就会散开（纯气氛组）</p><p>四个单个逻辑不复杂且工作量很小的 AI，组合成一个看似一直在围堵玩家的敌方小队。这就是最经典的地方</p></blockquote><p>这篇文章再开个坑：我要写一篇我对游戏 AI 的理解。例如游戏设计中，一些非常难的 gameplay 可能会设计出让 AI 「放水」，让玩家以为 AI 真的翻车了，以此来鼓励玩家</p><p>好了，这一部分的重点本应该是这个游戏的 AI，目前的设计是： <strong>在自己的 y 与球的 y 距离大于 25 时，追球。25 差不多是板子的 1/4。</strong> 逻辑就这，没了</p><p>但别小看这简单的逻辑，在目前没有什么骚东西的环境下，只要没有什么花里胡哨的操作（例如拿板边去敲球）几乎没有胜利的机会。而现在这个环境玩骚的只会把自己的分骚没（比如我）</p><h3 id="冷却与重置">冷却与重置</h3><p>当球落某方门后，球会重置到游戏中点，没有操作，直接关闭了惯性和直接 set position</p><p>不过有一个小设计：败方接球。如果某方上一回合输了，这一回合由该方接首发球</p><p>所以，虽然是可以玩了，但是还是缺东西，比如很多关于游戏规则的完善</p><h2 id="下一步">下一步</h2><ul><li>发球 y 随机：目前发球的 y 是固定的，直接去接球点等球多没意思啊</li><li>随机首发球：第一球现在都发给左方，或许应该随机</li><li>胜利规则：现在这游戏一开就没边了…</li><li>暂停与结束界面</li><li>声音</li></ul><p>游戏补完之后，往后的更新就越来越慢了，因为想法越骚，实现也会越来越难</p><h2 id="Link">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82567889">游戏AI入门及AI优化</a></li><li><a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html">AnimationPlayer</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27177424">现代游戏AI的鼻祖——聊聊你所不知道的《吃豆人》</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 发布</title>
      <link>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</link>
      <guid>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</guid>
      <pubDate>Thu, 02 Sep 2021 15:55:09 GMT</pubDate>
      
      <description>&lt;p&gt;其实游戏已经做很远了，为了真实性删了很多添加的东西…&lt;/p&gt;
&lt;p&gt;本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-6&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完成基本的击打、胜利条件、球的恢复&lt;/li&gt;
&lt;li&gt;编译与发布&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>其实游戏已经做很远了，为了真实性删了很多添加的东西…</p><p>本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-6">TL;DR</h2><ul><li>完成基本的击打、胜利条件、球的恢复</li><li>编译与发布</li></ul><span id="more"></span><h2 id="完成情况-2">完成情况</h2><p>基本的 gameplay 已经完成 —— 两块板子一个球，板子的后面是各自的「门」。</p><p>门选择 <code>Area2D</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，原因是这个控件专门控制物理状态与检查物理状态；墙壁使用<code>StaticBody2D</code></p><p>板子和球目前均使用 <code>KinematicBody2D</code>，因为可以方便的模拟物理状态，反弹完全不需要代码描述。但板子可能应该换成<code>RigidBody2D</code>，这样可以模拟更多的真实物理，例如摩擦力，受力。不过目前需要求证：控制端使用 <code>RigidBody</code> 是否合理</p><p>完全没什么好讲的，非常简单的实现</p><h2 id="编译与发布">编译与发布</h2><p>由于 <code>native</code> 的关系，运行时会把 cpp 编译，并编译成动态链接库。例如 osx 使用 <code>.dylib</code>，那么 web 跟原生相关的肯定是 <code>.wasm</code> 。官方提供了原生端的案例<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，而开发时也只编译了 osx 版本。</p><p>直到要验证发布到 github pages 时，出大问题，浏览器只显示 <code>abort(undefined)</code></p><h3 id="目前不能使用最新的-emscripten-编译你的-wasm">目前不能使用最新的 emscripten 编译你的 wasm</h3><p>经历各种尝试，例如直接从源码编译新的 template，但编译时也频出问题，甚至 debug 无法成功编译，接着进入无尽改编译参数等各种操作……</p><p>直到看到这个 issue <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>因为之前一直使用的 <code>emscripten</code> 版本已经是 26，所以猜<strong>是不是跟版本有关系，于是换成 17，成了</strong></p><p>于是有另一个猜想：<strong>官方发布的模板是否因为也使用 17 的版本发布，会导致 dll 对应不上。业务代码必须同样使用 17 编译代码才可以使用？</strong></p><h3 id="交给-github-action">交给 github action</h3><p>因为刚刚的 issue，发现这个作者对 godot 发布已经了然于胸，最后发现他提供了一个 ci 配置<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，于是参考这个配置写了一个工作流，现在可以把整个发布路程交到 github 了</p><h3 id="记得提交-export-presets">记得提交 export_presets</h3><p>可能可以发现，前面大部分 action 都是失败的</p><p>如果选择了 github 的 .gitignore 模板，这个文件默认会被忽略。但缺少这个文件 ci 无法工作 —— 获取不到发布配置</p><p>so，记得提交，接着等待一切结束。顺带一提，github action 的配置应该不高，编译 godot-cpp 属实膀胱局</p><p>下一篇应该讲有完整 UI 的第一个版本，结束</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/physics/using_area_2d.html">使用 Area2D</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative C++示例</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-cpp/issues/554">Building for HTML5 stopped working for emsdk 2.0.18+</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/2shady4u/godot-cpp-ci">2shady4u/godot-cpp-ci </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 介绍</title>
      <link>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</link>
      <guid>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</guid>
      <pubDate>Sun, 29 Aug 2021 14:10:49 GMT</pubDate>
      
      <description>&lt;p&gt;做一个简单的项目介绍：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;godot engine&lt;/code&gt; 从零开始的 &lt;code&gt;pong game&lt;/code&gt; 开发。开发会尽量保持简单，但希望不缺挑战&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;pong&lt;/code&gt; 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：&lt;strong&gt;不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作&lt;/p&gt;
&lt;p&gt;所以项目将会使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;godot 3 (gdnative)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;photopea（用来弄点素材）&lt;/li&gt;
&lt;li&gt;garageband / logic（声音）&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>做一个简单的项目介绍：</p><p>使用 <code>godot engine</code> 从零开始的 <code>pong game</code> 开发。开发会尽量保持简单，但希望不缺挑战</p><p>实现 <code>pong</code> 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：<strong>不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去</strong></p><p>这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作</p><p>所以项目将会使用：</p><ul><li>godot 3 (gdnative)</li><li><strong>C++</strong></li><li>photopea（用来弄点素材）</li><li>garageband / logic（声音）</li></ul><span id="more"></span><h2 id="你-TM-怎么想的">你 TM 怎么想的</h2><p>「在岸上永远学不会游泳」，这是在当时听到的兄弟对我说的一句话。<s>希望他不是因为嫌我菜让我爬而说出来的话</s></p><p>也为了记录，「如果单就以 pong 作为母版，到底能做到什么样子」，所以本身也是一个兴趣导向产物</p><p>这个系列还是不定期更新，甚至可能随时流产。流产的原因只有一个：搞不出来了…</p><p>就这样。下一篇先写一切的基础：如何让 pong 运行起来</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F/">游戏</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
