<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    
    <image>
      <url>https://avatars2.githubusercontent.com/u/21327913?v=3&amp;s=466</url>
      <title>Colmugx &#39;s Blog</title>
      <link>https://colmugx.github.io/blog/</link>
    </image>
    
    <atom:link href="https://colmugx.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Thu, 20 Jul 2023 15:27:13 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>写代码还有激情吗?</title>
      <link>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/</link>
      <guid>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/</guid>
      <pubDate>Thu, 20 Jul 2023 13:27:31 GMT</pubDate>
      
      <description>&lt;p&gt;在今年的上半年，看以前以码为友的群，群主在逼问一个群友。详情看这个吧&lt;/p&gt;
&lt;p&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://2nthony.com/posts/passion-of-coding&quot;&gt;写代码还有热/激情吗? - 2nthony&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说实话，代码这个事情想到还是会激情澎湃，每天还是能维持非常活跃的「创作」思维。但是写代码，还是淡了&lt;/p&gt;
&lt;p&gt;原因有很多，体力、生活、工作……&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>在今年的上半年，看以前以码为友的群，群主在逼问一个群友。详情看这个吧</p><p><a target="_blank" rel="noopener" href="https://2nthony.com/posts/passion-of-coding">写代码还有热/激情吗? - 2nthony</a></p><p>说实话，代码这个事情想到还是会激情澎湃，每天还是能维持非常活跃的「创作」思维。但是写代码，还是淡了</p><p>原因有很多，体力、生活、工作……</p><span id="more"></span><h2 id="关于体力">关于体力</h2><p>别不承认，确实会随着年龄增长而感觉力不从心。刚毕业的时候能因为热情莽它个凌晨3点，第二天8天照样醒来去上班。相当于一天 <strong>仅需要 6 小时</strong> 睡眠时间就可以满足一天的生活</p><p>现在是做不到了，回到家会明显感受到疲倦。可以说现在上班因为「不纯粹」导致花费太多的精力，下班了再看到电脑只会想起白天的事情，故大多数时间不想使用电脑</p><p>也可以说剩余的精力确实无法支持了，以至于其实很多时候都会想「如果有机器能直接让我的想法变现就好了，不是要无中生有变成产品，我可以颅内编程」</p><h2 id="关于工作">关于工作</h2><p>Actually，上班时还是有写一些东西。这两年都在实现「无框架化」的操作。</p><blockquote><p>AVR is evil – Phodal</p></blockquote><p>写了两个东西：</p><p>第一个是对业务的沉淀，实用型库。大多数 infrastructure 类型的例如 <code>Request</code>, <code>Tracking</code> 都是 Adaptor Pattern</p><p>第二个是框架化的实践。我希望把整洁架构和六边形架构都融合到前端项目中来，因为我们接下来的项目属于是中型长线更新型项目，严格意义上并不算「前端」，所以有完整的测试和 DDD 明显会更好。主要技术还是 DI 和单例，CQRS, ES 我们都会包含到框架里</p><p>并且很明显，第二个产品会提供 adaptor port 给第一个产品，也就是第一个产品的 <code>Request</code> 和 <code>Tracking</code> 等等也会有 adaptor 接到框架，也就是 Application - Adaptor - Adaptor…</p><p>但显然两个框架都在我手里，interface 是一样的就完事儿了</p><p>除此之外还有一个远程观察/调试工具也正在开发，我觉得很有意义。例如远程请求拦截，观察应用运行状态，甚至直接观察操作（webrtc 可以做到）</p><p>第二第三是计划开源，到时候看内部情况</p><h2 id="关于生活">关于生活</h2><p>确实生活的影响也很大，除了说自身身体之外，生活上的事情也会影响到我。但我确实不喜欢讨论自己的生活</p><p>其实可以盘算一下，我已经立项的项目到现在都过了多久</p><ul><li>nlvi 3.0：19年，直接放弃</li><li>nlvi Next：20年，没有进展</li><li>resumer：20年，因为简历直接没有需求所以不做</li><li>kazusa：20年开始，22年调整方向，至今只是能读取文件</li><li>setsuna：20年提到，21年还在技术选型，至今没有像样的逻辑</li><li>ayaka：22年提出，只能说实现一个 SPA Blog 的话能勉强算是一个 POC</li><li>evolution pong：一个不断加游戏设计到 pong 看能有什么效果的实验，甚至是大逃杀</li><li>……</li></ul><p>坑多，每个坑的规划（项目管理）做得不好，加上设计不充分。导致每次打开电脑想开始某一段开发时，总会被各种问题困扰或者无法推进，最终只会是「先想想还没想好」而终止开发</p><p>加上现在会投入很多时间给自己的生活，可能原本周末会坐下来，即使只是坐着没有推进，但还是会验证一两个技术问题。而现在……</p><h2 id="所以">所以</h2><p>flappy bird。只要点击屏幕，bird 就会稍微抬头；但只要放弃点击屏幕，bird 就会下坠，而且是重力下坠</p><p>当我觉得「还是要放弃吗」的时候，我会去看看曾经的自己，看看曾经也对此有过激情的朋友们：包括不限于 yuexun, 2nthony，或是 Randy</p><p>其实我已经慢慢变得对信息不太敏感，也不知道现在该去哪里看什么东西。我也曾经让 4ark 推荐我一些 RSS</p><p>当我发现 yuexun 还会去参加 RustConf 的时候我还是会先是羡慕，然后想</p><p>我是否还是程序员？</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E8%81%8C%E4%B8%9A%E6%80%9D%E8%80%83/">职业思考</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2023/07/20/passion-of-coding/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>跟 ChatGPT 共同创作？</title>
      <link>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/</link>
      <guid>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/</guid>
      <pubDate>Sun, 02 Apr 2023 08:59:50 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;img src=&quot;/blog/Image/bingai-dalle.jpeg&quot; alt=&quot;Bing 调用 DELL-E 生成结局场景&quot;&gt;&lt;/p&gt;
&lt;p&gt;不讲虚的，直接开始&lt;/p&gt;
&lt;p&gt;正文在最后一个章节，爱看不看&lt;/p&gt;
&lt;p&gt;如果你选择阅读，希望你可以猜测一下：哪部分内容由 AI 生成的？&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Tips: 不一定是成片的内容，全程有来有回&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;配合的版本是 Bing AI&lt;/li&gt;
&lt;li&gt;出于这B的限制，文章除了是多次对话拼接而来，还需要应对实时更新问题&lt;/li&gt;
&lt;li&gt;联网、实时的 ChatGPT 更令人害怕&lt;/li&gt;
&lt;li&gt;颠覆了原本我对 NLP 原本的理解&lt;/li&gt;
&lt;li&gt;用于文学创作还是太硬，它依然还是“计算机思维” —— 效率达成目的&lt;/li&gt;
&lt;li&gt;AI 经常忘记上标点（别利用这一点去猜，我手动补上了）&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;总结&quot;&gt;总结&lt;/h2&gt;
&lt;p&gt;就是一个字：害怕，非常害怕&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><img src="/blog/Image/bingai-dalle.jpeg" alt="Bing 调用 DELL-E 生成结局场景"></p><p>不讲虚的，直接开始</p><p>正文在最后一个章节，爱看不看</p><p>如果你选择阅读，希望你可以猜测一下：哪部分内容由 AI 生成的？</p><p><strong>Tips: 不一定是成片的内容，全程有来有回</strong></p><h2 id="TL-DR">TL;DR</h2><ul><li>配合的版本是 Bing AI</li><li>出于这B的限制，文章除了是多次对话拼接而来，还需要应对实时更新问题</li><li>联网、实时的 ChatGPT 更令人害怕</li><li>颠覆了原本我对 NLP 原本的理解</li><li>用于文学创作还是太硬，它依然还是“计算机思维” —— 效率达成目的</li><li>AI 经常忘记上标点（别利用这一点去猜，我手动补上了）</li></ul><h2 id="总结">总结</h2><p>就是一个字：害怕，非常害怕</p><span id="more"></span><p>我用的是 Bing AI，并不是说 GPT3.5 或是 GPT4 不好，而是后者对我来说有点麻烦，不如微软爹的东西直接打开就能用，加上本来就是 Microsoft Edge 的用户，不存在专门下个浏览器</p><p>大多数情况下我们配合得还算很好的，基本上即使分成了很多个会话（我有时候会想看更多发展，会打开三个标签页同时接一样的内容），虽说生成的内容不是很喜欢，<strong>但大致思路是很接近的，甚至 AI 给我提供了一些事件和制造节奏的思路</strong></p><p>过程上真的一边写一边笑，在想这怕不是日系故事有套路，都这么写；AI 是不是先知道了「暗恋和表白」的结果所以一有机会就 A 上去；这个发展真的，我来我也这么做（x</p><p>加上我的提示语其实不多，而且这个属于创作类型的使用类型，所以很有意思</p><p>实际上在预训练时就已经把几乎「能看的所有东西」都过了一遍，知书达理，博学多才应该是「非常正常」的事，<strong>直到我看到它去搜索</strong>了「日本高中毕业」、「薰衣草的寓意」等等我们在续写过程中出现的一些关键词，并像原本聊天问答一样经过理解之后<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，这时<strong>不是对所有搜索到的资料进行一个总结，而是继续代入回「小说」这个语境再继续续写工作</strong>，并且它依然能把它续写的相关内容画上虚线。我看着对话底下的「了解详细信息」，真的令人感到害怕。</p><p><img src="/blog/Image/bingai-1.png" alt="Bing AI 搜索剧情发展所需信息"><br><img src="/blog/Image/bingai-2.png" alt="Bing AI 根据信息续写"><br><img src="/blog/Image/bingai-3.png" alt="Bing AI 信息来源"></p><p>总的来说，我非常喜欢这次尝试结果，因为不管是剧情发展，还是人物性格，人物关系，我觉得 AI 都大致上是真的了解到的</p><p>只不过措辞和文字相对真正的作家可能显得稚嫩不成熟，加上我从来不看网文小说…</p><p>再挖个坑？因为这个小说的人物设计、背景、以及一些东西的含义我是真的设计过的，如果凑合的话，要不真的写一部正经的？这波自己写</p><h2 id="正文">正文</h2><p>叠甲：由于已经记不清到底打开了多少个对话才有这些内容，为了让每个对话（虽然上限是20条，但大多数都是到12 13就因为你用过就会懂的原因 AI 直接跳出）之间联系比较自然，衔接的部分一般都是我自己补上去的，但有时候太跳脱了，我也只是当做测试不会花太多时间，文案会显得很粗糙。<s>当然你也可能看不出衔接。</s></p><p>并且我会尽量给这些内容打个小节？也许它并不合适</p><blockquote><p>PROMPT:<br>我们现在开始故事接龙。接下来我会简单介绍一些背景和信息点：“女主会按照风铃草来设计，包括不限于性格，形象，名字等等。男主人公是一个非常普通的高中生，其他部分都交给你设计包括男主姓名。这是一个日系校园恋爱故事，故事发生在日本高中的毕业季，女主是喜欢一个同班的男同学也就是男主人公，一直暗恋不敢表白。最后在毕业那天，女主已经在想放弃和好好跟高中的生活告别了，但在离开校园大门前，发现男主正拿着一束风铃草在校门口等她。” 你可以搜索各种你认为需要的公开的资料。如果你准备好了就回答准备好了。我先写，你来续写。</p></blockquote><h3 id="1">1</h3><p>家里的院子里有一片风铃草，那是我妈妈种的。她说过，风铃草有着迷人的优点，并希望我能像风铃草一样。但她始终没有告诉我那是什么。</p><p>又是一个清晨，阳光穿过厚厚的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。这是我的同班同学，我们从小学就一直是同学，也是无话不说的闺蜜。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你从来不把发带直接扎在头发上，而是做成像边夹一样别在头上呢！”</p><p>“嗯，因为我觉得这样更有特色一点吧，而且我喜欢浅蓝色，就像风铃草一样”我笑着回答。</p><p>“风铃草？话说你家门口的那片植物是不是就是风铃草？”薰突然像是一个问题孩子，“风铃草是不是还有一个名字叫忘忧草？”</p><p>“忘……忧……草”我心里不断地想着这个词。是啊，我应该怎么面对我的忧愁呢……</p><p>我很在意一个人，他是我的同班同学，名叫悠太，是一个很普通的男生。他没有什么特别出众的地方，也不是什么学霸或者校草。但他看起来总是很安静，很专注，很有思想。他喜欢看书，喜欢音乐，喜欢观察周围的事物。他的眼神总是很深邃，很温柔，很有魅力……</p><p>“你是不是又在想那个男生了？你看你又是这样，突然魂就不知道飞到哪儿去了！”</p><p>我突然如惊醒一般，连忙转头看了一眼薰，她的五官都快以鼻子为中心挤成一团了，我感受到了薰涌上来满满的怨念。</p><p>“我真的很不明白你为什么对他这么在意！”薰越想越气，“他对所有人都爱理不理，这么多年也没见他参加过什么活动。他甚至会因为别人去打扰他而发脾气！”</p><p>“你快别这么说。”我拉了拉薰的衣角。</p><p>只听到薰话音刚落，薰的脸色又变得非常的甜美阳光，“你看那个连，长得好帅，不仅成绩很好，琴棋书画都很擅长。还有还有！身上总有一股迷人的，每天不重样的清香。”</p><p>我就这么看着薰光滑而圆润的脸上，又从一脸花痴相进行了一次一百八十度的渐变，“而且人家还很关心你！他对你多好啊！那么多喜欢他的女孩子他从来都不看一眼！我真的好羡慕你！噢~你是不是在吊着人家！你要是不喜欢人家能不能直接说！你不喜欢有的是人喜欢！”</p><p>“薰，你别说了，我真的不喜欢连。”我无奈地说道，“他虽然很优秀，很帅，很有才华，但是他不是我的类型。我对他没有任何感觉，也不想吊着他。”</p><p>“那你为什么不拒绝他呢？”薰不解地问道，“他已经向你表白了好几次了，你每次都说要考虑一下，你这样不是在耽误人家吗？”</p><p>“好了我们先不要聊这个话题了！”我们就这样走着走着，不知不觉到了校门口，“明天就是毕业典礼了，你有想过毕业以后的事情吗？”</p><p>“我还没有想过哎，你想过了吗？能不能告诉我你的计划啊铃酱~”</p><h3 id="2">2</h3><p>“我啊，我——”</p><p>“钟同学——”啊，这个声音，我跟薰回头一看，是连。</p><p>“早上好，钟同学，山本同学。”</p><p>“早上好连同学。”我下意识地瞟了一眼薰，果然她整个人都已经迷糊了。</p><p>“钟同学，你今天的发夹真可爱，很适合你呢。”</p><p>“谢谢”，我迅速回避掉他的眼神，心想：求求你能不能不要再在意我啊……我要怎么逃走啊……</p><p>“钟同学，我能跟你说一句话吗？”连突然说道，“其实我有一件事情想跟你说，很重要的事情。”</p><p>“什么事情？”我紧张地问道，“你说吧。”我隐隐约约感觉到，他又会说……</p><p>“其实……”连犹豫了一下，“其实我一直很喜欢你，我想跟你在一起。”</p><p>“啊……”我惊讶地看着他，不知道该怎么回答。</p><p>“钟同学，你不用马上回答我，你可以考虑一下。”连温柔地说道，“但是请你不要拒绝我，给我一个机会吧。”</p><p>“我们要快点去教室了！马上就开始上课了！”我给薰使了一个眼色。但薰好像没有看到，她一直在盯着连看。</p><p>“薰！！！”我大喊了一声，“马上上课了！！”</p><p>“啊…啊！我们要先去上课了！”薰依然还是眼巴巴的盯着连边看边说道，“不好意思啊，铃酱她总是这样……”</p><p>“快走啦！”，我拉着薰就跑了起来，往楼里奔去。</p><p>“等等，钟同学！”连追了上来，“你还没有回答我呢！”</p><p>“对不起，连同学，我现在不能回答你。”我说道，“我还有很多事情要考虑，我需要一些时间。”紧接着我拉着薰头也不回地往前跑。</p><p>好像已经甩开了，我心里这么想到。于是我们渐渐放慢脚步朝着自己的教室走去。</p><p>“铃兰，你怎么能这样呢？”薰责备我说，“你不是说你不喜欢他吗？怎么每次都这样！”</p><p>“可是……”我无奈地说，“可是他对我这么好，我真的又不忍心拒绝他。”</p><p>“那你就这样拖着他吗？”薰皱着眉头说，“你知道吗，你这样做对你自己也不好。”</p><p>“那我们就别再说这个了。”我打断了她，“我们还是聊回毕业典礼吧。你有没有准备什么礼物给老师和同学呢？”</p><p>“嗯……”薰想了想，“其实我还没有准备呢。你呢？”</p><p>“我也没有呢。”我说道，“不过我想送一些手绘的卡片给大家，上面画上他们的头像和一些祝福的话。亲手做的礼物也许更有意义呢”</p><p>“哇，你真是太有心了！”薰感动地说道，“你这样做一定会让大家都很开心的！”</p><p>“谢谢你。”我笑了笑，“其实我也有点舍不得毕业呢。毕竟我们在这里度过了三年多的时光，有过很多难忘的回忆。”</p><p>我们就这样聊着聊着，到了教室。教室里已经有不少同学了，他们都在互相打招呼。</p><p>我不急不缓移动到自己的座位上，坐下挂好自己的书包，突然感觉好像有谁看了我一眼。</p><p>我捕捉到悠太朝我脸上射出的视线，悠太似乎也发觉到了，瞬间收回他的眼神。他坐在窗边的座位上，手里拿着一本书，看得很专注。他没有跟任何人说话，也没有收到任何礼物。他就像一个孤岛，与周围的世界隔绝。透过窗户微弱的阳光溅射在他的身上，一切都如此平静和静谧。</p><p>“真的让人很好奇啊，他到底每天都在想些什么呢？”我不禁这样想。</p><p>“你又在看他，那个奇怪的男生。”薰走过来指着悠太摇头说道，“一点毕业的气氛都没有，他不会是觉得这样很酷吧？”</p><p>“可能他不喜欢这种场合吧。”我说道，“或者他有什么心事呢。”</p><p>“心事？”薰疑惑地问道，“他有什么心事啊？”</p><p>“我也不知道。”我摇摇头，“只是猜测而已。”</p><p>“我真的无法理解，你总是向着他。他明明也没对你做过什么事。”薰漠不关心地刷着她的手机。</p><p>“铃兰！铃兰！”薰突然非常激动地缠住我的胳膊，“快看快看！我收到了一封大学的录取通知书！”</p><p>“哇！你收到了录取通知书啊！”我惊讶地说道，“你可真是个幸运儿呢！”</p><p>“嘿嘿嘿~”薰得意地笑道，“那是当然啦！”</p><p>“那你被哪所大学录取了呢？”我问她。</p><p>“嗯……”薰想了想，“其实我报了好几所大学，这封是其中一所的。你呢？”</p><p>“我啊……我还没有收到任何录取通知书呢。”</p><p>“啊，真的吗？”薰关切地问道，“你不要着急，你一定会收到的。你是一个很优秀的女孩子，你的成绩也很好。我相信你会被你想去的大学录取的。”</p><p>“谢谢你。”我说道，“你真是个好朋友。”</p><p>“不客气。”薰笑着说道，“你要加油哦。”</p><p>我跟薰拥抱了一下，感受到了她的温暖和支持。我心里有些感动也有些紧张。我不知道我的未来会怎样，我能不能实现我的梦想，我能不能遇到我的爱人。但是我知道，无论如何，我都不会忘记我的高中生活。</p><h3 id="3">3</h3><p>就在这时，铃声响了。老师进来了。他手里拿着一本书和一张纸。</p><p>“同学们，请安静一下。”老师说道，“我想跟大家做一个小测试。”</p><p>“啊？小测试？”大家都惊讶地各自议论纷纷。</p><p>“这个小测试不是为了考核你们的知识，而是为了考核你们的心情。”老师说道，“这个小测试只有一个问题，就是：你对高中生活有什么感想？”</p><p>“这个问题……”大家都沉默了。</p><p>“你们可以用任何形式来回答这个问题，可以是文字，可以是图片，可以是音乐……只要能表达出你们的真实感受就行。”老师说道，“你们可以用纸笔来做这个小测试，时间限制在十分钟内。”</p><p>“老师，这个小测试有什么意义吗？”有人问道。</p><p>“这个小测试的意义就是让你们回顾一下自己的高中生活，感受一下自己的成长和变化。”老师说道，“也让你们有一个机会跟自己和大家说再见。”</p><p>“再见……”大家都低声重复了一遍。</p><p>“好了，开始吧。”老师说道。</p><p>大家都开始做起了小测试。有的人用手机打开了相册，翻看着自己的照片。有的人用纸笔写下了自己的心情。有的人用耳机听着自己喜欢的歌曲。</p><p>我决定用画画来回答这个问题。我想通过画表达我的高中生活的点点滴滴，我的快乐和悲伤，我的收获和失去，我的梦想和现实。</p><p>于是，我开始画起了薰衣草……</p><p>我觉得它很适合我，我知道他可能不会注意到我，也不会喜欢我，但是我还是忍不住对他抱有希望。我想用薰衣草来表达我的心情，也许他能感受到我的心意。</p><p>我画出了一片薰衣草田，上面有一只小鸟在飞翔。小鸟代表着自由和梦想，它可以飞向任何地方，也可以找到自己的伴侣。我希望自己也能像小鸟一样，能够追求自己的梦想，能够遇到自己的爱人。</p><p>我画出了一座小屋，里面有一张桌子和一把椅子。小屋代表着安静和思考，它可以让人放松和沉淀。我喜欢在小屋里看书，听音乐，画画。这些都是我跟悠太有共同的爱好，也是我们之间唯一的交集。我希望自己能在小屋里跟他相遇，能够跟他分享我的想法和感受。</p><p>我画出了一颗大树，上面挂着一个风铃。大树代表着坚强和成长，它可以抵御风雨和寒冷。我在高中生活中经历了很多困难和挫折，但是我没有放弃，而是努力学习和进步。</p><p>我把这些元素都组合在一起，形成了一幅美丽的画面。这就是我的高中生活的写照，也是我的心灵的映射。我对这幅画感到很满意，也很感动。这就是我的答案。</p><p>“你画得真好啊！”薰走过来看了看我的画说道，“这是什么花啊？”</p><p>“这是薰衣草。”我说道，“你不知道吗？”</p><p>“哦，原来是薰衣草啊。”薰说道，“它跟我的名字很像呢。”</p><p>“是啊。”我说道，“你知道它的花语吗？”</p><p>“不知道呢。”薰说道，“你告诉我吧。”</p><p>“它的花语是‘等待爱情’。”我说道。</p><p>“等待爱情？”薰重复了一遍，你觉得爱情是什么呢？“</p><p>“我觉得爱情是……”我想了想，“是一种心灵的契合，是一种灵魂的共鸣，是一种无法言喻的感觉。”</p><p>“哇，你说得好深刻啊！”薰赞叹道，“你是不是已经遇到了你的爱情呢？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰奇怪地问道，“你怎么会不知道呢？”</p><p>“因为……”我低下了头，“因为我喜欢的人可能不喜欢我。”</p><p>“啊，真的吗？”薰惊讶地说道，“你喜欢的人是谁啊？”</p><p>“他是……”我刚想开口，就听到了老师的声音。</p><p>“同学们，时间到了，请大家把自己的小测试交给我。”老师说道，“我会把你们的答案都收集起来，作为我们班级的纪念。”</p><p>大家都把自己的小测试交给了老师，老师一一收下，并且给出了一些评价和感想。轮到我的时候，老师看了看我的画作，赞叹道：</p><p>“铃兰同学，你的画真是太美了！你用薰衣草来表达了你对高中生活的感想，很有创意和深意。你是一个很有才华和情感的女孩子，你的画让我感动了。”</p><p>“谢谢老师。”我说道，“您也是一个很好的老师，您教了我很多知识和技巧。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了我的画作，然后走向了悠太。悠太也拿出了他的小测试，交给了老师。</p><p>我看到老师也很惊讶地看着悠太的画作，问道：“悠太同学，你的画也很美啊！你用风铃草来表达了你对高中生活的感想，很有——”</p><p>“什么？风铃草？！”正在走神的我突然听到了老师说悠太画的是风铃草，吓了一跳，本能地发出了“啊！”的声音。</p><p>“你怎么了？铃兰同学？”老师站在悠太座位边上朝我的方向看，“你刚刚遇到什么问题了吗？”</p><p>“没……没什么。”我尴尬地说道，“我只是有点惊讶而已。”</p><p>风铃草？为什么他会画风铃草呢？难道他也喜欢风铃草吗？还是他有什么别的寓意呢？</p><p>“惊讶什么？”老师问道。</p><p>“惊讶……”我瞟了一眼悠太的画作，“惊讶悠太同学画的是风铃草。”</p><p>“为什么会惊讶呢？”老师又问道。</p><p>“因为……”我不知道该怎么回答，只好编了一个理由，“嗯……我也喜欢风铃草，我也没想到悠太画的也是花。”</p><p>“哦，是这样啊。”老师笑了笑，“那真是巧合呢。你们两个都很有眼光，风铃草是一种很美丽的花，也很有寓意。”</p><p>老师转向了悠太，“你用风铃草来表达了什么感想呢？”</p><p>“没什么，就是单纯想画风铃草。”悠太说道，语气淡淡的，一如既往的冷静回答，仿佛人类的感情与他无关。</p><p>“就是单纯想画风铃草？”老师有些不解地问道，“你就没有什么特别的感想？”</p><p>“没有。”悠太摇摇头，“可能风铃草很好看，很有意思。”</p><p>“好看，有意思？”老师又问道，“展开讲讲？”</p><p>悠太想了想，“我喜欢风铃草的颜色，浅蓝色，很清新，很舒服。我喜欢风铃草的形状，像小铃铛，很可爱，很有趣。”</p><p>“原来如此。”老师点点头，“你对风铃草的描述很细致，很生动。你是一个很有观察力和感受力的男孩子，你的画让我印象深刻。”</p><p>“谢谢老师。”悠太说道，“您也是一个很好的老师，您教了我很多知识和技能。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了悠太的画作，然后走向了其他同学。我倾听着他跟老师的对话，心里有些疑惑也有些失落。他为什么只是单纯想画风铃草呢？他没有什么特别的感想吗？他对高中生活没有什么回忆和感情吗？他对我没有什么期待和祝福吗？</p><p>为什么他会画风铃草呢？难道他真的只是单纯想画而已吗？还是他有什么别的原因呢？</p><p>我想起了他平时的样子，总是一个人坐在角落里，看着书或者听着音乐，从不跟任何人交流。他总是那么冷漠，那么孤独，那么神秘。</p><p>他到底在想些什么呢？他到底喜欢些什么呢？他到底喜欢谁呢？</p><p>我突然感觉到一阵心跳加速，一阵脸红。我赶紧低下了头，不敢再看他。</p><p>是不是我想多了，也许他真的只是想画风铃草而已吧。或许他喜欢风铃草般的女孩子，跟我没有一点关系。或许……或许他根本就——</p><p>从来没把我放在眼里。</p><p>我突然感到一阵心痛，像是被刀刺了一下。我不敢再看他的眼睛，我不敢再听他的声音，我不敢再靠近他的身边。我只想逃离这里，逃离他，逃离自己。</p><p>就这样熬过了一整个上午，而我一整个上午都没有在听课。</p><p>“铃兰，你怎么了？”薰走过来，拍了拍我的肩膀，“你脸色很不好啊。”</p><p>“没……没什么。”我勉强笑了笑，“我只是有点累而已。”</p><p>“累？”薰关切地问道，“我们休息一下，正好，我们一起吃午饭吧。”</p><p>薰把我拉了起来，我跟薰走出了教室，向着室外走去。我回头看了一眼悠太的方向，发现他正看着我。我们的目光在空中相遇，然后又迅速分开。我感觉到我的心又跳了一下，然后又沉了下去。</p><p>这就是我们之间最后的交流吗？这就是我们之间最后的告别吗？</p><p>我不知道。我也不想知道。</p><p>我只想忘掉他。忘掉他的存在，忘掉他的影子，忘掉他的画作。</p><h3 id="4">4</h3><p>“今天天气好像是有点糟糕呢……我还以为早上只是太早了云层有点厚而已呢~”我尝试着找一个话题掩盖此刻的心情。</p><p>“你反应很大啊？”薰看着我有点虚弱的表情，也不忘记嘲笑我，“你该不会以为，那个男生真的是在意你吧？怎么你还不让人家喜欢风铃草了，你也不是风铃草啊。”</p><p>是噢，总不能因为我的名字带着铃，妈妈喜欢风铃草，我就强行占有了这个世界的风铃草吧。我不断这么安慰自己。</p><p>“当然不是，”我赶紧解释，“我没有在想风铃草的事”</p><p>“没有在想风铃草的事？”薰不信地说道，“那你刚才为什么会吓得那么厉害？”</p><p>“我……”我支支吾吾地说道，“我只是觉得很巧合而已。”</p><p>“巧合？”薰反问道，“你觉得这是巧合吗？”</p><p>“嗯，是啊。”我点点头，“这不是很正常的吗？”</p><p>“我的意思是，”薰摇摇头，“他都没有为你做过什么事情，你怎么就以为人家对你有意思。”</p><p>“我也没有这么想。”我忙否认道，“我只是觉得他很有才华。”</p><p>“哦，是这样啊。”薰不以为然地说道，“那你为什么不去告诉他呢？”</p><p>“告诉他？”我吃了一惊，“你是说，告白？”</p><p>“对啊，告白。”薰说道，“你不是喜欢他吗？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰无奈地摇摇头，“铃兰，你真是太胆小了。你知道明天结束，你可能再也见不到他了吗？”</p><p>“我知道。”我低下了头，“但是，我怕。”</p><p>“你怕什么？”薰问道，“你怕被拒绝吗？”</p><p>“不……”我摇摇头，“我怕失去他。”</p><p>“失去他？”薰不解地说道，“你本来就没有拥有过，你还能失去什么？”</p><p>“我……”我咬了咬嘴唇，“我怕失去这份感情。这份对他的喜欢，对他的敬佩，对他的思念。如果我告诉他，如果他拒绝了我，或者接受了我，那么这些感情就会消失。就像风铃草一样，随风而逝。”</p><p>“铃兰……”薰轻轻地叹了口气，“你真是太傻了。你知道吗？感情不是用来藏着的，而是用来表达的。如果你真的喜欢他，就应该勇敢地告诉他。也许他也喜欢你呢？也许他也在等你呢？也许你们可以在一起呢？虽然我还是不理解为什么你对他会这么在意。”</p><p>“可是……”我还想说什么，但被薰打断了。</p><p>“没有可是。”薰说道，“铃兰，如果你再不行动，就真的会后悔一辈子的。相信我，你不会想要那样的结果的。”</p><p>“薰……”我看着她真诚的眼神，感觉到她对我的关心和鼓励，但我还是拒绝了薰。</p><p>“还有一天时间呢，让我再好好想想吧”我把头低下来，感觉内心像一场风暴，翻滚着各种矛盾和冲突……</p><p>薰看着我，无奈地摇了摇头，她知道我是个固执的人，不会轻易改变主意的。她只好放弃了劝说我，转而换了一个话题。</p><p>“对了，铃兰，你知道吗？”薰说道，“今天下午有一个画展，好像是一个社团的作品展示。”</p><p>“社团？作品展示？”我稍微把头微微侧倾表示好奇，“绘画社？”</p><p>“是呀是呀，”薰从书包里拿出了一张传单，上面写着“致我们的高中生活”，还有一幅画作的缩略图。</p><p>“去看看吗？”薰说道。我看着薰，从她的脸上看到了非常感兴趣五个大字。</p><p>“去看看？”我疑惑地问道，“去哪里看？”</p><p>“去画展啊。”薰说道，“今天下午三点到五点，在学校的美术馆。我们一起去吧。”</p><p>“快点，快点。”她催促道，“我们还有半个小时就到画展开始了。我们不能迟到。”</p><p>“等等，等等。”我挣扎着说道，“我还没准备好呢。”</p><p>“没关系，没关系。”薰说道，“有我在呢。放心吧，一切都会好的。”</p><p>她带着我跑出了教室，向美术馆的方向飞奔而去。</p><h3 id="5">5</h3><p>我们跑到了美术馆的门口，看到了一排排的人在排队进入。我们也赶紧加入了队伍，等待着进入画展。</p><p>我看了看海报，上面有一幅画作，是一群高中生在校园里欢笑着。他们有的拿着书本，有的拿着乐器，有的拿着画笔，有的拿着球拍。他们的表情都很自然，很快乐，很真实。</p><p>“这幅画是谁画的啊？”我问道，“好厉害啊。”</p><p>“不知道呢。”薰说道，“可能是绘画社的社长吧。他应该是个很有才华的人。”</p><p>“是吗？”我说道，“你对他很感兴趣吗？”</p><p>“不是啦。”薰摇摇头说道，“我只是对他的画感兴趣而已。我想看看他还画了什么。”</p><p>“哦，这样啊。”我说道，“那我们快点进去吧。”</p><p>我们终于排到了门口，进入了美术馆。里面有很多画作，都是绘画社的成员们用心创作的。每幅画都有一个标题和一个简介，介绍了画作的背景和意义。</p><p>我们一边走一边看，不时地发出惊叹和赞美。有些画作让我们回忆起了自己的高中生活，有些画作让我们感受到了别人的高中生活。每幅画都有自己的故事和情感。</p><p>“你看，你看。”薰突然拉住了我的手，指着一幅画说道，“这幅画好熟悉啊。”</p><p>画作是一幅风景画，画面上是一片风铃草田，还有一对男女的背影。男生手里拿着一束浅蓝色的风铃草，单马尾女生则把头靠在男生的肩膀上。两人看起来很恩爱，很幸福。</p><p>我下意识地看了一眼右下角，一边看一边轻声读了出来：“《风铃草之恋》，作者：藤原悠——”</p><p>我突然倒吸一口凉气，感觉后背开始一点点发凉，又像是被谁揪住了一样，接着又觉得非常的不可思议——很自然地用双手捂住了自己的嘴和鼻子。</p><p>“这是……真的……？”我的眼神反复在画布上的内容和右下角的标签之间来回移动，一遍又一遍的确认。</p><p>“这是悠太画的？”薰凑近瞧了瞧，“还真的是！真没想到他还是绘画社的成员，原来他这么有东西！”</p><p>接着薰又用手肘顶了一下我的手臂，“哎哎，你说，他画得是真好，但是他是不是只会画风铃草啊？”</p><p>“但是，”薰说道，“多美啊，多浪漫啊。这就是他对爱情的理想吧。你说，这个女孩会不会就是他喜欢的人呢？”</p><p>我死死地盯着这幅画，感觉到我的心被刺了一下。这就是他心中的风铃草之恋吗？这就是他心中的女孩吗？那么，我在他心中又是什么呢？</p><p>“喂，喂！”，薰突然摇了一下我，“姐妹你别傻愣着鸭！开麦！开麦姐妹！”</p><p>“啊……啊！”，我突然如梦惊醒，扭头看了一眼薰，“没……没什么事……画得很好……是……看起来很幸福…嗯…对……”。我低下头，仿佛在想什么事情，又什么都没想。</p><p>“铃兰，你在说什么啊？”薰摇摇头说道，“你今天怎么了？”</p><p>“没有”，我非常轻声的回答了薰的问题，但这个声音已经微小到似乎仅仅是通过骨传导传递到我的耳朵而已。</p><p>“你觉得这个女孩，会是你吗？”薰挽着我的手，头微微低下，似乎在尝试观察头发背后的我此刻的表情。</p><p>我突然猛地一抬头，“什么？我？女孩？我？”</p><p>“是啊！”薰微微靠在我的肩上，“老师给我们的那道题，他画了风铃草。现在放在眼前的这幅画，内容也是风铃草……”</p><p>“其实我总是嘴上说说，但是我能感觉到，他可能对你有意思。”薰的头突然离开了肩膀，微微地晃动了一下，又贴到了肩上，“其实我都看到好多次，他总是在不经意间偷偷看你，又突然地甩断视线……”</p><p>我听着薰的话，心里一阵乱糟糟的。我真的很喜欢悠太，但是我从来没有勇气告诉他。我只是默默地关注着他，欣赏着他的才华，羡慕着他的自信。</p><p>我以为他心里有别的女孩，也许是那些漂亮的，聪明的，活泼的女孩。我以为他和我之间，只有风铃草这一点微不足道的联系。不，他不知道我的名字跟风铃草有关系，这根本不是联系。</p><p>“你说得对。”我终于开口说道，“这幅画真的很美，很浪漫。这就是悠太对爱情的理想吧。”</p><p>“那你呢？”薰问道，“你对爱情的理想是什么？”</p><p>“我……”我犹豫了一下，“我想……和喜欢的人在一起……就好了。”</p><p>“那你想好了没有？”</p><p>“想好……想好什么？”</p><p>这时薰的头彻底离开了我的肩膀，直勾勾的盯着我，“去做你想做的事！”</p><p>“可是……”我还想说什么，但是被薰打断了。</p><p>“别可是了。”薰重复道，“你要抓住机会啊。”</p><p>“可是……”我还想说什么，但是被薰拉着就往画展的出口走去。</p><p>“我们去哪里？”我问道，“不看了吗？”</p><p>“还看什么画展啊。”薰说道，“你都不是很想继续看了，我们回去找他啊。”</p><p>“找他？”我惊讶地问道，“找他干什么？”</p><p>“找他告白啊。”薰说道，“你不是喜欢他吗？你不是想和他在一起吗？”</p><p>“我……”我瞪大了眼睛，不敢相信自己的耳朵。</p><p>“你怎么了？”薰看着我，一脸的不解。</p><p>“你……你让我去告白？”我结结巴巴地问道，“你是认真的吗？”</p><p>“当然啦。”薰说道，“这不是很正常的吗？”</p><p>“不……不正常啊。”我说道，“这太突然了啊。我怎么能去告白啊。”</p><p>“为什么不能呢？”薰问道，“你有什么顾虑吗？”</p><p>“顾虑？”我说道，“顾虑太多了啊。万一他拒绝我怎么办？万一他嘲笑我怎么办？万一他觉得我很烦怎么办？万一他已经有喜欢的人怎么办？”</p><p>“哎呀，你想太多了。”薰说道，“你要有点自信啊。你又不是没有优点，你又不是没有魅力，你又不是没有人气。你为什么要自卑呢？”</p><p>“可是……”我依然被薰再次打断。</p><p>“画展先看到这吧，我们回教室。”</p><h3 id="6">6</h3><p>我们从美术馆出来，看到天空突然下起很大的雨，我们急忙跑到一个屋檐下，躲避着雨水。雨水顺着屋檐起伏间的缝隙，成股地滚了下来，重重地砸向了地面。</p><p>“哎呀，怎么会突然下这么大的雨啊。”薰抱怨道，“我们没有带伞啊。”</p><p>“是啊。”说完便观察周围的情况，看看能不能找到一条不会淋雨的路线回到教室。</p><p>“有了！”我突然喊了出来，“我们可以先沿着这个建筑边缘走，然后再穿过这个通道，中间可能有一点点路会淋到，但应该没问题。你可以吗？”</p><p>“我可以！我们先这样吧，先回到教学楼再想想怎么回家。”薰点了点头表示同意我的建议。</p><p>“那我们先这样，跑起来！”</p><p>我们跟着我的计划，沿着建筑边缘跑去，但是雨越下越大，我们的衣服和头发都被打湿了。我看了看薰，她的脸上有些苦恼，但也有些兴奋。她的眼睛在雨中闪闪发光，像是一颗星星。</p><p>“你没事吧？”我关心地问她。</p><p>“没事，就是有点冷。”她笑了笑，“不过这样也挺有意思的，就像是冒险一样。”</p><p>“是啊，我们好像是在逃亡。”我也笑了起来，“不过我们要快点，不然会感冒的。”</p><p>“嗯。”她点点头，加快了脚步。</p><p><strong>我们终于穿过了通道，来到了教学楼前。教学楼是一座四层的建筑，外墙是白色的，窗户是蓝色的。教学楼的门口有一个大大的屋檐，可以遮挡雨水。我们跑到屋檐下，松了一口气。</strong></p><p>“太好了，我们终于到了。”我说。</p><p>“是啊，真是太幸运了。”薰说，“不过我们现在怎么办？我们都湿漉漉的。”</p><p>“对啊。”我看了看自己的头发，“不过还好，我们先回教室休息，再找找有没有什么东西可以擦干。”</p><p>我们沿着走廊向教室走过去，当我们走到门前，只见到有一个身影正从我们教室里打算出来。“看，是连，他来我们教室干什么？”薰拽了拽我并朝前指了一下。</p><p>有点被打湿的我看到连之后感到愈发的寒冷，心想：“他来干什么啊！”</p><p>“钟同学，山本同学。你们？”连看到我们之后，一脸诧异，“你们是淋雨了吗？你们没事吧？”</p><p>接着连一个箭步闪现到一个课桌前，迅速地抄起了桌子上的毛巾，朝我们走了过来。</p><p>连把毛巾掸开，接着对折了一遍。然后一手抓住毛巾，打算朝着我的头发扑过来。</p><p>我下意识地躲闪了一下，“请不要这样，我自己来，把毛巾给我就好”。连微微笑了一下，放下举过我头顶的手，并把毛巾递到我的面前，“给~”</p><p>我迅速接过毛巾，又把毛巾摊开，熟练的将毛巾包住自己的头发，稍微用力搓了一下。</p><p>“好香”，应该是包住头发的一瞬间，挤压出了原本停驻在毛巾间的空气，顺带着毛巾散发出来的淡淡的清香。我一边一边搓着自己的头发，一边重新回溯毛巾是从哪张课桌拿过来的。</p><p>“给，你也要擦一下”，我把毛巾递给了薰。薰接过毛巾，照着我的动作又重复了一遍。</p><p>“谢谢你”，我低头向着连说道，同时心里又很担心他又要“故技重施”。</p><p>“你也太贴心了叭！”薰擦完头发之后，小心翼翼的把毛巾对折一遍，又对折一遍，变成一块小方块，想要还给连，“你怎么会想到给我们准备毛巾！”</p><p>“不客气。那个”连注视着我，仿佛又要说出那句。</p><p>“不，先别”我及时打断了连，“如果你还要说‘喜欢我’之类的话，不好意思，对不起”</p><p>“好吧，你还是拒绝我了吗？”连看着有点失望。</p><p>“我不能马上回答你，不好意思”我把整个身子扭向了一边，面对着白色墙壁。</p><p>“好吧，我先走了，你们要小心，不要感冒”，说完，连离开了教室。</p><p>薰把我转了过来，刚要开口，我打断了薰。</p><p>“我知道你又要说教我了，你这次想说什么？”我摆脱了薰的手掌，缓慢向我的座位走去。</p><p>“你真的……你真的”，薰顺势将手托住自己的脸颊，“我真的……我真的……”</p><p>“行了，我明白的”，当我走到我的座位旁，正要坐下时，看到课桌靠窗的一边，倚着一把雨伞。</p><p>“这是谁的雨伞？”我把伞拿了起来看了一眼，接着我突然灵光一闪，想到了毛巾，“毛巾呢？薰，毛巾在你那吗？”</p><p>薰把毛巾递了过来，“我是真的佛啦，铃兰，你是真 NB 啊，你真该死啊！”，薰好像有点要急哭了的样子，“你要是不稀罕舔狗，能不能让他舔舔我啊！”</p><p>“你在说什么啊！！！”我冲着薰喊了一声。没想到薰竟然突然对我是这个态度，我突然感到有一丝失望，顺手把毛巾抽回来。</p><p>“人家给你送毛巾，给你准备雨伞，你却这样对人家”，薰突然就哭了起来，“我真的……我看着好心痛，连真的好可怜……可怜的汤姆猫……”</p><h3 id="7">7</h3><p>“毛巾确实是从我桌子上拿的……”，我边回忆边念念有词，“伞和毛巾，到底是谁放在我桌子上的？”</p><p>此时教室里除了我们，没有其他人。教室也非常干净，黑板被擦得一点粉笔痕迹都没有，甚至还在反光，感觉能隐约看到我们的影子。窗户也紧闭着，只能透过窗户看到灰蒙蒙的天，以及雨水努力敲打玻璃发出清脆的声音。白色的窗帘也不会摆动，一切就像时间凝固了一般。</p><p>“还能有谁！当然是连拿过来的啊！你想一下刚刚除了我们俩，还有谁！”薰冲着我又嚷了一声，接着又软了下来，嘴里小声念叨着，“多好啊……多好啊！！！”</p><p>我起身走到薰的身边抱住了薰，试图让薰冷静下来，“好了，是我不好”。</p><p>“铃兰，你怎么能这样呢？”薰再一次责备我，用了跟早上一样的话语。但这次是抽泣的。</p><p>“我不想让他产生误会。”我小声的在薰耳边说，一边用手擦拭薰眼角上的泪痕。</p><p>“我不说了，我不说了，我什么都不想说了。”薰抬起头，用力吸了一下鼻子，“如果我是你的话，就好了。”</p><p>“我们先回家吧”，我拿着伞和毛巾。心想着，先把毛巾带回去洗干净，烘干。明天再连同雨伞一起带过来，看看是谁的吧。</p><p>于是，我手里拿着毛巾，然后挽着薰的手臂，另一只手拿着雨伞，带着她离开了教室。</p><p>我们走出了教学楼，来到了校门口。雨还是没有停，但是没有刚才那么大了。我打开了雨伞，为我们遮挡着雨水。薰紧紧地挽着我的手臂，靠在我的肩膀上。我能感觉到她的呼吸和体温，让我心里一阵暖意。</p><p>我们一起走出了校门，向东边走去。路上，我们没有说话，只是默默地感受着彼此的存在。我不知道她在想什么，也不知道自己在想什么。我只知道，这一刻，我很幸福。</p><p>看着走了三年的小路还是坑坑洼洼，路过的街道还是这么吵吵嚷嚷……</p><p>“还有两次”</p><p>“嗯？”薰贴着我，发出了娇贵的声音。</p><p>“我说，这条路，我们可能只会再多走两遍了。”我也靠着薰说道。</p><p>“嗯……”</p><p>我们就这样相互依着往前走，感觉走了没多久，眼帘里映入最熟悉的围墙，我到家了。</p><p>“你可以吗？薰？”我把手从薰的手臂间抽了出来，又很迅速地牵住了薰，“剩下的路，你可以自己走吗？”</p><p>“我可以的”薰伸手想接过雨伞，“你回家吧，我们明天见。”</p><p>我把伞转移给薰，自己跑回了家里。在家门口屋檐下转了个身，朝着薰挥了挥手。</p><p>“我回来了”，边脱鞋边跟家里打招呼，但好像家里也没有人。</p><p>我穿过了门厅，来到院子前。外面的风真的好大，门外的风铃草正在坚强地承受雨的洗礼，在努力的对着风向摆动自己，试图也想让自己平静下来。</p><p>雨敲打地面的声音，横风掠过的声音，以及顽强抵抗横风的风铃草，清脆的撞击声……各种声音在我的耳边，持续回响……</p><p>“风铃草，到底是什么意思？铃兰跟风铃草有没有关系？妈妈到底是想要让我知道什么？”我蹲了下来，抱住自己的腿，看着风铃草，陷入了沉思……</p><h3 id="8">8</h3><p>终于。</p><p>毕业典礼当天，还是到了。</p><p>还是像往常一样起了一个大早，像往常一样洗漱，像往常一样穿上自己的校服。</p><p>不过，这是最后一天穿校服了。</p><p>一切准备就绪，来到家门口。还是像往常一样在门口等着薰的出现。</p><p>阳光穿过薄薄的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。</p><p>等到薰走到身边，我马上挽住薰的手臂。今天不管怎样，我都想这样走去学校。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你今天，竟然扎在头发上了！”</p><p>“单马尾的你，好可爱啊！！”，薰一边走一边用脸蹭着我的肩膀。</p><p>我们还是这么互相依着，踏着路面被风雨打下来的樱花，继续往前走。</p><p>“真不敢相信，我们就要毕业了。”薰叹了口气，“我们可能就此分开了，你会不会想我呢？”</p><p>“当然会啊。”我紧紧地挽着薰的手臂，“你是我最好的朋友，我怎么会不想你呢？我们以后还可以保持联系啊，还可以见面啊，还可以一起玩啊。”</p><p>“是啊，是啊。”薰点点头，“我们一定要保持联系，一定要见面，一定要一起玩。我们永远都是最好的朋友。”</p><p>“对啊，对啊。”我附和着说，“我们永远都是最好的朋友。”</p><p>我们就这样走着走着，不知不觉到了校门口。今天的校门口格外热闹，很多同学都提前到了学校，有的拿着相机拍照留念，有的拿着卡片写下祝福语，有的拿着花束准备送给喜欢的人。</p><p>“毕业典礼马上就开始了，我们先去体育馆吧。”我拉着薰，穿过人群，朝着体育馆走去。</p><p>我们穿着校服，戴着毕业帽，坐在体育馆的座位上。台上是校长和老师们，他们正在发表着毕业致辞，祝贺我们的成绩，鼓励我们的未来。台下是我们的同学们，他们有的在认真地听着，有的在偷偷地聊着，有的在悄悄地哭着。我看了看身边的薰，她也看了看我。我们都没有说话，只是微微地笑了笑。我们的眼神里，有着无尽的情感。</p><p>毕业典礼结束了，我们拿到了毕业证书，和老师们握手道别。然后，我们走到了操场上，和同学们拍照留念。我们拍了班级合影，社团合影，好友合影。我们拥抱着彼此，说着感谢和祝福。我们流着眼泪，笑着说再见。</p><p>“铃酱，我不想离开校园！”薰眼巴巴的看着我，感觉又要哭出来了，“我真的好舍不得学校，舍不得这段时光，舍不得你……”</p><p>说实话，我也很留恋这三年时光，这里有我最美好的回忆，最珍贵的友情，最深刻的感情。我也不想离开这里，不想离开他们，不想离开他。</p><p>但是我不想继续再多待一秒，因为……</p><p>“薰，结束了，我们回去吧”，我看着薰，此刻的我不知为何能做到如此冷血，说出这番话。</p><p>“我不！我不要！”薰向后退了一步，用力的摇了摇头，“我真的好舍不得，我想去多拍一些照片，我想去我们第一次上课的地方，我想去音乐室，我想……”</p><p>“那我在校门口等你好吗？”我打断薰的话语，并看着薰，眼睛发出渴求的信号，心里一直想着，千万要接收到并能理解。</p><p>“好…好吧……”薰不舍地说道，“那你要等我噢！无论如何要等我噢！！！”，接着薰回头，一头扎进楼里。渐渐的，看不到人影。</p><p>我也回头，朝着校门口走去。“我就站在门口等着薰回来吧”，边走边这么想着。</p><p>当我走出大门，看到写着学校名字的铭牌前站着一个人。</p><p>“是悠太！他怎么站在这里！”我突然感觉自己的心率正在飞快上升，又快一点，再快一点……</p><p>悠太笔直地站在校门口，仿佛在等着谁。</p><p>“那是什么！”我看到了悠太，背在身后的手上，似乎拿着什么东西。</p><p>“风……风铃草！？”我突然感到一丝窒息感，“为什么？他在这里干什么？他在等他喜欢的人出现吗？”</p><p>悠太好像看到了我，笔直地朝我走了过来。</p><p>“怎么办怎么办怎么办怎么办怎么办怎么办怎么办”我不知道自己该干什么，但是他正在一步步逼近，我应该怎么办，我束手无策。</p><p>“钟铃兰……”，悠太开口了。</p><p>“啊，啊！”我抬头看了一眼悠太，“你也，你也太失礼了吧藤原同学！你怎么能直接叫人家的姓名！”</p><p>“对不起，你在等人？”</p><p>“嗯……我在等薰。”我说。</p><p>“薰？”他有些惊讶，“她还没走吗？”</p><p>“她还想去看看学校。”我说。</p><p>“哦，这样啊。”他说，“那你们……你们要一起回家吗？”</p><p>“是的。”我说，“我答应了薰，我们要一起走回家，最后一次。”</p><p>“你……”他欲言又止，似乎有什么话想要说，又不敢说出来。</p><p>“我什么？”我问。</p><p>“你……你喜欢我吗？”</p><p>他终于说出了那句话。</p><p>“我……我……”我感觉到我的脸正在变得越来越热，我不知道该怎么回答。我下意识地很想用手扇扇自己的脸散热，但我不敢。我的心里有千言万语，却说不出一个字。</p><p>“对不起，我向你道歉。是我冒犯了。”悠太低下头，扭捏了一下，“那个……嗯……”</p><p>悠太把双手从后面移向了前面，双手捧着一束花。是浅蓝色的……是风铃草。</p><p>“我猜你有所疑惑”，悠太解释道，“你想说，现在根本没有风铃草。是的，现在确实还不到风铃草的花期。”</p><p>我的大脑一片空白，我不知道他想干什么。</p><p>“其实我一直在偷偷喜欢着你，但是我又很害怕。我知道，我在别人眼里，是一个没有朋友的怪人，所以我怕。”悠太换了个姿势，继续说道。</p><p>“我一直想表达我的心意，但是如果被拒绝了，这些感情就会消失。就像风铃草一样，随风而逝……”</p><p>“可是，如果毕业了我都不能说出我想说的话，我可能会一直后悔下去，后悔一生……所以我给自己一个期限，也在逼迫自己，不管怎样，即使毕业了，我也要在毕业当天，说出我的想法。你真的很好……”</p><p>悠太突然牵扯住我的眼神，我好想躲开，但又忍不住建立起联系。</p><p>“你很温柔，你对其他同学非常好，你也总是先想着别人……你很勤奋，我经常看到你在那家面包店打工，你在前台对着客人的甜美的微笑，让我内心感到治愈……你很坚强，体育课的长跑项目，你不小心摔倒了，还坚持站起来，走着也要走完全程……”</p><p>“我真的，我只能默默为你做点事情，虽然你也许永远都不会知道，那些是我做的。”</p><p>“这么说！！！”我突然恍然大悟，眼睛里突然有些温热，“不会是！昨天毛巾和雨伞？！还有之前的那些—— 我以为——”</p><p>“其实还有一些，”悠太的突然脸也红了起来，“总之，当你需要的时候，我就会在。”</p><p>“好吧，就到这里吧。这个送给你”，悠太双手捧着风铃草，递到我的面前。</p><p>我接过了风铃草，刚想开口。</p><p>“以后我们应该还会再相见吧，如果可以的话。祝福你，祝你在大学生涯里继续追逐你的梦想。”，说完，悠太转过身，准备离开。</p><p>“藤……悠太！”我叫住了他。</p><p>悠太回头看了一眼，微微一笑，“还有什么事吗？”</p><p>“那个……”我犹豫了一下，不知道该怎么说，“对了，如果毛巾是你的……”</p><p>我赶紧放下包，找到那条白色的毛巾。它已经失去了原本的味道，现在跟我衣服的味道一模一样。</p><p>我拿着毛巾追了上去，递给悠太。“这是你的毛巾，我希望你能收下。”</p><p>悠太微微一笑，收下了毛巾，并礼貌性地点了下头，然后回头想继续走。</p><p>“还有！！”我再一次叫住了悠太。</p><p>“还有什么事吗？”</p><p>“还有……”我把花束换到了自己的左手，并举起了自己的右手，向前伸去，手背向上，手指尖向下压低了15度……</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>看了一个 b站 视频，一个知乎回答，还有一个不知道是什么打不开 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E6%B2%BF%E6%8A%80%E6%9C%AF/">前沿技术</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/ChatGPT/">ChatGPT</category>
      
      <category domain="https://colmugx.github.io/blog/tags/AI/">AI</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/04/02/chatgpt-novel/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>重新学习 JavaScript</title>
      <link>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</link>
      <guid>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</guid>
      <pubDate>Tue, 14 Feb 2023 12:13:14 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;孔子曾说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“温故而知新，可以为师矣”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Confucius 曾经也说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？&lt;/p&gt;
&lt;p&gt;想一想，从 16 年到现在一直用 &lt;code&gt;TypeScript&lt;/code&gt;，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且，孔子还说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知之者不如好之者，好之者不如乐之者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我决定邀请各位，请让你&lt;strong&gt;身边&lt;/strong&gt;的人一起学&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）</p></blockquote><p>孔子曾说：</p><blockquote><p>“温故而知新，可以为师矣”</p></blockquote><p>Confucius 曾经也说过：</p><blockquote><p>“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”</p></blockquote><p>意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？</p><p>想一想，从 16 年到现在一直用 <code>TypeScript</code>，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 <code>JavaScript</code></p><p>并且，孔子还说过：</p><blockquote><p>知之者不如好之者，好之者不如乐之者</p></blockquote><p>所以我决定邀请各位，请让你<strong>身边</strong>的人一起学</p><span id="more"></span><h2 id="环境">环境</h2><p>虽然直接使用浏览器方便一些，但我们现在应该本地都有一个 <code>node</code>，这可能对我们来说更为方便。顺便的可以温习一遍简单的 <code>File IO</code>，毕竟这是几乎所有语言入门都需要接触的部分</p><p>本文环境配置如下：</p><ul><li>OS：最新最时尚最卡的 MacOS Ventura</li><li>node: v16.13.2</li></ul><h2 id="基本类型">基本类型</h2><p><code>JavaScript</code> 是一款“函数式” <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 解释型脚本语言，所以这部分我们可以使用 Node REPL</p><p>打开终端，输入这个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node</code></pre><p>首先是基本类型：<code>JavaScript</code> 有<strong>三种</strong>基本类型：<code>string</code>, <code>number</code>, <code>boolean</code></p><p><code>string</code> 叫字符串，如果有其他编译型语言经验的话可能一时会觉得奇怪，但在 <code>JavaScript</code> 没那么讲究，字符串就是基础类型</p><p>字符串由一对引号包起来，也没那么多讲究 —— 单引号双引号都可以</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &#39;I love you&#39;&#39;I love you&#39;&gt; &quot;I love you, too&quot;&#39;I love you, too&#39;</code></pre><p>如果你的字符串出现了必要的单引号（例如 do not 的缩写），这时为了避免歧义，应该用一种引号（双引号）来作为语法识别，这样字符串内就可以使用另一对引号（单引号）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &quot;I don&#39;t hate you&quot;&quot;I don&#39;t hate you&quot;</code></pre><p><code>number</code> 叫 number，数字，同样也没那么多讲究 —— 不分 32 位 64 位，不分整浮点，甚至双精，甚至 <code>decimal</code></p><p>配合一些基本的操作符（operators），我们可以把 REPL 作为计算器使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 1+12&gt; 1*11</code></pre><p>计算机的世界，计算没有大括号（{}），没有中括号（[]），只用小括号表示优先级，嵌套越深则越优先。举个例子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 4 * (40 - (2 - 12) + 40 * 2)520</code></pre><p>这个时候你再试试除以 0。不过我们小学都学过，除法里是不能除以 0 的。但是学编程，就是要敢猜敢试。放心，不会起火</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 520 &#x2F; 0Infinity</code></pre><p>看，尝试得到了新的理解。这个式子也许对你还有另一种含义：<strong>爱与无限之间，只有一个「无条件」</strong></p><p><code>boolean</code> 指布尔值，指一对真实反义词，例如对和错，真和假，0和1。通常用在逻辑分支</p><p>计算机是严格的，对就是对的，错就是错的。<strong>但你们之间，没有绝对对错</strong></p><p>懂行的人别急，确实还有两种：<code>undefined</code> 和 <code>null</code>，它们一般情况下指「没有」，但他们严格来说不是一个意思：<code>null</code> 指这个值是空的，但本身也是一个值；<code>undefined</code> 是真的没有，且未知</p><p>就像你现在问你身旁的人问你今天有没有想TA，你回答 “没有”。虽说可能真的没想你，但其实心里还有你</p><p><strong>而有些人想都没得想！</strong></p><h2 id="函数">函数</h2><p>在复习函数之前先随便复习一下定义变量</p><p>严格 ES6 之前我们只会用 <code>var</code>，但如今我们都默认有两种定义方式：<code>var</code>, <code>let</code>，还有一种定量定义方式：<code>const</code></p><p>变量指定义之后，值还能改；定量指定义之后，值无法修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var lovedGame &#x3D; &#39;League of Legends&#39;lovedGame &#x3D; &#39;JX Online 3&#39; &#x2F;&#x2F; 世界上最好的 MMORPLGconst lovedOne &#x3D; &#39;You&#39;lovedOne &#x3D; &#39;Her&#39;&#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</code></pre><p>严格讲，<code>var</code> 和 <code>let</code> 有一点区别，<code>let</code> 有声明使用顺序（死区）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和作用域限制，换句话说更“安全”，所以现在对于新手来说，无论如何优先使用 <code>let</code></p><p>接下来到函数，一般声明一个函数会有两种方式，一种是正常的函数声明，一种是基于语言特性的声明</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1.function fn() &#123;&#125;&#x2F;&#x2F; 2.const fn &#x3D; () &#x3D;&gt; &#123;&#125;</code></pre><p>第二种其实就是一种「把函数也当做一个变量/定量」的思路，具体区别不展开<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>调用一个函数很简单</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn() &#x2F;&#x2F; 函数有参数就照着传</code></pre><p>Ok，小节实践，尝试以下函数并调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function calc(n) &#123;  return ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n&#125;&#x2F;&#x2F; 也可以这么写，是不是更帅了const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n</code></pre><p>（可以在 REPL 运行）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * nundefined</code></pre><p>REPL 是这样的，输入的下一行永远是返回值。接下来输入调用看看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; calc(1)520.1314&gt; calc(51)520.1314&gt; calc(564)520.1314</code></pre><p>你们也是这么简单纯粹吧 —— <strong>不要总问是不是变丑了，不管你变成怎样，都会一直爱你</strong></p><h2 id="实践">实践</h2><p>接下来就不用 REPL 了，因为接下来想整 <code>Network</code> 和 <code>File IO</code>。纯 <code>JavaScript</code> 这个语言是不带 IO 实现的</p><p>这一次就随便练一下写文件好了，我们的目的是：获取一个网络上的资源，并写下来</p><p>首先创建一个文件，就叫 <code>love.js</code>，随便放在你能找到的地方</p><p>先定义一些变量，照着复制就完事了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fileName &#x3D; &#39;love.txt&#39;</code></pre><p>接下来是引入一个<code>fs</code>包</p><p>由于现在已经是 <code>import/export</code> stable 的时代，所以包引用哪种都可以</p><p>但如果使用 <code>module</code> 模式的话需要将 <code>package.json</code> 的类型更改为 <code>module</code></p><p>我们直接执行，也不引入 npm 概念，所以我们这里用 <code>CommonJS</code></p><p>在最顶上（<code>fileName</code> 的上方）写入</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 文件系统const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 路径模块（用于系统各种跟路径相关的工具）const path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 网络const http &#x3D; require(&#39;https&#39;)</code></pre><p>接着我们在最开始写的变量（<code>fileName</code>）下面新增一行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 将要保存文件的路径（自动拼接绝对路径）const currentDir &#x3D; path.resolve(__dirname, fileName)</code></pre><p>然后是网络请求，我们一般都会封装成一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  http.get(    &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,    res &#x3D;&gt; &#123;      let data &#x3D; [];      res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;        data.push(chunk);      &#125;);      res.on(&#39;end&#39;, () &#x3D;&gt; &#123;        return data.toString()      &#125;);    &#125;)&#125;</code></pre><p>最后一行写上文件写入就行啦（注：这个示例跳过错误边界）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request())</code></pre><p>接下来在终端运行它吧！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node .&#x2F;love.js</code></pre><p>然后报错了！</p><p>这个时候我们应该学会看错误，这也是编程的基础。<strong>有错就说明清楚，然后调整，这样才能和谐相处</strong></p><blockquote><p>The “data” argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined</p></blockquote><p>这里说的是获取到一个 <code>undefined</code>，这个是不支持写入的</p><p>Actually，我们会给一个未知变量做边界控制，这里简单的直接短路吧<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request() || &#39;&#39;)</code></pre><p>这个时候不报错了，我们去看一下这个目录下生成的 <code>love.txt</code> 文件吧！</p><p>当我们兴奋地打开之后发现，<strong>这是一个空文件</strong></p><p>千万不要想着「我的努力我的付出，得不到回应」</p><p>不要灰心，学习编程的过程就是不断发现问题，不断解决问题。<strong>感情也是如此</strong></p><p>但我们要的不是对「你错在哪儿了？」进行一个精准的回答，而是 <strong>code review</strong></p><p>通过 review 我们会发现，<code>request</code> 写错了 —— 异步函数在这里不能直接获取返回值</p><blockquote><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p></blockquote><p>而网络对于一个 node 程序来说，就是一个异步工作</p><p>发现问题，开始解决问题</p><p>对于异步工作，我们总会很习惯的使用 <code>Promise</code> 来解决「回调嵌套」问题，使得代码看起来「同步」，而且可以非常直觉的处理「返回值」。换句话说，就是把整个函数的调用都放进了异步队列</p><blockquote><p>Promise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象</p></blockquote><p>所以，对 request 进行修改吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  return new Promise(resolve &#x3D;&gt; &#123;     http.get(      &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,      res &#x3D;&gt; &#123;        let data &#x3D; [];        res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;          data.push(chunk.toString())        &#125;);        res.on(&#39;end&#39;, () &#x3D;&gt; &#123;          &#x2F;&#x2F; 文件里有被转义的换行符，这里转回来          resolve(data.toString().replace(&#x2F;\\n&#x2F;g, &#39;\n&#39;))        &#125;);      &#125;)  &#125;)&#125;</code></pre><p>同时，「文件写入」语句也要做相应的修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, await request() || &#39;&#39;)</code></pre><p>这个时候再执行一遍！同样没有报错</p><p>但这一次不同了，当我们再一次打开 <code>love.txt</code> 文件时，我们会看到</p><p><img src="/blog/Image/heart.webp" alt="heart"></p><p>所以说，爱有时候也应该像这样：<strong>长久的爱与互相理解，建立在承诺(promise)和等待(await)</strong></p><p>我们已经约好了一直走下去的呀，等一会又怎样嘛</p><p>END -</p><p>（其实如果你有留意到这篇文章分类是在「曲苑杂坛」下，或许早就知道了）</p><h2 id="Links-2">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266495749/answer/309719982">如何用数学的方法表白? - 知乎</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">异步 JavaScript 简介</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises">如何使用 Promise</a></li><li>本博客</li></ul><p>真是温故知新啊，看看这个引用区 ↓</p><p>全都是年轻不懂事的自己，瞎几把写</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>JavaScript 可以是函数式语言，但是极端还是存在争议，这里过分严谨一些 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我今天给 let 安排了 · Colmugx 's Blog</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我就写个方法，这么麻烦？ · Colmugx 's Blog</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>剧本味也太重了草，事已至此只能做一个违背祖宗的决定了 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>田旗插在苹果上但没插好 —— MAUI + MusicKit</title>
      <link>https://colmugx.github.io/blog/2023/02/07/maui-musickit/</link>
      <guid>https://colmugx.github.io/blog/2023/02/07/maui-musickit/</guid>
      <pubDate>Tue, 07 Feb 2023 15:14:05 GMT</pubDate>
      
      <description>&lt;p&gt;众所不周知，在大概 3 4 年前曾经有这么一个项目叫 &lt;code&gt;sona&lt;/code&gt;，这是一个音乐播放器，&lt;code&gt;react native&lt;/code&gt;，连着网抑云。大概长这样&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/sona-v1.png&quot; alt=&quot;sona&quot;&gt;&lt;/p&gt;
&lt;p&gt;过了这么久，我早就不网抑云，也以现在的眼光再看这个 UI 未免有些稚气，还有点费电资源 —— 整的什么垃圾&lt;/p&gt;
&lt;p&gt;正好，关注了一年多的 &lt;code&gt;MAUI&lt;/code&gt;，纯纯在 Build 看着宣布，然后 GitHub 开库，进 preview，到现在 stable。.NET 都从 6 preview 一直到 7…&lt;/p&gt;
&lt;p&gt;所以先来搂一眼，正好也想复活这个产品，并且不优先解决网抑云，而是解决 Apple Music 和 Spotify，还有 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;http://Last.fm&quot;&gt;Last.fm&lt;/a&gt;。再决定是改用 maui 重构还是继续用 RN&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-7&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;C# 很香，但遗传了 Xamarin 的臭&lt;/li&gt;
&lt;li&gt;安卓 SDK 两个包，噶了一个&lt;/li&gt;
&lt;li&gt;平台能力最好还是用平台原生语言&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;目前的 MAUI，狗都不用&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>众所不周知，在大概 3 4 年前曾经有这么一个项目叫 <code>sona</code>，这是一个音乐播放器，<code>react native</code>，连着网抑云。大概长这样</p><p><img src="/blog/Image/sona-v1.png" alt="sona"></p><p>过了这么久，我早就不网抑云，也以现在的眼光再看这个 UI 未免有些稚气，还有点费电资源 —— 整的什么垃圾</p><p>正好，关注了一年多的 <code>MAUI</code>，纯纯在 Build 看着宣布，然后 GitHub 开库，进 preview，到现在 stable。.NET 都从 6 preview 一直到 7…</p><p>所以先来搂一眼，正好也想复活这个产品，并且不优先解决网抑云，而是解决 Apple Music 和 Spotify，还有 <a target="_blank" rel="noopener" href="http://Last.fm">Last.fm</a>。再决定是改用 maui 重构还是继续用 RN</p><h2 id="TL-DR-7">TL;DR</h2><ul><li>C# 很香，但遗传了 Xamarin 的臭</li><li>安卓 SDK 两个包，噶了一个</li><li>平台能力最好还是用平台原生语言</li><li><strong>目前的 MAUI，狗都不用</strong></li></ul><span id="more"></span><h2 id="MAUI">MAUI</h2><p>一句话：MAUI 是另一个 React Native 但 C#，<strong>不是 Flutter</strong></p><p>MAUI 前面有 <code>Xamarin</code>（分平台的不是 <code>Xamarin.Forms</code>），服就服在<strong>微软能把各个平台的 API 都转一份</strong>，这样所有代码都使用 C# 编写，以便享受这个极其变态的编译器。当你创建一个 mac 的 Xamarin 应用，你会发现除了语法是 C#，无论结构还是文件组织都与直接用 XCode 创建出来的项目不能说有点相似，只能说完全一致</p><p>高情商：令人钦佩的软件工程能力；低情商：吃饱了撑着</p><p>所以作为后继者，MAUI 在平台调用依然会是全 C#，不像 flutter 或者 RN 在分别平台使用 swift/kotlin。这样有好坏</p><p>好是因为全 C#，在编写平台逻辑时可以直接使用通用的 <code>interface</code>，或者是 common 写一个 <code>partial</code>，再分平台补充实现。即使在通用代码也可以用 macro 来区分平台生成代码，毕竟不用担心，编译会根据编译目标选择源代码</p><p>坏那也坏，RN 和 flutter 的方式是让平台代码完全使用平台程序，相当于写了一个原生程序，通过桥通信交换信息，这样可以保证平台逻辑是绝对的平台逻辑，《非常原生》。而反过来就是 MAUI 的缺点，谁也不知道到底这个翻译官水平如何</p><h2 id="MusicKit">MusicKit</h2><p>WWDC21 宣布了 <code>MusicKit</code>，WWDC22 宣布了<strong>其他平台</strong>的 MusicKit SDK 和 Apple Music API，至此 Apple Music 可以在其他平台集成，包括 Web</p><p>只不过，据我所知，Apple Music API 和 MusicKit Web 只有很普通的音质，没有 ALAC，没有 Dolby Atmos，其实后者没有应该不奇怪</p><h2 id="Combine">Combine</h2><p>按照平台分，方案如下：</p><ul><li>iOS/iPadOS：系统带着了，直接写，可以参考 <a target="_blank" rel="noopener" href="https://github.com/xamarin/ios-samples/tree/main/ios11/MusicKitSample">Xamarin.iOS 的示例</a></li><li>Android: 使用官方 SDK，一共两个 aar</li><li>其他：只能封装 Apple Music API</li></ul><p>这个项目在 RN 的时候也仅考虑 iOS 和 Android。这次会考虑新增 iPad 和桌面端，但无所谓</p><h3 id="Create-Library-s">Create Library(s)</h3><p>如果按照 React Native 的习惯，可能会创建一个插件项目，接着分别在对应位置做平台实现。但，<code>Xamarin</code> 似乎不是这么做的</p><p>首先需要创建两个 Binding 项目：<code>Android Bindings Library</code> 和 <code>iOS Bindings Library</code></p><p>毕竟只是概念验证，所以这次不实现 iOS，先试试 <code>aar</code> 绑定。这里可以参考微软文档 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></p><p>在安卓，Apple Music 提供了两个 <code>arr</code>：</p><ul><li>mediaplayback：Apple Music 部分，用于获取专辑，音乐信息等</li><li>musickitauth: MusicKit 的验证部分（例如直接使用本地的 Apple Music 进行授权，类似通过 QQ 登录）</li></ul><p>一个一个来</p><h3 id="Droid-MusicKit-mediaplayback">Droid.MusicKit - mediaplayback</h3><p>（似乎 Xamarin 的插件大火都是这么命名的）</p><p>先处理 mediaplayback，按照文档，创建项目之后，把 <code>aar</code> 直接拖进项目，并设置「生成操作设置」</p><blockquote><ol start="5"><li>将 textanalyzer.aar 的生成操作设置为 LibraryProjectZip</li></ol></blockquote><p>Xamarin 虽然是这么设置的，但是在 Visual Studio 2022 <strong>已经没有这个选项了</strong>，取而代之的是 <code>AndroidLibrary</code></p><p>然后就可以开始生成了，<strong>要不怎么说微软 nb 呢</strong> —— .NET 会解析 <code>arr</code> 或者 <code>jar</code> ，将所有签名或者代码结构生成出来，并以类为单位生成一个个 C# 文件，作为 header file 使用</p><p>但，刚说什么来着？</p><blockquote><p>谁也不知道到底这个翻译官水平如何</p></blockquote><p>不出意外的话<strong>马上又要出意外了</strong></p><h3 id="寄！">寄！</h3><p><img src="/blog/Image/maui-musickit-error.png" alt="error"></p><p>mediaplayback 关于音乐部分是原生库（.so），应该是 JNI 部分依赖了 <code>javacpp</code>，而 <code>javacpp</code> 在翻译成 C# 的时候出问题了。尝试解决一下但无法解决，想抄作业全网搜索没有一个相似案例可以抄作业。如果直接用 kotlin 我会受这苦？</p><p>没办法只能退而求其次 —— 本地授权完获取 token 之后，剩下的走 Apple Music API。但即使可以的话，音质可能是收音机水平</p><h3 id="Droid-MusicKit-musickitauth">Droid.MusicKit - musickitauth</h3><p>跟 mediaplayback 一样，把 arr 拖进来，改成 <code>AndroidLibrary</code> 之后编译，很意外的非常顺利，只有几百个警告。<s>在老程序员的眼里，1000 个警告都是无异常</s></p><p>接着，在 MAUI 的项目中打开「引用」目录，右键这个目录添加引用，把 <code>Droid.MusicKit</code> 添加进来，再编译一遍。没有报错的话就是没有报错</p><p><strong>要不怎么说微软 nb 呢x2</strong>，在使用时，可以直接 using 包名</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">using Com.Apple.Android.Sdk.Authentication;</code></pre><p>这里采用的方式是：先在公用逻辑写一半类，接着在对应的平台实现里完成各个平台调用</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth();    &#125;&#125;</code></pre><p>接着到 android 目录，创建一个 <code>MusicKitService.cs</code></p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth()        &#123;            &#x2F;&#x2F; 当前 activity（如果有更好的方式的话欢迎告诉我）            var activity &#x3D; Microsoft.Maui.ApplicationModel.Platform.CurrentActivity;            &#x2F;&#x2F; 应用上下文（React Native 直接在 props 进来的那个）            var context &#x3D; Android.App.Application.Context;            var authenticationManager &#x3D; AuthenticationFactory.CreateAuthenticationManager(context);            var developerToken &#x3D; &quot;&quot;;            var intent &#x3D; authenticationManager                .CreateIntentBuilder(developerToken)                .SetHideStartScreen(false)                &#x2F;&#x2F; 授权页面显示的告示信息                .SetStartScreenMessage(&quot;要想听歌就赶紧授权！&quot;)                .Build();            &#x2F;&#x2F; 跳转 activity（android 原生应该很熟悉）            activity.StartActivityForResult(intent, 100);        &#125;    &#125;&#125;</code></pre><p>最后随便绑定到项目创建时的 Demo 的按钮上，不出意外的话点击按钮就能显示 Apple Music 的授权页面（跳转到 Apple Music 或者让你安装一个）</p><h2 id="总结-4">总结</h2><p>零零散散写了很久，文章周期很长。可能有上文不接下气的感觉</p><p>本来对 MAUI 寄予厚望，现在理性考虑还是不会使用</p><p>一方面是需要踩坑的地方目测得到的就有点多（如果之前没踩过 Xamarin 的话还得算上）；一方面目前社区不活跃，有点冷门的实现自己搞不定</p><p>体感上会比印象中的 React Native 好很多（新解释器和 Hermes 还没用过），但开发成本和理解成本不在一个层面</p><p>总之，看还是会看，暗中观察。用的话现在不会用（但是体感上 Xamarin 真的要比 React Native 好，很纠结…</p><h2 id="Link-2">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/samples/xamarin/ios-samples/ios11-musickitsample/">Xamarin.iOS - MusicKitSample</a></li><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></li><li><a target="_blank" rel="noopener" href="https://github.com/dotnet/maui/discussions/1340">MAUI Binding .aar library</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/C/">C#</category>
      
      <category domain="https://colmugx.github.io/blog/tags/MAUI/">MAUI</category>
      
      <category domain="https://colmugx.github.io/blog/tags/MusicKit/">MusicKit</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/02/07/maui-musickit/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>成为玩家 2022</title>
      <link>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</link>
      <guid>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</guid>
      <pubDate>Sat, 31 Dec 2022 08:51:19 GMT</pubDate>
      
      <description>&lt;p&gt;本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了&lt;/p&gt;
&lt;p&gt;边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了</p><p>边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x</p><span id="more"></span><h2 id="我想做的就是-JRPG">我想做的就是 JRPG</h2><p>今年有更多的时间花在系统学习音乐上，为什么</p><p>首先，JRPG 更强调剧情的推进，且有更强烈的 role play（相对于欧美RPG来说，代入日式RPG更需要想象），所以相对来说，JRPG 有一个更抽象的世界观。怎么交代清楚「现在身处一个怎样的环境」，<strong>除了文案旁敲侧击暗示之外，配乐起到非常关键的作用</strong></p><p>自从去年聊完《原神》之后，我发现越来越多的新游戏（所谓的二次元游戏）都开始强调配乐（这个时候我真想吐槽某个游戏吃老本的功力是真的得天独厚）。但毕竟不是谁家都是 HoYoVerse，从一开始就深入跟策划文案磨世界观，和游戏基本到开发末期再“配乐”，本质上还是有所区别</p><p>所以在游戏，音乐有一个更新的称呼：互动音乐（设计），且这是我们能叫出名的国外游戏公司的标配（比如真有你的 SE）</p><p>举个例子，最近的《宝可梦朱/紫》，四个地区分别有自己一个 theme，但每一个 theme 在步行、骑行、水边、特殊场景、战斗所使用的配器均不同，且使用的配器更适合当时的环境 —— 步行更多是一个比较纯净的钢琴，一旦上了摩托就会变成一个带 epic 的管弦，<strong>并且他们无缝衔接</strong>。这让探索旅途中，既体现了地区风格，又带给游玩者一个“更真实”的情绪</p><p>再加个例子，《八方旅人》和《异度之刃3》有一个差不多的设计</p><p>介绍下背景，《八方旅人》讲的是八个不同的角色为了实现各自不同的目标在同一片大陆展开冒险的游戏。在他们分别进 boss 战之前都有一段嘴炮用于剧情铺垫，此时配乐开始使用对应角色一个可以循环的短音乐，进战斗之后开始切为一个从这个短音乐的音阶和节奏型转换为战斗配乐的音阶和节奏型（大多是升音阶，学者中间段先接上前面的 3/4 转 6/8 一路卡到 4/4 进战斗）</p><p>也就是每个角色 boss 战之前配乐是这样的：循环段 -&gt; 过渡 -&gt; 战斗</p><p>这么做的好处同样很清晰：<strong>当你沉浸在故事时，不会因为配乐切换而打断情绪</strong>。同时游戏大多时候在嘴炮期就已经让你感觉到气愤/可怜，而在过渡段自然地滑进 battle theme 之后，玩家的情绪也已经非常自然地提到了激情的状态，巴不得直接就扬了面前这个B</p><p>而《异度之刃3》要提的是冠名怪（You Will Know Our Names-Finale-，这首也是系列第一首使用了完整的互动音乐设计的音乐</p><p>冠名怪的配乐被分成了四段：进去一段，怪进狂暴期一段（血条在火焰之后），濒死一段，<strong>收势两段</strong>。是的，收势分为以 Chain Attack 结束和普通结束。</p><p>上面描写了很多信息，那跟我有锤子关系？巧了，我想做的就是 JRPG。<strong>如果制作人都不知道自己的游戏将会是什么样，那又有谁会知道呢</strong></p><p>所以日后只要写关于游戏简评的文章，都会加上一个新章节：配乐分享</p><p>虽然但是，今年的钢琴没有任何进步。明年除了乐理要继续安排时间学习，要开始翻《配器法》</p><h2 id="好故事还要讲得好">好故事还要讲得好</h2><p>故事对于 RPG 来说非常重要，无论是美式 RPG 还是日式 RPG。关于日式和美式对于故事的区别我跟一些业内人员（世界观设计，文案）算是有过沉重的讨论，这里不谈，可以以后单独写一篇我的观点</p><p>翻看我的微信读书，发现《故事》读了 8 个月，我记得很清楚，其中第五章第六章花费了绝大多数时间。如何「科学」的写出一部能让众人娓娓而谈的小说是一件非常难做到的事情</p><p>这是写故事，好故事所需要的前置条件。再是讲故事，因为不管多好的故事，它终究暂时是在纸上。读小说吸引人的其中一点也在于画面与描写都在每个人的大脑中，每个人都有每个人想要的画面和理解，一千个读者眼中就会有一千个哈姆雷特</p><p>《故事》列举了非常多的影视作品片段作为案例用于解释故事点，实际上对于现代游戏来说…也没问题。现在能端上台面的 RPG 游戏，要求可越来越高了。除了需要成熟或独特的游戏玩法，镜头语言、场面调度等等影视手段也在不断地搬到游戏作品中去，加上这个时代出现了「虚幻5」这样的游戏引擎，越来越多不可能逐渐变成可能</p><h2 id="游戏首先要好玩">游戏首先要好玩</h2><p>今年刚好内部有一个 gamejam，抱着试一试的心态参加了。拿到主题之后，我们首先有一个世界观想法，然后开始写 GDD，开始决定类型、特点、关卡设计、<strong>音乐设计</strong>…</p><p>虽然我们最后因为其他原因没有参赛（报名了但没参赛），但在路演期间，在去试玩其他组的游戏，特别是一个后来成为冠军的游戏时，我突然悟了一个道理</p><blockquote><p>游戏首先要好玩 —— 魏皮特</p></blockquote><p>任天堂也是这样的主张，游戏设计再好，它不好玩就不是好游戏。所以<strong>从最开始我们的路线就是错的</strong> —— 浪费时间在决定是 2D 是 3D，是像素还是写实，<strong>甚至是 gamejam 没有时间考虑的音乐设计</strong>，都是无用功</p><p>也许这是 JRPG 的路线，但对于 gamejam 来说就是不适合，因为流程太长，无法在玩法上一击命中，那么短的试玩时间根本无法给试玩者留下任何印象，他们都是没有耐心的。在开发时也无故增加了许多工作量</p><p>并且我们在常规关卡设计中预计使用「华容道」，这其实已经被证明过多次这是个“偷懒”的游戏设计，如果关卡设计太难，这又会失去更多一部分玩家</p><p>总而言之，从此刻开始悟道什么是纯粹的快乐。明年再来</p><h2 id="减少后悔">减少后悔</h2><p>在复盘整年时，我发现上一节提到了 gamejam，实际上我本就有一个符合主题的游戏 —— 去年学习游戏开发时的原型《Pong Evolution》，真的本质上就完全符合主题</p><p>但为什么会想不起来？<strong>能力不够</strong>。能让我发现这个问题的依然是那个比赛的第一名，让我得到「原来主题还可以这样理解」的启发</p><p>这让我又有一个新的想法：如果我就以一个游戏原型，不断地去参加内部的比赛，每次都为了贴合主题添加新的元素，积累下来会不会非常有意思？</p><p>多做减少后悔，现在我是这样想的</p><h2 id="你做的前十个游戏都是垃圾">你做的前十个游戏都是垃圾</h2><blockquote><p>你做的前十个游戏都是垃圾，所以赶紧做掉吧 —— Jesse Schell</p></blockquote><p>上面提到的 JRPG 确实是我目前在游戏工作中最大的梦想，但我不可能一直吊死在一个项目上，停留在「完美的设计」上，即使这是我最想做好的游戏</p><p>我能理解标题的含义，初出茅庐就做出完成度非常高的作品几乎不可能。与其纸上谈兵不如先做起来。十个必然是一个虚数，其含义是不断地做，坚持做，越做越多，越来越多的错误，越来越多的总结…</p><p>作为程序员应该更能理解。刚开始写一个应用程序的时候，我肯定大多数人都还无法理解设计模式的重要性（说不定现在大多数前端也不理解，所以我还是不认为这些前端是程序员（x</p><p>Wwise 是一个商业软件，自然它也官方适配同样是商业引擎的 Unity 和 Unreal，而对于目前作为我学习伴侣的 godot 就没有这种完美适配。所以在我开始学习「交互音乐设计」同时也在思考「如何设计一个在 godot 比较方便我自己使用的声音管理类？」、「autoload 是否就可以做到？」</p><p>这大概就是「垃圾」的意义</p><p>这个游戏我至今都一直在修改和补充 GDD，但确实不会贸然开始设计程序，因为我的垃圾还没写完（x</p><h2 id="是该有所不一样了">是该有所不一样了</h2><p>去年的这个时候还在抑郁的期间，总结非常的 down</p><p>今年更多被一个压力更大的工作看上了，几乎一整年都在围绕这个工作</p><p>公司给机会了所以尝试开发一个框架。在最开始设计的时候并没有把它当框架设计，今年开始发现业务复杂度越来越「奇妙」之后，决定给它加个核心转成框架，以后讲</p><p>加上在公司活整得很散，所以今年感觉比较疲，几乎所有开坑的产品都是 idle</p><ul><li>kazusa - 游戏剧本编辑器</li><li>setsuna - 个人事项管理</li><li>ayaka - 文档生成器（CSR, SSG）</li><li>hikari - 图片预览器</li></ul><p>是该有所不一样了，原本给自己设计的知识管理工具后面推翻改成游戏剧本/文案编辑器，应该以后更多都会根据自己的需求开发工具</p><p>有太多想做的事情，甚至当前很想去开发《无限暖暖》…</p><p>就这样，今年没有那么多抱怨和抱负，大概是因为正在生病</p>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>web 「性能优化」</title>
      <link>https://colmugx.github.io/blog/2022/12/15/web-optimization/</link>
      <guid>https://colmugx.github.io/blog/2022/12/15/web-optimization/</guid>
      <pubDate>Thu, 15 Dec 2022 14:23:45 GMT</pubDate>
      
      <description>&lt;p&gt;如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢&lt;/p&gt;
&lt;p&gt;而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-10&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少加载体积&lt;/li&gt;
&lt;li&gt;懒加载/延迟加载：利用 import/export 做代码分段&lt;/li&gt;
&lt;li&gt;充分利用 http2 和 vite（开箱即用版 rollup ）&lt;/li&gt;
&lt;li&gt;非常巧合的做法，指跟 React Beta 版文档异曲同工&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢</p><p>而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方</p><h2 id="TL-DR-10">TL;DR</h2><p>总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间</p><ul><li>减少加载体积</li><li>懒加载/延迟加载：利用 import/export 做代码分段</li><li>充分利用 http2 和 vite（开箱即用版 rollup ）</li><li>非常巧合的做法，指跟 React Beta 版文档异曲同工</li></ul><span id="more"></span><h2 id="减少加载体积">减少加载体积</h2><p>前端的静态资源都在依赖网络传输，所以在第一屏尽量加载最小的资源。</p><h3 id="使用-preact">使用 preact</h3><p>这个应用在建立的时候 react 版本是 17，虽然已经有 react 18 但还不 stable。考虑一番之后觉得没有并发和批处理的 react 不够有吸引力。与此同时，preact 10 有：</p><ul><li>更小的体积，即使带着 <code>compact</code> 最后也就不到 10k，保守预估</li><li>更快的运行</li><li>react 16 兼容，沉淀组件直接用不用考虑需不需要升级或适配</li><li><code>&lt;Suspense&gt;</code> 在当时已经稳定</li></ul><p>当时的考虑是：现在用 preact 以后迁移回 react 18 问题也不是很大，所以在 react 18 没有稳定之前都可以用 preact。只不过在 <code>TypeScript</code> 环境下，写类型稍微痛苦了一些 —— 毕竟只有 <code>api</code> 是兼容的，类型可不兼容</p><h3 id="JS-加载">JS 加载</h3><p>首先是编译期处理，举个例子</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; use-noop.tsexport function useNoop() &#123;  return () &#x3D;&gt; &#123;&#125;&#125;&#x2F;&#x2F; page.tsimport &#123; useNoop &#125; from &#39;.&#x2F;use-noop&#39;</code></pre><p>首先我们的规范决定了：工具放在 <code>utils</code> 目录中且<strong>一个文件仅有一个函数，并通过 <code>export</code> 导出</strong></p><p>所以我们在最开始就解决了一个问题：尽可能拆掉首包体积，或是能自然的利用 ES Module Tree Shaking (Rollup)</p><p>接着，由于我们的目标是Chromium(cef) 76 往上，那么<strong>可以直接使用 module 的形式加载</strong>且不需要 <code>polyfill</code></p><h2 id="懒加载">懒加载</h2><p>懒加载内容分两个：</p><ul><li>原本一起打包但已经 split 的 JS 文件</li><li>从网络上加载的媒体资源（图片，视频）</li></ul><h3 id="媒体资源懒加载">媒体资源懒加载</h3><p>这里主要是图片，虽然 Chrome 已经有浏览器级别的懒加载（loading=“lazy”）</p><p>Chrome 会根据当前网络环境决定要加载多远的图片，不过 Chrome 的阈值有点捉摸不透。最后还是决定使用 <code>lazysizes</code>，并且自己控制加载距离 —— 大概就在屏幕外面多一点点</p><p>于是「不必要」的网络请求又节省下来一点</p><h3 id="JS-懒加载">JS 懒加载</h3><p>可以懒加载的 JS 不少，对于我们来说大概有几种：</p><ul><li>首屏用不到的模块，懒加载</li><li>路由，组件懒加载</li></ul><p>首屏用不到的，或者在生产中用不到的模组例如 <code>vconsole</code>、<code>hls.js</code>，在第一次不参与加载</p><p>其次，我们在架构组织上采用分层组织，即页面组件(pages)作为消费层，业务代码根据需求和 <code>feature</code> 一一关联</p><p>我愿称之为渐进式 DDD，因为就是从 DDD 的思想不断简化，再通过磨合时间和程度逐步加上去，最后都习惯并理解「为什么持续维护项目型需要 DDD」</p><p>有机会的话下一篇分享 DDD 在我们实际场景中的运用。这里推荐一个项目叫 <a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh</a>，比较可惜的是这个框架诞生于我们的决定之后</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 这里隐藏掉了部分细节- common  - component  - model  - repository  - service- [feature]  - component  - model  - repository  - service...- pages  - [page]</code></pre><p>这样，<code>page</code> 对于我们来说只是一个组合功能的载体，从而又带来一个好处：<strong>一个页面可以决定哪部分直接添加，哪部分进 lazyload</strong>。加上 <code>preact</code> 已经稳定的<code>&lt;Suspense&gt;</code>，就可以实现不那么生硬的体验效果</p><p>并且所有的 <code>page</code> 都是通过路由 lazyload 的，也就是第一次加载不会加载到别的页面的 JS（这好像已经变成了基操）</p><p>到这其实有个问题：以上关于一个页面拆分懒加载，但它们始终都要在第一屏加载，下载量可是不变的</p><p>所以还有下一步操作，大小尽量砍了，该想怎么弄快了</p><h2 id="利用-http2">利用 http2</h2><p>http2 没有改动 http 的语义，但改动了头部压缩，新增优先级排序和多路复用</p><p>在 http1.1，由于每个请求都会开一个连接，所以早期前端优化有这么一手：把静态资源分布在不同域名下，例如 <a target="_blank" rel="noopener" href="http://img1.example.com">img1.example.com</a>，<a target="_blank" rel="noopener" href="http://img2.example.com">img2.example.com</a>。其实现在观察 github 也能看到类似的做法</p><p>但因为 http2 有了二进制分帧，所以基于此实现了共享TCP，到位了再根据标记和头部重新组装报文。在这之前 http1.1 是一整块纯文本，分区用的换行符（指头部和身体）</p><p>其实以上都「不重要」，只需要知道现在同一CDN下载不阻塞了。所以在 h2 之下，<strong>静态资源可以同时加载</strong>。这就解答了上面关于页面拆分的问题</p><h2 id="异曲同工？">异曲同工？</h2><p>Dan Abramov 也就是 react 的创作者，被小右也就是 vue 的创作者大狙点头之后，对 react beta 文档爆更了 3 天。原因就是被吐槽 TTI 和 TBT 占用时间太长被 vue 的文档吊锤</p><p>所以他对 react beta 文档改动了什么？</p><ul><li>工具函数拆分，改成一文件一函数</li><li>移除过时浏览器支持，从而移除 <code>polyfill</code> 的加载（react 现在也仅支持现代浏览器）</li><li>懒加载资源，例如 <code>@codemirror/lint</code> 和 <code>eslint</code></li></ul><p>所以现代前端优化，好像基础版就这么些操作，大家都是一样的。首先尽可能压低大小（可仅参考 gzip 之后大小），然后尽可能抬高加载速度显示速度（SSR，CDN）</p><p>实在不行，发现瓶颈出现在远端数据，那就上缓存！资源慢缓存资源，数据接口慢缓存数据，什么 service worker 全给它叠起来（x</p><h2 id="Links-3">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/mq2thez/blog/blob/main/upgrade-react-etsy/preact-vs-react.md">Updating React at Etsy</a></li><li><a target="_blank" rel="noopener" href="https://web.dev/browser-level-image-lazy-loading/">Browser-level image lazy-loading for the web</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/geekculture/how-does-dan-abramov-optimize-beta-reactjs-org-after-be-complained-about-website-speed-840b02cf5ee8">How Does Dan Abramov Optimize beta.reactjs.org After Be Complained about Website Speed?</a></li><li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/HTTP--2.html">什么是HTTP/2？</a></li><li><a target="_blank" rel="noopener" href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a></li><li><a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh-js/remesh</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/preact/">preact</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/15/web-optimization/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我早就想拿 QuickJS 做 SSR 了</title>
      <link>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</link>
      <guid>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</guid>
      <pubDate>Mon, 12 Dec 2022 12:33:01 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;鸽了一年，不重要，下一篇解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在几乎现代框架 SSR 默认都是用 &lt;code&gt;node&lt;/code&gt;，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 &lt;code&gt;React&lt;/code&gt; 举例子，SSR 分两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 &lt;code&gt;renderToString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行时水合，也就是不用 &lt;code&gt;render&lt;/code&gt; 而是 &lt;code&gt;hydrate&lt;/code&gt;，因为已经不需要在运行时创建节点，只需要绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以问题就很清晰：默认或者常规手段的 &lt;code&gt;hydrate&lt;/code&gt; 和 &lt;code&gt;renderToString&lt;/code&gt; 都是 JS 函数&lt;/p&gt;
&lt;p&gt;当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：&lt;strong&gt;这 B 是不是可以直接拿来做 SSR ？&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>鸽了一年，不重要，下一篇解释</p></blockquote><p>现在几乎现代框架 SSR 默认都是用 <code>node</code>，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 <code>React</code> 举例子，SSR 分两个步骤：</p><ol><li>静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 <code>renderToString</code></li><li>运行时水合，也就是不用 <code>render</code> 而是 <code>hydrate</code>，因为已经不需要在运行时创建节点，只需要绑定</li></ol><p>所以问题就很清晰：默认或者常规手段的 <code>hydrate</code> 和 <code>renderToString</code> 都是 JS 函数</p><p>当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：<strong>这 B 是不是可以直接拿来做 SSR ？</strong></p><span id="more"></span><h2 id="Why-QuickJS">Why QuickJS</h2><p>毕竟 rust 早就有 v8 绑定，<code>deno</code> 用的就是</p><p>你说得对，但是 QuickJS 是由著名神仙 Fabrice Bellard 所打造的一个小型并且可嵌入的 Javascript 引擎，它支持ES2020规范，包括模块，异步生成器和代理器。在这里，你可以用任何现代的 JavaScript 语言片段在几乎任何语言环境中运行，在自由的环境中邂逅不同的语言和技术栈，同时它还支持 Decimal 提案和运算符重载提案……</p><p>其实就是不挑</p><h2 id="前端">前端</h2><p>流水账，主要是踩坑流程</p><p>前端部分自不必多说，玩了两年半的 <code>solidjs</code>，现在只要不是上班都是用这款（其实上班能夹带私货的时候也用）</p><p><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a> 提供 SSR 各种形态的 demo，但他们都有一个特点：使用非常原生的 <code>rollup</code> 插件作为演示<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，那我正经用也不用这个啊，那不行，就得按 vite 工作流来。</p><p>so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm dlx degit solidjs&#x2F;templates&#x2F;ts</code></pre><p>首先 <code>vite.config.ts</code> 有两处调整：</p><ul><li>solid 插件激活 ssr，这在处理 ssr 输出时有用</li><li><code>noExternal</code>，后面讲为什么</li></ul><p>改完之后大概是这样</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default defineConfig(&#123;  plugins: [solidPlugin(&#123; ssr: true &#125;)],  build: &#123;    target: &quot;esnext&quot;,  &#125;,  ssr: &#123;    noExternal: true,  &#125;,&#125;);</code></pre><p><code>package.json</code> 新增一个 <code>script</code>，不加也行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;vite build --outDir .&#x2F;dist&#x2F;client&quot;,    &quot;build:server&quot;: &quot;vite build --ssr .&#x2F;src&#x2F;entry-server.tsx --outDir .&#x2F;dist&#x2F;server&quot;,  &#125;&#125;</code></pre><p>这里把输出路径都有点调整，目的是把客户端产物和服务端产物分开，不这么做也行。<strong>但入口是肯定分开的</strong>，即使这很基操不需要写下来</p><p>按照 vite 建议的做法，客户端入口从 <code>index.tsx</code> 改为 <code>entry-client.tsx</code>，则服务端入口为 <code>entry-server.tsx</code>，内容每个框架都差不多，按照前端框架的建议做即可</p><p><strong>记得客户端真实入口 <code>index.html</code> 里的 script 路径也要改！</strong></p><p>过一下 build，能看到 dist 下两组目录，下一步</p><h2 id="服务端">服务端</h2><p>Web Framework 不用挑，用的最多的（可能也是两年半），可能也是目前来说依然最虎的 <code>actix-web</code>，需要花心思的是找 binding</p><p>首先用的是 <a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a>，在品鉴这个项目的时候还顺便搜到另一个项目 <a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a>，这是一个类似的操作：通过 QuickJS SSR Vue，可以读读看</p><blockquote><p>Node outperforms QuickJS by a wide margin. Especially with enough cores and memory. However, QuickJS is very small and has very low memory consumption, so running it threaded in a Rust shell makes it possible to have very high throughput using very few resources in comparison.</p></blockquote><p>顺便品鉴完这个项目之后，开始缝合。不出意外的话马上要出意外了</p><h3 id="坑1：">坑1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unsupported keyword: export</code></pre><p>这里可以讲讲为什么上面要 <code>noExternal</code> ，原因很简答，vite 默认你是会用 node 的，加上 type 是 <code>module</code>，结果就是编译后的服务端入口依然有 <code>import</code> 和 <code>export</code></p><p>所以目的很简单：把所有用到的 js 都打成一个文件。并且这里还需要一个操作：去掉最后一行，也就是 <code>export</code> 部分</p><p>默认情况下是在 QuickJS global 环境下 eval 程序，直接当成 <code>REPL</code> 来用就完事了</p><h3 id="坑2：">坑2：</h3><blockquote><p>找不到 setTimeout</p></blockquote><p>一番查找，<code>setTimeout</code> 由 QuickJS 内置 module: os 提供，按道理来说 <code>setTimeout</code> 应该能在 globalThis 直接调用</p><p>没关系，直接 eval 进去吧</p><h3 id="坑3：">坑3：</h3><blockquote><p>不存在 os</p></blockquote><p><strong>这你妈你说你妈呢？</strong> 这怎么可能啊</p><p>只见 Issue 区赫然有这么一行</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs/issues/123">Is there any way to use std, os, and global?</a></li></ul><p>Ok，寄</p><h3 id="Finish">Finish</h3><p>本来看着是 star 最多的库</p><p>算了，还得是直接绑定来得稳定，虽然比较麻烦，相当于换个语言直接使用框架。但高级封装至少比低级封装容易使用</p><p>于是改用这个高级封装：<a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a>，这个就非常纯，需要直接生吃 Document</p><p>简单验证</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let test &#x3D; ctx.eval(&quot;let a &#x3D; 1; let b &#x3D; 2; a + b&quot;).unwrap();assert!(3, test);</code></pre><p>发现没问题，直接搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let result &#x3D; context.with(|ctx| &#123;    let _a: String &#x3D; ctx.eval_file(&quot;ssr&#x2F;dist&#x2F;server&#x2F;entry-server.js&quot;).unwrap();    let result: Object &#x3D; ctx.eval(r#&quot;render()&quot;#).unwrap();    let head: String &#x3D; result.get(&quot;head&quot;).unwrap();    let body: String &#x3D; result.get(&quot;body&quot;).unwrap();    let mut map &#x3D; HashMap::&lt;String, String&gt;::new();    map.insert(&quot;body&quot;.to_string(), body);    map.insert(&quot;head&quot;.to_string(), head);    map&#125;);</code></pre><p>这里转一次 <code>HashMap</code> 的原因是：<code>Object</code> 的类型没有声明，直接 return 出去有静态检查问题，rust 不允许</p><p>但因为是概念验证，先转成已知类型出去顶着用</p><p>编译没问题，继续搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let template &#x3D; read_to_string(&quot;ssr&#x2F;dist&#x2F;client&#x2F;index.html&quot;).unwrap();let html &#x3D; template    .replace(&quot;&lt;!--app-head--&gt;&quot;, result.get(&quot;head&quot;).unwrap())    .replace(&quot;&lt;!--app-body--&gt;&quot;, result.get(&quot;body&quot;).unwrap());</code></pre><p>打印 html，确认内容就是一个完整的 html 文件。<strong>成了！</strong></p><p>那直接上 server-side，简简单单写个 get</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[get(&quot;&#x2F;&quot;)]async fn hello() -&gt; impl Responder &#123;    let html &#x3D; make_html();    HttpResponse::Ok()        .status(StatusCode::OK)        .content_type(&quot;text&#x2F;html&quot;)        .body(html)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123;    HttpServer::new(|| &#123;        App::new()            &#x2F;&#x2F; 静态文件映射            .service(Files::new(&quot;&#x2F;assets&quot;, &quot;ssr&#x2F;dist&#x2F;client&#x2F;assets&quot;))            .service(hello)    &#125;)    .bind((&quot;127.0.0.1&quot;, 8080))?    .run()    .await&#125;</code></pre><p>浏览器输入一个令人熟悉的 <code>localhost:8080</code>，正常运行，JS 绑定也一切正常</p><p>代码会发布在 <a target="_blank" rel="noopener" href="https://github.com/colmugx/quickjs-ssr">colmugx/quickjs-ssr</a></p><h2 id="最后-3">最后</h2><p>这里只是一个简单验证，SSR 的 real world 肯定不是这么两步就能完成，否则就不需要像 <code>next.js</code> 和 <code>SolidStart</code> 这样的上层框架</p><p>并且，除了服务端需要考虑线程池等等这些问题之外，拥有 JIT 的 v8 可能性能上会更优</p><p>但我的目的也很简单，我要的不是 SSR，而是两个需求</p><ul><li>给 <code>ayaka</code> 提供一个静态页面生成的方式，但默认还是像 <code>saika</code> 那样的运行时 fetch</li><li>给 <code>kazusa</code> 提供脚本执行环境，不过这是个 optional，主要维护还是 lua 执行环境，这与既定用户群有关</li></ul><p>别问为什么又来一个 <code>ayaka</code>，问就是灵感来源 <a target="_blank" rel="noopener" href="https://github.com/2nthony/saika">2nthony/saika</a>，而不叫<code>sakuya</code>的原因仅是因为那会在玩原神银趴</p><p>最后，这可能是第一篇来自于这个主题 3.5 版本的文章，想给用 hexo 的这段时间一个完美的休止符，然后去开发有新设计风格的 nlvi 4</p><p>但是重构一半，交互上还是有缺陷，只不过说不影响阅读</p><h2 id="Links">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>solidjs 的 vite 插件来源于 rollup 插件的上层封装 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/quickjs/">quickjs</category>
      
      <category domain="https://colmugx.github.io/blog/tags/vite/">vite</category>
      
      <category domain="https://colmugx.github.io/blog/tags/solid/">solid</category>
      
      <category domain="https://colmugx.github.io/blog/tags/ssr/">ssr</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>作为玩家 成为玩家</title>
      <link>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</link>
      <guid>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</guid>
      <pubDate>Fri, 07 Jan 2022 11:21:34 GMT</pubDate>
      
      <description>&lt;p&gt;实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那是一篇极其消极的文章&lt;/li&gt;
&lt;li&gt;本文是一次自我救赎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so，这也许是更合适的“年终总结”&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-8&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虽然还是前端，但身处游戏&lt;/li&gt;
&lt;li&gt;对于以上，为什么&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：</p><ul><li>那是一篇极其消极的文章</li><li>本文是一次自我救赎</li></ul><p>so，这也许是更合适的“年终总结”</p><h2 id="TL-DR-8">TL;DR</h2><ul><li>虽然还是前端，但身处游戏</li><li>对于以上，为什么</li></ul><span id="more"></span><h2 id="因为热爱">因为热爱</h2><blockquote><p>从主观感受聊到游戏设计，这大概就是热爱吧 —— 2021.4.30</p></blockquote><p>我觉得故事不用从盘古开天辟地开始讲起</p><p>非常幸运的是，当时的工作环境中，团队所有人都玩游戏，大部分都玩高品质单机游戏，所以我们业余茶歇都会聊游戏。甚至分享可以讨论游戏，甚至在会议室玩《决斗链接》，两人duel，其他人通过电视观战。而那会面试的时候，我们经常问的“你业余时间一般会做什么”，在得到瞬间的回答“我平时不玩游戏”反而会感到诧异</p><p>在当时，除了会讨论游戏好不好玩之外，我经常又会往下继续讨论。跟另外一位同事经常讨论现在的热点，以及游戏细节，和“我为什么喜欢xx游戏”。那个时候根本没想过会到游戏公司服务，大家只是玩家</p><p>后来遇到一些朋友，无一例外都来自于游戏公司。于是在氛围煽动下，我离开了所处不久的新环境。这里只能说：感谢 VP 的理解和支持，同时我没办法回应你的欣赏，实属抱歉</p><h2 id="“黑暗降临”">“黑暗降临”</h2><blockquote><p>永远不要忘记第一次听《疾如猛火》后潸然泪下的那个中午</p></blockquote><p>作为一个营销碰瓷游戏，在此之前我从来没有关心过，黑暗降临也指的是第一次的营销碰瓷。但在一次内部分享之前，一切都改变了</p><p>分享的大概主题是“原神的音乐设计”，发生在分享之前，游戏新闻也多多少少提到：</p><blockquote><p>《崩坏3》和《原神》的音乐火到出圈</p></blockquote><p>于是，这是我与原神的第一次接触 —— 我打开了原神的主主题（Main Theme）。那个层次的细腻和画面感一下子涌入脑中，光听音乐已经能大概能看到这是一片幻想大陆</p><p>紧接着，我听了一些场景音乐。有个熟悉的特点，场景音乐都分为日间和夜间，这个设计在这之前仅有《异度之刃》系列对我印象深刻</p><p>当天中午，引用的故事发生了。在五声宫调跳进中古调，加上民乐领跑，饱满的感情直接轰入灵魂。因为原神的早期世界观架在欧洲，主题也就偏中古调式。《疾如猛火》就是一首同时具有璃月主题与原神主题的战斗音乐，也就是就东方体裁碰撞西方体裁，民乐器碰撞管弦乐，毫不突兀，又交相辉映……就这样一下子崩不住了。落泪原因简单：在我们生活的这片土地上，真的诞生了品质如此优秀的游戏</p><p>其实很长一段时间我都没有打开过原神，下载过原神。但城邦、人物性格、人际特点几乎都靠音乐云了个七七八八。蒙德有大大小小的西欧建筑，遍地风车，人们过着惬意的生活；繁荣的璃月港口络绎不绝，不仅存在丰富的中华文化，更是做到最大的文化包容；像是一个存在于战争或荒乱的稻妻，人民憧憬和平，满怀希望。在绀田村的表达中更为明显，仿佛妻离子散，每天都盼望家人回家……而每个元素也有独特的风格，雷元素会有重金属或者电子音乐，火元素有急躁的风格或者摇滚，水元素总会用带有故事感的钢琴带情绪……</p><p>且不谈游戏质量，这已经能证明这是成功的游戏音乐了</p><p>这是一个即使现在想起来还是会鼻尖一酸的回忆，<strong>所以我不断提醒自己，不要忘记这个感觉。</strong>《鬼谷八荒》、《风来之国》、《戴森球计划》等等证明了我们是可以做出优秀的游戏，《原神》向我们展示了我们也能做出贴近日系上游品质的游戏。但是 <strong>这个日系游戏并没有屈服于这个 title —— 璃月的刻画告诉了全世界什么是中华文化。</strong> 原本我没有喜欢过任何一个角色，现在有了：<strong>红毹婵娟 —— 云堇</strong></p><p>与其说是爱上了 miHoYo，不如说只是喜欢 HoYo-MiX。我还是不会主动向人推荐《原神》</p><h2 id="“未成年保护”">“未成年保护”</h2><blockquote><p>周五、周六、周日和法定节假日<br>20:00 ~ 21:00</p></blockquote><p>两个朋友同一时间离职，相继去了三个不同的行业：游戏、教育、房地产。于是后面发生了什么已经不用讲了（笑</p><p>虽然 ban 的是网络游戏。但难免有些感慨。国内的游戏环境还是太糟糕了，被各种数值网游污染，导致人们根本没办法理解什么是游戏，怎么对待游戏。现在还有绝大多数人认为游戏 = 打怪升级刷刷刷，他们不懂《双人成行》为什么必须两个人玩；《风之旅人》为什么不告诉玩家 NPC 的由来；《传说之下》为什么不能打怪升级；《我的世界》为什么能成为电子工程摇篮（x</p><p>针对游戏问题，更重要的是成长期的陪伴。任天堂在 2000 年的时候就推出了“防沉迷机制”<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但人家是如何理解防沉迷的？</p><blockquote><p>Wii的“家长监控”模式，最终选择了记录孩子的游戏时间，让他们和家长自行沟通决定游戏时间，用主机里的“游戏履历”督促孩子遵守约定，达到和“断电”同样的目的。</p><p>总之，大部分限制都能调整，只要家长和孩子商量好就行。这是任天堂“家长监控”系统的最大亮点。</p></blockquote><p>任天堂在本来是提供给监护人的信《致监护人》预判了“孩子可能正在寻找解除限制的方式”，并留下了一段话告诉小朋友：</p><blockquote><p>不守诺言，整天玩游戏肯定是不行的<br>但如果是“我才玩了一会……”就被爸爸妈妈说了<br>那或许就是没有好好决定游戏时间的缘故了！</p><p>确定一个规则，然后让爸爸妈妈通过这个软件监督自己，这样就能开开心心玩游戏了</p></blockquote><p>我是相信人在思维最发散的时候是应该接触电子游戏或者沙盘游戏的，而且应该培养一个健康的游戏价值观。<strong>至于那些什么“电子海洛因”的家长，反正每一代都有上瘾的东西。</strong> 尝试反问你的家长，上学的时候有没有沉迷过武侠小说，有没有沉迷过滚铁环，至少我屡试不爽。什么时候为人父母才能懂得：<strong>家庭才是第一教育场所，陪伴才是第一教育资源。</strong> 怪电视，怪游戏，怪玩具，怪邻居都是不可能解决问题的</p><p>你觉得你很忙，没时间陪孩子，把手机一丢让孩子自己玩。即使你手机没有王者荣耀，你的孩子也会因为抖音上瘾。到时候你敢举报抖音吗？你不敢！因为你也正上瘾着呢！</p><h2 id="主程摆烂">主程摆烂</h2><blockquote><ul><li>这个实现不了</li><li>我们最近太忙了，有空看一下</li></ul></blockquote><p>这来自于真实情况，但我只能轻描淡写</p><p>作为发行，确实有很多运营工作是需要我们做的，其中就有游戏中的社区入口。我们对接的两个游戏，一个 webview 不撑满，一个 webview 保留默认工具栏，更甚的是 android 与 iOS 的工具栏位置不同，但它们都会挤压视图空间。而这两个问题本不是问题，对于 unity editor 来说仅仅是一个开关而已。而当我们提出了问题时，对方回复了引用1；而当我们提出解决方式：仅加一条声明，对方回复了引用2</p><p>并且在合作过程中，游戏方经常爱理不理，甚至出现内存泄露时还直接推锅是社区造成的，<strong>并转发崩溃堆栈给我们排查问题，你他妈是认真的吗？</strong></p><p>这让我感受到了，“带着热爱工作”只是我的一厢情愿而已，无论到哪都是如此。我不再出声，用 unity 模拟了我们需要的调试环境（只用了一个 webview，并对 webview 定制），并加入他们不愿意做的退出功能（不愿意取消工具栏的原因是没有工具栏退出不了场景）。以此来解决我们的调试工作经常受阻导致我们自己的开发周期被压缩，最后再进游戏运行一遍确认效果即可</p><p>彼时彼刻我真的很敬仰腾讯游戏，在《腾讯游戏开发精粹2》里他们描述到了，他们在三个游戏引擎都开发了渲染后端，让社区和活动页面都能直接渲染在游戏引擎中。这种做法无论什么角度都是完美的，而我们却还在这种狗屁事情纠缠不清</p><h2 id="浅墨离世">浅墨离世</h2><blockquote><p>愿这本书，能帮助那些热爱游戏编程、怀揣游戏开发梦想，却苦于难以入门的人们，让他们少走弯路。</p><p>愿这本书，能为国产游戏、国产游戏引擎的崛起，开启一扇门，迎接新的黎明。</p><p>我们都还年轻，该做的梦及时去做，该追寻的梦想用力去追寻。</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><blockquote><p>我有一个梦想，将来的某一天，大家都能玩到拥有自己本土文化的优质游戏。</p><p>我有一个梦想，有一天，西游记能出ACT，让老外去体会中国文化西游记中“斗战胜佛”的打击快感，那一定比西方的动作巅峰之作《战神》、《鬼泣》更加深邃。</p><p>我有一个梦想，有一天，上海滩能出沙盒游戏，而不是玩《GTA》感受美国梦，亦或是玩着《热血无赖》体验国外公司强行塞给我们的“中国文化”。</p><p>我有一个梦想，有一天，不少3A大作不需要汉化，因为是我们自己的游戏，配音是中国的，文化也是中国的。</p><p>我有一个梦想，将来的某一天，国产游戏能像中国的其他产业一样，以一个领跑者的姿态，面对全世界，面对全宇宙，器宇轩昂，扬眉吐气。</p><p>这会是由我们一起去完成的梦想。</p><p>等着我们的好消息！</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><p>我不会揣摩已故之人，但能写下如此文字的人最后的结果竟然如此令人遗憾，想必在那瞬间肯定是无比绝望吧</p><p>我对浅墨并不熟悉，在这之前仅通过 opencv 了解过。在这之前因为方向不同，所以对 shader 等等也不关心。在某个周六，兄弟加班出门吃饭时，看到了某座楼下面围起来了，还在叹息：</p><blockquote><p>XX游戏怎么又……（为什么加又）</p></blockquote><p>当知道当事人是如此追梦人时，没有人不是心酸的。但凡在知乎看过那两则招聘文章，即使评论区各种冷嘲热讽，也能感受到作者对这件事抱足了信心。</p><p>也许世界就是这么现实吧。有人正在坚持“技术宅改变世界”，有人在摆烂，有人因为可能过高投入导致评估收益不清晰而在投入之前终止了投入</p><h2 id="最后-4">最后</h2><blockquote><p>在我的名片上，我是一个公司总裁；<br>在我自己来看，我是一名游戏开发者；<br>而在内心深处，我是一名玩家。</p><p>—— 岩田聪 -《玩者之心》- GDC2005</p></blockquote><p>故事是经过排列的，每发生一个事件，这种无助又坚定的心情就加深一层</p><p>《原神》向我们和世界展示了国产优秀的架空世界观和国产游戏音乐，我们再也不用羡慕史克威尔的音乐；《黑神话：悟空》向我们和世界展示了各个角度的正版“斗战胜佛”，我们再也不用羡慕拥有《战神》的圣莫妮卡。未来还有更多可能</p><p>但我们的环境还是很糟糕。所以，我能不能也做点什么，能不能不再是少数人的世界，能不能让更多人理解，即使这对我来说完全陌生。打嘴炮是最简单的，但这件事可能真的入脑了 —— 我开始怀疑我的选择和自己：我真的可以做到吗？我可什么都不会啊！</p><p>就像 2022 年潘通流行色<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>想要表达的那样（老样子，博客换颜色了），也刚好贴近自己和博客一直的追求：<strong>让一切充满想象力</strong>，希望可以继续坚持下去。毕竟，整个评论区可都是“你可以！！”啊</p><p>其实 <code>godot-pong</code> 是有在做的，现在是填充基本规则和做了音效音乐（音乐觉得做废了打算重做所以迟迟没上传）</p><p>希望 2021 年留下来的这篇文章，在未来不会被自己删除，并时刻提醒自己</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/461405.html">https://www.huxiu.com/article/461405.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2022">PANTONE COLOR OF THE YEAR 2022</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>为什么我没想过 EventBus</title>
      <link>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</link>
      <guid>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</guid>
      <pubDate>Wed, 24 Nov 2021 14:32:35 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;以下全是暴论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个发生在今年的对话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：组件通信有几种方式？&lt;br&gt;
A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children&lt;br&gt;
Q：还有吗？&lt;br&gt;
A：postmessage 可以算吗&lt;br&gt;
Q：也行，还有吗？&lt;br&gt;
A：localStorage/sessionStorage 可以算吗？&lt;br&gt;
Q：算半个，还有吗？&lt;/p&gt;
&lt;p&gt;这 TM 不就这些方式还有吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回来一拉清单，各家文章盘点确实还多了一个：&lt;code&gt;EventBus&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>以下全是暴论</p></blockquote><p>这是一个发生在今年的对话：</p><blockquote><p>Q：组件通信有几种方式？<br>A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children<br>Q：还有吗？<br>A：postmessage 可以算吗<br>Q：也行，还有吗？<br>A：localStorage/sessionStorage 可以算吗？<br>Q：算半个，还有吗？</p><p>这 TM 不就这些方式还有吗？</p></blockquote><p>回来一拉清单，各家文章盘点确实还多了一个：<code>EventBus</code></p><span id="more"></span><h2 id="什么是-eventbus">什么是 eventbus</h2><p>简单理解：事件总线，一种订阅/发布模型，即是在希望发生事件处理的地方创造一个监听器(listener)，接着在希望影响到监听器所在位置变化或更新的地方加上发射器(emitter)</p><p>这样的好处是，任何位置都可以透传。因为事件总线（可以）是全局的</p><p>从名字上看，它应该是属于事件驱动设计的产物。这没问题，GUI 一直都跟事件驱动有关，浏览器在交互部分也是这么做的</p><p>那，这么多前端框架有没有使用事件驱动的？有，御三家里的 <code>Angular</code>。除了御三家那更多了，反而数据驱动才是新品种</p><p>OK 目的达成，我就是要绕到这个点上：为什么面试上问 Vue，甚至是 React，我就没想过 EventBus。<strong>因为这本来就跟数据驱动没关系</strong></p><h2 id="为什么我不用-eventbus">为什么我不用 eventbus</h2><p>不带 Vue 玩了这领域有争议。就一个问题：什么时候 React 会触发更新？</p><p>这个时候就应该有个经典公式：view = f(props, state)。也就是当 <code>props</code> 或者 <code>state</code> 发生更新了，<code>view</code> 会更新。或者换句话说，<strong>数据更新了视图会更新</strong></p><p>那这里就有一个问题：如果触发了某个事件，视图会更新吗？<strong>会更个几把！</strong> 要会更新你还需要 <code>setState</code> 吗？这也是为什么 <code>rxjs</code> 在 <code>React</code> 用起来就是没有 <code>Angular</code> 来得无尿点，最核心的一点就是你想通过 <code>rxjs</code> 通知视图更新就肯定需要在订阅做一次 <code>setState</code>，不管你封装了还是在 business code 里订阅一次写一次</p><p>而且我不用还有另一个原因：这东西在我的理解中，就是一个 <code>goto</code> —— 它会把代码弄得非常糟。本来是单向的数据流向，现在会完全不知道某个组件会因为什么而产生更新，流向变得不可观察</p><p>你可能会说，那 context 也是这么传的啊！可 eventbus 可不禁止子组件 call 父组件，不约定好就造成逆数据流</p><p>除此之外，事件名称是一个字符串（暂且只能是字符串），那么这个时候需要保证事件名不要重复。为了解决这个问题可能就会引入一个叫事件表的东西 —— 但你想用到某一个事件时，import 这个常量，毕竟常量背后什么静态值对于事件来说无所谓，对得上就行。这会发生什么问题？在生产过程中这问题发生得不要太多，最经典的就是忘记更新事件表，或者嫌麻烦摆烂直接写，最后发现因为一个大小写导致事件对不上……</p><p>除此之外还有！毕竟是一个订阅发布模型，你订阅了是不是得取消订阅。事件的东西你一旦开了他就会一直留存在内存中，处理不当的话可能会出现两个一模一样的 listener，而这个原因仅是因为上一个没有销毁……当然了最轻的问题就是你的某一个事件处理会响应 n 次，是的这只是最轻的</p><p>总之这非常反思维，在一个数据驱动的环境中，为了一点点 buff 而引入大量 debuff 是否得不偿失。经过一轮网上冲浪后发现，相关讨论不少（指两个）</p><ul><li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/t/event-bus-is-it-a-good-idea/49853">Event bus - is it a good idea?</a></li><li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/androiddev/comments/eksepr/why_some_people_dislike_eventbus/">Why some people dislike EventBus?</a></li><li><a target="_blank" rel="noopener" href="https://tkacz.pro/vue-js-why-event-bus-is-bad-idea/">Vue.js: why event bus is bad idea</a></li></ul><h2 id="你真的需要-eventbus？你用来做什么？">你真的需要 eventbus？你用来做什么？</h2><p>Vue 有 provider/inject，React 有 Context API，这应该够用了</p><p>跟数据有关的 API，Vue 有 Vuex，React 有 React / Recoil。他们本身也会遵循单向数据流</p><p>所以，到底是哪里需要在 React 环境中引入一个不属于数据驱动的东西。或者换个思路（挖个坑）：</p><p><strong>我们是否正在被框架绑定？一个本只是视图层框架，现在还包含了逻辑层？</strong></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/">架构思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 一起玩吧</title>
      <link>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</link>
      <guid>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</guid>
      <pubDate>Fri, 03 Sep 2021 17:52:52 GMT</pubDate>
      
      <description>&lt;p&gt;稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-5&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;启动页面、得分牌&lt;/li&gt;
&lt;li&gt;加入简单的 AI&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-5">TL;DR</h2><ul><li>启动页面、得分牌</li><li>加入简单的 AI</li></ul><span id="more"></span><h2 id="完成情况-2">完成情况</h2><p>这把已经像一个游戏了。所以，可以一起玩吧</p><p>以下是记录本次更新一部分内容</p><h3 id="UI">UI</h3><p>目前是加了一个标题场景，但是过于没东西讲。老前端熟悉的 <code>flex</code> 布局思路一通搞完事</p><h4 id="切换场景">切换场景</h4><p>游戏是按场景(scene)来区分页面(非常前端的描述)，比如关卡类游戏一般会做很多 level 的场景。不同的是这可没有所谓的路由，而是直接切换(change)</p><p>这里使用的是：获取场景树，得到实例，切换场景(change_scene)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get_tree()-&gt;change_scene(path);</code></pre><p>这个项目里的实现是：把这种按钮直接做成「组件」，暴露场景接口。在标题场景 <code>connect</code> 所有这个类型的事件，用统一事件处理跳转。这样就封装了跳转场景，方便以后处理设置界面啥的</p><h4 id="记分牌动画">记分牌动画</h4><p>有一个控件 <code>AnimationPlayer</code> ，用来控制能访问到的节点的动画，例如运动、变形。如果使用过 <code>flash</code> 那是相当熟悉 —— 关键帧打起来</p><h3 id="加入-AI">加入 AI</h3><p>周伯通虽然也行，但是自己玩还是得有个「对手」</p><p>现在看到 AI 人就不知觉紧张起来，感觉是个非常难的东西。其实 AI 就只是「人工智能」，其目的就是「假装是个人」，那游戏 AI 就是「假装有个陪你打游戏的人」。只不过现在的「机器学习」确实给游戏 AI 也带来了不少想象力 —— 他们的操作越来越像人的思维方式了</p><p>多智能还得看开发者。例如中小学机器人编程比赛中的经典项目足球项目和灭火项目，</p><blockquote><p>足球项目：最简单的逻辑就是通过传感器（指南针）判断两边方向，超声波测距，忘记什么传感器用来找球。摸到球之后直接把球往对方门里「撞」，完事。</p></blockquote><blockquote><p>灭火项目：都带着指南针和热力传感，主要还是看谁的寻路比较nb</p></blockquote><p>游戏 AI 很早就有，最经典的游戏 AI 还属南梦宫的吃豆人(pacman)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（对于我来说一样属于游戏设计必修课，甚至机器学习也可以）。</p><blockquote><p>一共四个干扰怪物，逻辑都不相同</p><p>红色 blinky：追着豆子，通过寻路算法找距离最近的路线<br>粉色 pinky：追豆子前方第四个格子，通过寻路算法找距离最近的路线。如果向上移动，则是左上方四个格子<br>青色 lnky：blinky 与豆子各自前方射线的交点，并两倍延长的点<br>橙色 clyde：追豆子到方圆 8 格内就会散开（纯气氛组）</p><p>四个单个逻辑不复杂且工作量很小的 AI，组合成一个看似一直在围堵玩家的敌方小队。这就是最经典的地方</p></blockquote><p>这篇文章再开个坑：我要写一篇我对游戏 AI 的理解。例如游戏设计中，一些非常难的 gameplay 可能会设计出让 AI 「放水」，让玩家以为 AI 真的翻车了，以此来鼓励玩家</p><p>好了，这一部分的重点本应该是这个游戏的 AI，目前的设计是： <strong>在自己的 y 与球的 y 距离大于 25 时，追球。25 差不多是板子的 1/4。</strong> 逻辑就这，没了</p><p>但别小看这简单的逻辑，在目前没有什么骚东西的环境下，只要没有什么花里胡哨的操作（例如拿板边去敲球）几乎没有胜利的机会。而现在这个环境玩骚的只会把自己的分骚没（比如我）</p><h3 id="冷却与重置">冷却与重置</h3><p>当球落某方门后，球会重置到游戏中点，没有操作，直接关闭了惯性和直接 set position</p><p>不过有一个小设计：败方接球。如果某方上一回合输了，这一回合由该方接首发球</p><p>所以，虽然是可以玩了，但是还是缺东西，比如很多关于游戏规则的完善</p><h2 id="下一步">下一步</h2><ul><li>发球 y 随机：目前发球的 y 是固定的，直接去接球点等球多没意思啊</li><li>随机首发球：第一球现在都发给左方，或许应该随机</li><li>胜利规则：现在这游戏一开就没边了…</li><li>暂停与结束界面</li><li>声音</li></ul><p>游戏补完之后，往后的更新就越来越慢了，因为想法越骚，实现也会越来越难</p><h2 id="Link">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82567889">游戏AI入门及AI优化</a></li><li><a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html">AnimationPlayer</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27177424">现代游戏AI的鼻祖——聊聊你所不知道的《吃豆人》</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 发布</title>
      <link>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</link>
      <guid>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</guid>
      <pubDate>Thu, 02 Sep 2021 15:55:09 GMT</pubDate>
      
      <description>&lt;p&gt;其实游戏已经做很远了，为了真实性删了很多添加的东西…&lt;/p&gt;
&lt;p&gt;本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-4&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完成基本的击打、胜利条件、球的恢复&lt;/li&gt;
&lt;li&gt;编译与发布&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>其实游戏已经做很远了，为了真实性删了很多添加的东西…</p><p>本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-4">TL;DR</h2><ul><li>完成基本的击打、胜利条件、球的恢复</li><li>编译与发布</li></ul><span id="more"></span><h2 id="完成情况">完成情况</h2><p>基本的 gameplay 已经完成 —— 两块板子一个球，板子的后面是各自的「门」。</p><p>门选择 <code>Area2D</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，原因是这个控件专门控制物理状态与检查物理状态；墙壁使用<code>StaticBody2D</code></p><p>板子和球目前均使用 <code>KinematicBody2D</code>，因为可以方便的模拟物理状态，反弹完全不需要代码描述。但板子可能应该换成<code>RigidBody2D</code>，这样可以模拟更多的真实物理，例如摩擦力，受力。不过目前需要求证：控制端使用 <code>RigidBody</code> 是否合理</p><p>完全没什么好讲的，非常简单的实现</p><h2 id="编译与发布">编译与发布</h2><p>由于 <code>native</code> 的关系，运行时会把 cpp 编译，并编译成动态链接库。例如 osx 使用 <code>.dylib</code>，那么 web 跟原生相关的肯定是 <code>.wasm</code> 。官方提供了原生端的案例<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，而开发时也只编译了 osx 版本。</p><p>直到要验证发布到 github pages 时，出大问题，浏览器只显示 <code>abort(undefined)</code></p><h3 id="目前不能使用最新的-emscripten-编译你的-wasm">目前不能使用最新的 emscripten 编译你的 wasm</h3><p>经历各种尝试，例如直接从源码编译新的 template，但编译时也频出问题，甚至 debug 无法成功编译，接着进入无尽改编译参数等各种操作……</p><p>直到看到这个 issue <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>因为之前一直使用的 <code>emscripten</code> 版本已经是 26，所以猜<strong>是不是跟版本有关系，于是换成 17，成了</strong></p><p>于是有另一个猜想：<strong>官方发布的模板是否因为也使用 17 的版本发布，会导致 dll 对应不上。业务代码必须同样使用 17 编译代码才可以使用？</strong></p><h3 id="交给-github-action">交给 github action</h3><p>因为刚刚的 issue，发现这个作者对 godot 发布已经了然于胸，最后发现他提供了一个 ci 配置<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，于是参考这个配置写了一个工作流，现在可以把整个发布路程交到 github 了</p><h3 id="记得提交-export-presets">记得提交 export_presets</h3><p>可能可以发现，前面大部分 action 都是失败的</p><p>如果选择了 github 的 .gitignore 模板，这个文件默认会被忽略。但缺少这个文件 ci 无法工作 —— 获取不到发布配置</p><p>so，记得提交，接着等待一切结束。顺带一提，github action 的配置应该不高，编译 godot-cpp 属实膀胱局</p><p>下一篇应该讲有完整 UI 的第一个版本，结束</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/physics/using_area_2d.html">使用 Area2D</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative C++示例</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-cpp/issues/554">Building for HTML5 stopped working for emsdk 2.0.18+</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/2shady4u/godot-cpp-ci">2shady4u/godot-cpp-ci </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 介绍</title>
      <link>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</link>
      <guid>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</guid>
      <pubDate>Sun, 29 Aug 2021 14:10:49 GMT</pubDate>
      
      <description>&lt;p&gt;做一个简单的项目介绍：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;godot engine&lt;/code&gt; 从零开始的 &lt;code&gt;pong game&lt;/code&gt; 开发。开发会尽量保持简单，但希望不缺挑战&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;pong&lt;/code&gt; 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：&lt;strong&gt;不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作&lt;/p&gt;
&lt;p&gt;所以项目将会使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;godot 3 (gdnative)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;photopea（用来弄点素材）&lt;/li&gt;
&lt;li&gt;garageband / logic（声音）&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>做一个简单的项目介绍：</p><p>使用 <code>godot engine</code> 从零开始的 <code>pong game</code> 开发。开发会尽量保持简单，但希望不缺挑战</p><p>实现 <code>pong</code> 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：<strong>不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去</strong></p><p>这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作</p><p>所以项目将会使用：</p><ul><li>godot 3 (gdnative)</li><li><strong>C++</strong></li><li>photopea（用来弄点素材）</li><li>garageband / logic（声音）</li></ul><span id="more"></span><h2 id="你-TM-怎么想的">你 TM 怎么想的</h2><p>「在岸上永远学不会游泳」，这是在当时听到的兄弟对我说的一句话。<s>希望他不是因为嫌我菜让我爬而说出来的话</s></p><p>也为了记录，「如果单就以 pong 作为母版，到底能做到什么样子」，所以本身也是一个兴趣导向产物</p><p>这个系列还是不定期更新，甚至可能随时流产。流产的原因只有一个：搞不出来了…</p><p>就这样。下一篇先写一切的基础：如何让 pong 运行起来</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>flutter desktop 能不能跨平台多窗口</title>
      <link>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/</link>
      <guid>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/</guid>
      <pubDate>Thu, 17 Jun 2021 15:34:21 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇文章极其具有时效性，在目前，&lt;code&gt;flutter&lt;/code&gt; 不支持多窗口，但是已经有&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY&quot;&gt;这么一篇文档&lt;/a&gt;&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。而且 flutter desktop 的多窗口可能已经计划中了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：&lt;code&gt;flutter&lt;/code&gt;。而且：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flutter 使用 &lt;code&gt;skia&lt;/code&gt; 绘图而不是调用原生组件，表现统一&lt;/li&gt;
&lt;li&gt;flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flutter 本就是先给移动端设计，可以直接用 &lt;code&gt;dart&lt;/code&gt; 完成很多工作。但是在调研桌面时发现一个问题：&lt;strong&gt;找不到多窗口 API！&lt;/strong&gt; 这不行。虽然 flutter 是允许原生编程，那我能会 &lt;code&gt;windows&lt;/code&gt; 开发吗？！&lt;/p&gt;
&lt;p&gt;等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/flutter-tauri-0.jpg&quot; alt=&quot;flutter-tauri&quot;&gt;&lt;/p&gt;
&lt;p&gt;把 flutter 套进 &lt;code&gt;electron&lt;/code&gt; 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）&lt;/p&gt;
&lt;p&gt;但是桌面端不选择 &lt;code&gt;electron&lt;/code&gt;，咱用 &lt;code&gt;tauri&lt;/code&gt;！毕竟现在全平台都 &lt;code&gt;webkit(blink)&lt;/code&gt;，而且 &lt;code&gt;flutter&lt;/code&gt; 使用 &lt;code&gt;canvaskit&lt;/code&gt;，不需要担心表现…&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章极其具有时效性，在目前，<code>flutter</code> 不支持多窗口，但是已经有<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">这么一篇文档</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。而且 flutter desktop 的多窗口可能已经计划中了。</p></blockquote><p>SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：<code>flutter</code>。而且：</p><ul><li>flutter 使用 <code>skia</code> 绘图而不是调用原生组件，表现统一</li><li>flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）</li></ul><p>flutter 本就是先给移动端设计，可以直接用 <code>dart</code> 完成很多工作。但是在调研桌面时发现一个问题：<strong>找不到多窗口 API！</strong> 这不行。虽然 flutter 是允许原生编程，那我能会 <code>windows</code> 开发吗？！</p><p>等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？</p><p><img src="/blog/Image/flutter-tauri-0.jpg" alt="flutter-tauri"></p><p>把 flutter 套进 <code>electron</code> 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）</p><p>但是桌面端不选择 <code>electron</code>，咱用 <code>tauri</code>！毕竟现在全平台都 <code>webkit(blink)</code>，而且 <code>flutter</code> 使用 <code>canvaskit</code>，不需要担心表现…</p><span id="more"></span><h2 id="准备工作">准备工作</h2><h3 id="初始化">初始化</h3><p><code>tauri</code> 采用的是「集成到项目」的方式，所以先创建一个 flutter 项目（创建步骤省略）</p><p>接着，根据文档<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>集成 tauri：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yarn add -D @tauri-apps&#x2F;cli$ yarn tauri init</code></pre><p>需要配置一些步骤。其中，<code>distDir</code> 选择的是 flutter 创建的 <code>web/</code>。开发地址暂时空过</p><h3 id="flutter-以服务运行">flutter 以服务运行</h3><p>与 electron 一样，tarui 运行的还是前端应用，所以要不执行 <code>index.html</code>，要不有个开发服务</p><p>flutter 直接调试会直接打开 chrome，所以这次运行换种方式：仅运行开发服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如果不指定端口，flutter 会随机一个高位端口，但每次启动都会更换端口flutter run -d web-server --web-port 4396</code></pre><p>flutter 服务没有热更，要更新的时候按 R <s>换弹</s> 更新</p><h3 id="配置-tauri-启动">配置 tauri 启动</h3><p>还记得刚刚漏了的运行地址？<code>tauri</code> 的配置都在 <code>tauri.conf.json</code> 中，找到 <code>devPath</code> 并补上</p><p>接着直接运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn tauri dev</code></pre><p>顺利的话就能直接看到窗口了</p><p><img src="/blog/Image/flutter-tauri.jpg" alt="flutter-tauri"></p><h2 id="开整">开整</h2><p>虽然标题只提到了「多窗口」，但 realworld 肯定无法避开原生操作。而且不管是 tauri 还是 electron 都需要用 <code>JavaScript</code></p><p>tauri 前后端（rust）通讯采用命令（command）的方式，同样是通过 event bus 互相抛事件来做到。所以我们要让一切 JavaScript 的工作桥接到 dart 上</p><p>tauri 提供了两种向后端通信的方式：直接用挂载在 <code>window</code> 的对象或者使用提供的包：<code>tauri-app</code>。这里暂时先用 <code>window</code>，但后者也可以满足，后面写 dartjs 互操作篇再覆盖</p><p>接下来分成两部分：需要实例化调用 与 不需要实例化调用</p><h3 id="不需要实例化">不需要实例化</h3><p>其实意思就是可以直接访问直接调用，不用 <code>new</code>。而在 tauri 中，向后端发起命令的函数位于：<code>window.__TAURI__.invoke</code></p><p>按照我们使用 JavaScript 的思路，调用一个对象下面的方法，思路就是直接一直点（.）下去。那么这就是一个<strong>访问多层上下文</strong>的过程</p><p>可以了，换成 dart 写出来</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; flutter 肯定有 dart，那肯定有 dart:jsimport &#39;dart:js&#39; as js;&#x2F;&#x2F; 获得 tauri 挂载的对象final tauri &#x3D; js.context[&#39;__TAURI__&#39;];&#x2F;&#x2F; 调用这个对象里面的方法tauri.callMethod(&#39;invoke&#39;, [&#39;&#39;]);</code></pre><h3 id="需要实例化">需要实例化</h3><p>总有（一堆）东西需要 <code>new</code>，多窗口就是其中一个。（这就离谱，多窗口竟然不由 rust 发起创建）</p><p>负责创建窗口的 API 位于：<code>window.__TAURI__.window.WebviewWindow</code><br>（更 NM 离谱的是直接明牌告诉你再加一个 webview）</p><p>那么，JavaScript 需要实例化，意味着<strong>需要在 dart 也实现一遍实例化</strong>作为映射。等于我们要在 dart 有一个对应的 class，有 class 才能 new</p><p>dart 里边儿能有这玩意儿吗！那妹有怎么办啊？造啊！</p><p>这次不能用<code>dart:js</code>，得换一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">flutter pub add js</code></pre><p>然后是模拟一切。首先最好先创建一个新文件，这个文件会被声明为某个可以被 <code>JavaScript</code> “发现”的 library</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS()library tauri; &#x2F;&#x2F; 实际上在这篇文章这块没卵用import &#39;package:js&#x2F;js.dart&#39;;</code></pre><p>接着，这波我们要实例化的是 <code>WebviewWindow</code>，位于 <code>window.__TAURI__.window.WebviewWindow</code></p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;&#125;</code></pre><p>那 class 要能 new，得有一个 <code>constructor</code>，dart 和某些其他语言一样，再写一遍类名。其他方法该怎么写怎么写</p><p>再看一眼 tauri 文档，<code>WebviewWindow</code> 实例化带两个参：<code>label</code> 和 <code>options</code>，<code>options</code>是一个对象，关于新窗口的配置</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, Object options);&#125;</code></pre><p>再看一眼文档，<code>options</code> 的 type 是 <code>WindowOptions</code>，所以这里可以如法炮制，再造出一个结构</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title, &#x2F;&#x2F; 文章例子仅需要 title  &#125;);&#125;</code></pre><p>这样写的结构，仅支持 <code>getter</code>，所以如果需要 <code>setter</code>，可以按照 dart 的方式改写这个 class</p><p>接着把上面的改一下。完整的代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; tauri.dart@JS()library tauri;import &#39;package:js&#x2F;js.dart&#39;;@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, WindowOption options);&#125;@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title,  &#125;);&#125;</code></pre><p>在<code>main.dart</code>创建一个新的按钮用来测试</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">ElevatedButton(  onPressed: () &#123;    final window &#x3D; WebviewWindow(      &quot;new_window&quot;,      WindowOption(title: &quot;Second Window&quot;),    );  &#125;,  child: Text(&#39;click&#39;),)</code></pre><p>完结撒花，结果不给图</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">Desktop Multi-Window Support (PUBLICLY SHARED)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://tauri.studio/en/docs/usage/development/integration">Tauri Integration</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/flutter/">flutter</category>
      
      <category domain="https://colmugx.github.io/blog/tags/tauri/">tauri</category>
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>组件化与工程设计</title>
      <link>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</link>
      <guid>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</guid>
      <pubDate>Tue, 16 Feb 2021 05:41:55 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是又一篇臆想文&lt;br&gt;
如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TL-DR-2&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;组件化在做什么，组件是什么&lt;/li&gt;
&lt;li&gt;因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以是什么时候前端开发也发展成需要「软件工程」的时代了，&lt;s&gt;还不是现在用户的电脑越来越 nb 浏览器越来越 nb&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……&lt;/p&gt;
&lt;p&gt;演变到这就产生一个问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是又一篇臆想文<br>如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。</p></blockquote><h2 id="TL-DR-2">TL;DR</h2><ul><li>组件化在做什么，组件是什么</li><li>因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计</li></ul><p>所以是什么时候前端开发也发展成需要「软件工程」的时代了，<s>还不是现在用户的电脑越来越 nb 浏览器越来越 nb</s></p><p>工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……</p><p>演变到这就产生一个问题</p><span id="more"></span><h2 id="问题">问题</h2><p>印象中的 toC 应用，它对于「历史包袱」的处理可以非常简单粗暴：</p><blockquote><p>都拖油瓶了，这不重构？顺道抬 KPI<br>既然都重构了，那整点新家伙，干活不累顺道抬 KPI (x2)</p></blockquote><p>所以 toC 应用总是会用上最新的技术，而且 toC 应用毕竟是直接面向个体用户的应用，所以无时无刻都在优化体验也说不定</p><p>但 toB 或者内部平台可不能说整就整，至少会遇到这些问题：</p><ul><li>“能用就行”</li><li>使用时间非常长，甚至可能公司开多久软件用多久</li></ul><p>如果再遇上几个持有「Promise没用过，应该是 vue 新加的功能」<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>观点的优质前端，这个应用的代码最后只能是 shit 了</p><h2 id="组件化">组件化</h2><p>我的二面可能会问一个没有什么正确答案也没什么理由的烂问题：</p><blockquote><p>如何理解组件化？</p></blockquote><p>但总能得到典型回答：</p><blockquote><p>工作中经常重复出现的功能<strong>抽</strong>成组件</p></blockquote><p>甚至是非典型回答：</p><blockquote><p>因为现在都用 vue，每一个 .vue 都是组件，这是 vue 要求的</p></blockquote><p>其中最经常得到的答案中，有一个关键动作：抽。所以又是什么时候组件化的定义变成了“抽组件”</p><h3 id="何为组件">何为组件</h3><p>在「C4模型」的官网中，关于组件的第一句话：</p><blockquote><p>The word “component” is a <strong>hugely overloaded term</strong> in the software development industry,</p></blockquote><p>很多地方其实都有组件概念，包括不限于 <code>sketch</code> 等设计应用都有组件概念。但一切都有相似之处：它们都可以是一个原子，一个单位，一个定义了接口能优秀完成某一部分工作的单位或者说 group。同理也适用于 sketch component —— 你定义了一个组件应该是怎样的元素构成与可变</p><p>所以上面的那句话，有后半句的：</p><blockquote><p>but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface.</p><p>If you’re using a language like Java or C#, the simplest way to think of a component is that it’s a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p></blockquote><h3 id="为什么开始强调组件了">为什么开始强调组件了</h3><p>确实没错，当前流行三大视图框架中，都有组件概念，即一个 vue 文件之于 vue，一个函数之于 react，一个 component 之于 ng 都是各领域定义的“组件”，甚至是「一切都是组件」。但这仅是强调了这是某个框架的原子，而<strong>业务形态的组件是由业务的，而不是框架决定的</strong>。</p><p>所以一个组件，并不是把代码放在一个 vue 文件，这个就是组件。毕竟你这个时候你可以问：你的应用下是不是有一个 <code>pages</code> 目录？下面也有一堆 vue 文件，他们每一个都是组件？接着你就尽情围观前端圈内最大双标现场</p><h3 id="怎样就是一个组件">怎样就是一个组件</h3><p>我自己给定义了几点：</p><ul><li>输入输出是确定的（像函数）</li><li>可单元测试的</li><li>“高内聚，低耦合”（现在还写这句话都觉得有些羞耻）</li></ul><p>举个例子，拿我以前很喜欢的某公司的官网做栗子（我觉得还是憋猜是哪个公司了吧，我给🐴成这样还猜得到？）</p><p><img src="/blog/Image/component-1.png" alt=""></p><p>这张图，大多数前端会认为，红框可以是组件。<s>甚至认为绿框在某开源组件库能找到</s></p><p><img src="/blog/Image/component-2.png" alt=""></p><p>放心我没⭕️ 错，很多前端都会这么想的。全都 <code>margin-top</code> 给它安排得明明白白，这样最后一个就不用处理了</p><p>但总有一部分的前端会这么认为：</p><p><img src="/blog/Image/component-3.png" alt=""></p><p>这样做几个好处：</p><ul><li>因为可以让组件弹性方便布局。</li><li>那个小标题<strong>肯定复用很多，别的地方也会有类似设计</strong></li><li><s>上下边距啊，在 <strong>page</strong> map 组件的时候<strong>给套上不就好了</strong></s></li></ul><p>所以很少前端会想到以下甚至更多：</p><p><img src="/blog/Image/component-4.png" alt=""></p><p>所以先弄清楚：<strong>谁是原子</strong>？</p><p>也就是「哪些是组件？」<strong>这个问题在设计阶段就应该确定了，而不是“抽成组件”</strong></p><p>所以在软件开发上，本就没有所谓的前端后端啥端的区别，软件该怎么写就得怎么写。一个组件可以是一个对象</p><p>而这<strong>还只是布局而已</strong>，也就是所谓前端工程师的「核心工作」</p><h2 id="工程化">工程化</h2><p>说实话，当今被冠以「工程师」之名的前端开发，没有几个懂工程（包括写这篇文章的five）</p><p>问题在于越来越多的软件都希望以浏览器为容器运行。所以并不是前端需要工程化，而是软件形态在发生改变。而这也可以继续解释下来会发生的事情 —— JavaScript 会越来越不顶用，需要 WebAssembly 做更多事情；使用 Web Worker 做跟渲染无关的事情等等等等</p><p>再同理，并不是开始要求前端开发需要懂工程了，而是这是一个软件工程师要知道的东西</p><h3 id="什么时候前端也要工程设计了">什么时候前端也要工程设计了</h3><p>是个应用就需要设计，或者说<strong>前端一直需要工程设计</strong>，只不过长时间被认为不需要和不被理解</p><p>最近的「微前端」更多的适用场景也是建立于此 —— 太旧的应用你实在维护不动了，新增的东西就以「微前端」的形式加入，这样做不破坏原本的应用，同时可以用较新的技术维护新功能</p><p>toB 大应用，在「前端」内容中更多是表单表格，以及很多弱交互的东西，可能最重的交互也就可视化配置。其注定了不需要设计驱动，更多的都在数据处理上，也就是「弄清数据流」。并且这类应用只会越做越大 <s>（直到流产，或者换老板）</s>，而且它的直接用户是另一个企业，甚至可能是以「私有部署」的形式售卖。所以要做的是尽可能稳定与高效</p><p>所以为了运行稳定不背锅，不让数据水乱流，只能跟传统软件，甚至是最亲近的后端服务的做法一样，做架构设计</p><p>而那些认为「按照原型实现 page component」的前端们，看看你的应用，是不是正在 <strong>「同一个接口在同一时间请求了好几遍，甚至是开一个弹窗再把相同数据请求个几遍？」</strong>。就这还敢把 Angular 作为鄙视链底层，谁给的勇气？<s>所以胆小的已经在用 dva(umi) 了</s></p><p>我又突然想到一次经历，我问过一个问题：</p><blockquote><p>你这里写了期望是前端架构师，精通前端架构。那你觉得前端架构需要做到什么？</p></blockquote><p>然后我得到一个非 常 满 意的回答：</p><blockquote><p>前端架构就是制定目录结构，接着指定代码规范，用什么组件库 balabala…</p></blockquote><p>那行呗，你开心就好，现在连 webpack 都不兴提一嘴了</p><h3 id="那咋做嘛">那咋做嘛</h3><p>提前说明，前端工程逃不过使用很多工具，包括构建与编译等。这里不讨论以上问题，只有编程「思想」</p><p>扒拉一段软件工程的含义：</p><blockquote><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p></blockquote><p>另外，IBM 的大型机之父布鲁克斯发布了《没有银弹》：</p><blockquote><p>从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等</p></blockquote><p>这里提到了「结构化程序设计」：</p><blockquote><p>结构化编程，一种编程典范。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><p>其实说到底总会有几点：</p><ul><li>高性能</li><li>高可用</li><li>高稳定</li><li><strong>可维护</strong></li></ul><p>关于可维护，这个时候可以来几个经典问题，问问自己，我现在在写的这个应用：</p><ul><li>是否有自动测试：unit test, e2e test？</li><li>是否会出现：点一个地方，哪哪都在 loading？（排除你偷懒连 loading 都不给）</li><li>一样的模块，在不同地方显示是不一样的？</li><li>一旦有一个样式改动，需要改十几个文件？</li></ul><p>这个时候，「组件」思想又被抬上台面，毕竟 <strong>组件化即一种分治思想</strong>。如果逃离了这个，那么单元测试就无法实现，因为<strong>此刻不存在单元</strong>，第一个问题不攻自破</p><p>接着，因为在应用之初根本没对应用进行设计，每个人拿着原型就开始整，最后各自写各自的，数据流都在某个组件里维护。接着产品经理要求「各数据展示需要同步」的时候怎么办？还不是指着产品骂娘然后做了一手操作：在产生 update 的地方后再 fetch 一次数据。所以第二个问题接着不攻自破</p><p>那怎么做其实非常明了：</p><ol><li>应用设计：在应用之初规划数据流</li><li>interface：看起来像爽哥，声音像爽哥，那就是爽哥</li></ol><p>数据流在设计之初就很好办，遇事不决先抄一版 flux —— 用 store 管理各种列表的数据和状态；列表页可以 keep-alive，根据 route 流向决定 store 的更新；VM 做成订阅/发布模型，这样，数据发起更新后，正在订阅数据的 V 可以做出更新……</p><p><strong>别信某些平台的前端爽文。什么 vuex/redux 等被称为状态管理的 library，只能用来管理共享状态，不能用来存放业务数据。Angular 看到这场景不得当场笑裂开</strong></p><p>到这也会发现，各种「台」的大型应用，最后也都是面向对象的思想。应用一旦复杂起来就需要一个充血模型。<s>那就更好办了，前端也直接 DDD ！直接嫖了后端的架构设计图</s></p><p>（顺便非常推荐《人月神话》，即使土，但45年依然流行是有道理的，其对于软件工程和项目管理的经验还有参考价值）</p><h2 id="最后">最后</h2><p>本来写这个文章的时候是想把遇到的事情都嘴臭一遍的，最后还是把这部分都清干净了，作为一个可能有用的文字。在此特别感谢若干 toB 项目，这几年在 toB 的公司中摸爬滚打带给我的一些新（旧）灵感（都是嫖后端和 GUI 应用的），终于让我这种杂学玩家体现出一点点作用</p><p>同时践行「敏捷开发」也有一段时间了，足够扎实的设计才能敏捷，不然就变成永远在填坑，而不是敏捷</p><p>所以这篇文章也作为开始，现在正在实践把「领域驱动设计」和「C4 模型」带到前端开发中。没错，又想开一个博文坑…</p><p>越来越觉得，前端架构设计可以参考 <code>rust</code> 的 <code>trait</code>，或者 <code>swift</code> 的 <code>protocol</code>，以及他们的设计模式。主观上觉得他们在思想有点相似</p><p>（不知道下次轮到我去面试时，恰好我的面试官看了我的博客，拿这玩意儿狙我…）</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://c4model.com/">The C4 model for visualising software architecture</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">维基百科 - 软件工程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">维基百科 - 结构化编程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">维基百科 - 敏捷软件开发</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科 - 领域驱动设计</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>一次面试发生的真实案例。并提出了「async 要配合 axios 才能用；ajax 没人用了」等理论 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/">组件化</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>再一次重新设计简历</title>
      <link>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</link>
      <guid>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</guid>
      <pubDate>Wed, 11 Nov 2020 15:22:24 GMT</pubDate>
      
      <description>&lt;p&gt;最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，&lt;s&gt;不同的 HR&lt;/s&gt;&lt;br&gt;
于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。&lt;s&gt;（确认是追了个寂寞）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;但这不是本文重点，这里将要讲新的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 一同带来的新简历模板的设计思路&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Resumer&lt;/code&gt; 正在用 &lt;code&gt;Angular 10&lt;/code&gt; 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…&lt;/p&gt;
&lt;p&gt;所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resume&quot;&gt;Resume&lt;/a&gt;、&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 和 Resumer(ng version)&lt;/p&gt;
&lt;h2 id=&quot;请停止使用这种模板&quot;&gt;请停止使用这种模板&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><span id="more"></span><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/">设计思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/">设计</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E7%AE%80%E5%8E%86/">简历</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我又不跨平台我为什么要 electron</title>
      <link>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</link>
      <guid>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</guid>
      <pubDate>Sat, 08 Aug 2020 09:24:29 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;无图版，会更有图版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;上篇文章（最近总是莫名联动）才写了 electron，主观感受，&lt;code&gt;electron&lt;/code&gt; 有这么些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得前端技术可以运用在本地桌面应用&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chromium&lt;/code&gt; 让兼容性不是首要考虑对象&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;NodeJS&lt;/code&gt; 既可以操作系统，也能利用本身能力与生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我好像不需要跨平台&lt;/li&gt;
&lt;li&gt;原生开发更加能操作系统 API&lt;/li&gt;
&lt;li&gt;扯破大天不就是&lt;code&gt;webview&lt;/code&gt;嘛&lt;/li&gt;
&lt;li&gt;依然不需要考虑兼容性，并且体积会大幅减小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，electron 再见！&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><span id="more"></span><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let menubar &#x3D; NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)let popover &#x3D; NSPopover()</code></pre><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; if let 爽啊！if let menuBtn &#x3D; menubar.button &#123;   menuBtn.title &#x3D; &quot;click&quot;   menuBtn.action &#x3D; #selector(togglePopover)&#125;&#x2F;&#x2F; 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到let popoverController &#x3D; NSStoryboard(name: &quot;Main&quot;, bundle: nil)  .instantiateController(withIdentifier: &quot;PopoverViewController&quot;) as? PopoverViewControllerpopover.behavior &#x3D; .transientpopover.contentViewController &#x3D; popoverController</code></pre><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">@objc func togglePopover(_ sender: AnyObject) &#123;    if popover.isShown &#123;        closePopover(sender)    &#125; else &#123;        showPopover(sender)    &#125;&#125;</code></pre><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; 其实本文其实用不到，先写着extension PopoverViewController: WKNavigationDelegate &#123;&#125;</code></pre><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">webview.navigationDelegate &#x3D; self&#x2F;&#x2F; 通过 userContentController 获取 webview 中的事件let contentController &#x3D; webview.configuration.userContentController&#x2F;&#x2F; 定义与前端交互的方法名contentController.add(self, name: &quot;hello&quot;)</code></pre><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let pagePath &#x3D; Bundle.main.url(forResource: &quot;index&quot;, withExtension: &quot;html&quot;, subdirectory: &quot;build&quot;)&#x2F;&#x2F; let devUrl &#x3D; URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)&#x2F;&#x2F; load 方式也不同，一种是加载文件，一种直接加载 urlwebview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())&#x2F;&#x2F; webview.load(devUrl)</code></pre><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">extension PopoverViewController: WKScriptMessageHandler &#123;    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;        if message.name &#x3D;&#x3D; &quot;hello&quot; &#123;            &#x2F;&#x2F; 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转            let body &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)            &#x2F;&#x2F; 这里完全可以通过 switch 做模式匹配，不过这里没有            if (body[&quot;type&quot;] as! String) &#x3D;&#x3D; &quot;notify&quot; &#123;              let value: String &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)[&quot;value&quot;] as! String              showNotification(title: value)            &#125;        &#125;    &#125;    &#x2F;&#x2F; 调用通知 api，显示通知    func showNotification(title: String) &#123;        let notification &#x3D; NSUserNotification()        notification.deliveryDate &#x3D; Date(timeIntervalSinceNow: 1)        notification.title &#x3D; title        NSUserNotificationCenter.default.deliver(notification)    &#125;&#125;</code></pre><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 点击按钮弹出通知const handleClick &#x3D; () &#x3D;&gt; &#123;  window.webkit.messageHandlers.hello.postMessage(&#123;type: &#39;notify&#39;, value: &quot;Hello World&quot;&#125;)&#125;</code></pre><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结-3">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 electron 爬图片</title>
      <link>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</link>
      <guid>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</guid>
      <pubDate>Sun, 21 Jun 2020 03:51:10 GMT</pubDate>
      
      <description>&lt;p&gt;有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了&lt;br&gt;
&lt;strong&gt;（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想了一下，切图仔唯一高效 GUI 的选型只有 &lt;code&gt;electron&lt;/code&gt; 了，没得选。但是这次有点特别，因为 &lt;code&gt;electron&lt;/code&gt; 的特殊性，我有了些想法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用的模板是之前实验服务一体化的模板 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/electron-react-koa-template&quot;&gt;electron-react-koa-template&lt;/a&gt;，然后删除了&lt;code&gt;server&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;删了&lt;code&gt;server&lt;/code&gt;……&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-3&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;webview&lt;/li&gt;
&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;提供下载&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR-3">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><span id="more"></span><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const webview &#x3D; document.createElement(&#39;webview&#39;)&#x2F;&#x2F; 当页面加载完成之后会触发这个事件，可以继续做接下来的事情webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)</code></pre><p>于是封装一下变成</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  const webview &#x3D; document.createElement(&#39;webview&#39;)  &#x2F;&#x2F; 保险起见  webview.useragent    &#x3D; &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) &#39;    + &#39;AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;    + &#39;Chrome&#x2F;81.0.4044.129 Safari&#x2F;537.36 Edg&#x2F;81.0.416.68&#39;  webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)  document.body.appendChild(webview)  this.webview &#x3D; webview&#125;search(url) &#123;  this.webview.src &#x3D; url&#125;</code></pre><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">mainWindow &#x3D; new BrowserWindow(&#123;  webPreferences: &#123;    &#x2F;&#x2F; 这里    webviewTag: true,    nodeIntegration: true,  &#125;,&#125;)</code></pre><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then((html) &#x3D;&gt; &#123;  &#125;);</code></pre><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;  webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then(html &#x3D;&gt; &#123;    ipcRenderer.send(&#39;ganhuo&#39;, html)  &#125;);&#125;)</code></pre><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ipcMain.on(&#39;ganhuo&#39;, (e, arg) &#x3D;&gt; &#123;  const $ &#x3D; cheerio.load(arg)  &#x2F;&#x2F; 各种教程都能看到的  &#x2F;&#x2F; 这里没多余操作，是个 img 就拿走  &#x2F;&#x2F; 接着 reply 回 renderer  const imgs &#x3D; $(&#39;body&#39;).find(&#39;img&#39;).map((idx, ele) &#x3D;&gt; $(ele).attr(&#39;src&#39;)).get()  e.reply(&#39;chuhuo&#39;, imgs)&#125;)</code></pre><p><code>renderer</code> 边准备一个接收，这波结束</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  ipcRenderer.on(&#39;chuhuo&#39;, (e, result) &#x3D;&gt; &#123;    this.setState(&#123;      imgs: result,    &#125;);  &#125;);&#125;</code></pre><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结-2">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接-2">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/electron/">electron</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/21/electron-crawler/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>整一个家庭服务器记录</title>
      <link>https://colmugx.github.io/blog/2020/06/07/home-server/</link>
      <guid>https://colmugx.github.io/blog/2020/06/07/home-server/</guid>
      <pubDate>Sun, 07 Jun 2020 05:57:46 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！&lt;/p&gt;
&lt;h3 id=&quot;系统选择&quot;&gt;系统选择&lt;/h3&gt;
&lt;p&gt;推荐三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot;&gt;raspbian&lt;/a&gt;（树莓派）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://clearlinux.org/&quot;&gt;clear linux&lt;/a&gt;（英特尔CPU）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.debian.org/index.zh-cn.html&quot;&gt;debian&lt;/a&gt;（传统服务器系统）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><span id="more"></span><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后-2">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/NAS/">NAS</category>
      
      <category domain="https://colmugx.github.io/blog/tags/linux/">linux</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/07/home-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</link>
      <guid>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</guid>
      <pubDate>Thu, 04 Jun 2020 14:30:36 GMT</pubDate>
      
      <description>&lt;p&gt;这应该是连载得最近的一次，书接上回：&lt;a href=&quot;/blog/2020/06/02/hammerspoon-ts/&quot;&gt;《或许可以用 TypeScript 编写 hammerspoon》&lt;/a&gt;（也就是下面那篇）&lt;/p&gt;
&lt;p&gt;这里只会描述通过 &lt;code&gt;TypeScript&lt;/code&gt; 实现的过程&lt;/p&gt;
&lt;p&gt;以下内容可能产生不适（因为&lt;code&gt;hammerspoon&lt;/code&gt;的 &lt;code&gt;d.ts&lt;/code&gt; 全是 &lt;code&gt;interface&lt;/code&gt; 一把梭，编码不好看）&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-6&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建界面&lt;/li&gt;
&lt;li&gt;实现剪贴板读取&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;绑定快捷键&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR-6">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><span id="more"></span><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容const completionFn &#x3D; choice &#x3D;&gt; &#123;  &#x2F;&#x2F; 一般来说这个判断不可省略，这样可以方便排除取消的情况  if (choice) &#123;&#125;&#125;const chooser &#x3D; hs.chooser.new(completionFn)</code></pre><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">chooser.show()chooser.hide()</code></pre><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.readString() &#x2F;&#x2F; 读取最后一次剪贴板的文本pasteboard.readImage() &#x2F;&#x2F; 读取最后一次剪贴板的图片数据</code></pre><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.changeCount()</code></pre><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const clipboard &#x3D; new Clipboard()&#x2F;&#x2F; 我选择 1s 检查一次export const clipWatcher &#x3D; hs.timer.new(1, () &#x3D;&gt; &#123;  const now &#x3D; hs.pasteboard.changeCount()  if (now !&#x3D;&#x3D; preCount) &#123;    pcall(clipboard.save.bind(clipboard))    preCount &#x3D; now  &#125;&#125;)clipWatcher.start()</code></pre><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">save() &#123;  const types &#x3D; hs.pasteboard.contentTypes&lt;ModelChoice[&#39;type&#39;]&gt;()  for (const type of types) &#123;    if (isImgType(type)) &#123;      this.saveImage(type)    &#125; else if (isTextType(type)) &#123;      this.saveText(type)    &#125;  &#125;&#125;</code></pre><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">hs.hotkey.bind(clipboardConf.hotkey[0], clipboardConf.hotkey[1], () &#x3D;&gt; &#123;  clipboard.show()&#125;)</code></pre><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">this.chooser!.choices(choices)this.chooser!.show()</code></pre><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</link>
      <guid>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</guid>
      <pubDate>Tue, 02 Jun 2020 14:59:20 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;lua&lt;/code&gt; 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 &lt;code&gt;cocos2d&lt;/code&gt; 的时候，就接触了这个语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hammerspoon&lt;/code&gt; 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整&lt;/p&gt;
&lt;p&gt;早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了&lt;/p&gt;
&lt;p&gt;当然还有其他方案，比如常见的用到了 &lt;code&gt;moonscript&lt;/code&gt;，这是一个类 &lt;code&gt;coffeescript&lt;/code&gt; 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境&lt;/p&gt;
&lt;p&gt;前些日子关注到有一个项目 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/TypeScriptToLua/TypeScriptToLua&quot;&gt;TypeScriptToLua / TypeScriptToLua&lt;/a&gt;，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><span id="more"></span><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><pre class="line-numbers language-none"><code class="language-none">npm inityarn add typescript-to-lua --dev</code></pre><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;dev&quot;: &quot;tstl --watch&quot;,&quot;build&quot;: &quot;tstl&quot;</code></pre><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
