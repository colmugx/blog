<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    
    <image>
      <url>https://avatars2.githubusercontent.com/u/21327913?v=3&amp;s=466</url>
      <title>Colmugx &#39;s Blog</title>
      <link>https://colmugx.github.io/blog/</link>
    </image>
    
    <atom:link href="https://colmugx.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Tue, 16 Feb 2021 16:50:56 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>组件化与工程设计</title>
      <link>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</link>
      <guid>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</guid>
      <pubDate>Tue, 16 Feb 2021 05:41:55 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是又一篇臆想文&lt;br&gt;
如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;组件化在做什么，组件是什么&lt;/li&gt;
&lt;li&gt;因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以是什么时候前端开发也发展成需要「软件工程」的时代了，&lt;s&gt;还不是现在用户的电脑越来越 nb 浏览器越来越 nb&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……&lt;/p&gt;
&lt;p&gt;演变到这就产生一个问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是又一篇臆想文<br>如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。</p></blockquote><h2 id="TL-DR">TL;DR</h2><ul><li>组件化在做什么，组件是什么</li><li>因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计</li></ul><p>所以是什么时候前端开发也发展成需要「软件工程」的时代了，<s>还不是现在用户的电脑越来越 nb 浏览器越来越 nb</s></p><p>工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……</p><p>演变到这就产生一个问题</p><a id="more"></a><h2 id="问题">问题</h2><p>印象中的 toC 应用，它对于「历史包袱」的处理可以非常简单粗暴：</p><blockquote><p>都拖油瓶了，这不重构？顺道抬 KPI<br>既然都重构了，那整点新家伙，干活不累顺道抬 KPI (x2)</p></blockquote><p>所以 toC 应用总是会用上最新的技术，而且 toC 应用毕竟是直接面向个体用户的应用，所以无时无刻都在优化体验也说不定</p><p>但 toB 或者内部平台可不能说整就整，至少会遇到这些问题：</p><ul><li>“能用就行”</li><li>使用时间非常长，甚至可能公司开多久软件用多久</li></ul><p>如果再遇上几个持有「Promise没用过，应该是 vue 新加的功能」<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>观点的优质前端，这个应用的代码最后只能是 shit 了</p><h2 id="组件化">组件化</h2><p>我的二面可能会问一个没有什么正确答案也没什么理由的烂问题：</p><blockquote><p>如何理解组件化？</p></blockquote><p>但总能得到典型回答：</p><blockquote><p>工作中经常重复出现的功能<strong>抽</strong>成组件</p></blockquote><p>甚至是非典型回答：</p><blockquote><p>因为现在都用 vue，每一个 .vue 都是组件，这是 vue 要求的</p></blockquote><p>其中最经常得到的答案中，有一个关键动作：抽。所以又是什么时候组件化的定义变成了“抽组件”</p><h3 id="何为组件">何为组件</h3><p>在「C4模型」的官网中，关于组件的第一句话：</p><blockquote><p>The word “component” is a <strong>hugely overloaded term</strong> in the software development industry,</p></blockquote><p>很多地方其实都有组件概念，包括不限于 <code>sketch</code> 等设计应用都有组件概念。但一切都有相似之处：它们都可以是一个原子，一个单位，一个定义了接口能优秀完成某一部分工作的单位或者说 group。同理也适用于 sketch component —— 你定义了一个组件应该是怎样的元素构成与可变</p><p>所以上面的那句话，有后半句的：</p><blockquote><p>but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface.</p><p>If you’re using a language like Java or C#, the simplest way to think of a component is that it’s a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p></blockquote><h3 id="为什么开始强调组件了">为什么开始强调组件了</h3><p>确实没错，当前流行三大视图框架中，都有组件概念，即一个 vue 文件之于 vue，一个函数之于 react，一个 component 之于 ng 都是各领域定义的“组件”，甚至是「一切都是组件」。但这仅是强调了这是某个框架的原子，而<strong>业务形态的组件是由业务的，而不是框架决定的</strong>。</p><p>所以一个组件，并不是把代码放在一个 vue 文件，这个就是组件。毕竟你这个时候你可以问：你的应用下是不是有一个 <code>pages</code> 目录？下面也有一堆 vue 文件，他们每一个都是组件？接着你就尽情围观前端圈内最大双标现场</p><h3 id="怎样就是一个组件">怎样就是一个组件</h3><p>我自己给定义了几点：</p><ul><li>输入输出是确定的（像函数）</li><li>可单元测试的</li><li>“高内聚，低耦合”（TMD 现在还写这句话都觉得有些羞耻）</li></ul><p>举个例子，拿我以前很喜欢的某公司的官网做栗子（我觉得还是憋猜是哪个公司了吧，我给🐴成这样还猜得到？）</p><p><img src="/blog/Image/component-1.png" alt=""></p><p>这张图，大多数前端会认为，红框可以是组件。<s>甚至认为绿框在某开源组件库能找到，找不到就不写了/不会写了</s></p><p><img src="/blog/Image/component-2.png" alt=""></p><p>放心我没⭕️错，很多前端都会这么想的。全都 <code>margin-top</code> 给它安排得明明白白，这样最后一个就不用处理了</p><p>但总有一部分的前端会这么认为：</p><p><img src="/blog/Image/component-3.png" alt=""></p><p>这样做几个好处：</p><ul><li>因为可以让组件弹性方便布局。</li><li>那个小标题<strong>肯定复用很多，别的地方也会有类似设计</strong></li><li>上下边距啊，在 <strong>page</strong> map 组件的时候<strong>给套上不就好了</strong></li></ul><p>所以很少前端会想到以下，甚至更多：</p><p><img src="/blog/Image/component-4.png" alt=""></p><p>所以<strong>组件化就是原子化</strong>，也是先弄清楚：<strong>谁是原子</strong>？</p><p>也就是「哪些是组件？」<strong>这个问题在设计阶段就应该确定了，而不是“抽成组件”</strong></p><p>所以在软件开发上，本就没有所谓的前端后端啥端的区别，软件该怎么写就得怎么写。一个组件可以是一个对象。只不过到最后，某些「把这么多事情直接交给 page “组件”」的前端工程师们口中的“高内聚，低耦合”，不过口号而已</p><p>而这<strong>还只是布局而已</strong>，也就是所谓前端工程师的「核心工作」</p><h2 id="工程化">工程化</h2><p>说实话，当今被冠以「工程师」之名的前端开发，没有几个懂工程（包括写这篇文章的five）</p><p>问题在于越来越多的软件都希望以浏览器为容器运行。所以并不是前端需要工程化，而是软件形态在发生改变。而这也可以继续解释下来会发生的事情 —— JavaScript 会越来越不顶用，需要 WebAssembly 做更多事情；使用 Web Worker 做跟渲染无关的事情等等等等</p><p>再同理，并不是开始要求前端开发需要懂工程了，而是这是一个软件工程师要知道的东西，<strong>可不知道多少前端连 UML 都不知道，更别说画了</strong></p><h3 id="什么时候前端也要工程设计了">什么时候前端也要工程设计了</h3><p>是个应用就需要设计，或者说<strong>前端一直需要工程设计</strong>，只不过长时间被认为不需要和不被理解</p><p>最近的「微前端」更多的适用场景也是建立于此 —— 太旧的应用你实在维护不动了，新增的东西就以「微前端」的形式加入，这样做不破坏原本的应用，同时可以用较新的技术维护新功能。<s>即使团队换血也不会出大问题</s></p><p>ToB 大应用，在「前端」内容中更多是表单表格，以及很多弱交互的东西，可能最重的交互也就可视化配置。其注定了不需要设计驱动，更多的都在数据处理上，也就是「弄清数据流」。并且这类应用只会越做越大（直到流产 <s>，或者换老板</s>），而且它的直接用户是另一个企业，甚至可能是以「私有部署」的形式售卖。所以要做的是尽可能稳定与高效</p><p>所以为了运行稳定不背锅，不让数据水乱流，只能跟传统软件，甚至是最亲近的后端服务的做法一样，做架构设计</p><p>而那些认为「按照原型实现 page component」的前端们，看看你的应用，是不是正在 <strong>「同一个接口在同一时间请求了好几遍，甚至是开一个弹窗再把相同数据请求个几遍？」</strong>。就这还敢把 Angular 作为鄙视链底层，谁给的勇气？</p><p>唉，蚂蚁的前端架构真的煞费苦心，dva(umi) 很大程度避免了这些问题</p><p>我又突然想到一次经历，我问过一个问题：</p><blockquote><p>你这里写了期望是前端架构师，精通前端架构。那你觉得前端架构需要做到什么？</p></blockquote><p>然后我得到一个非 常 满 意的回答：</p><blockquote><p>前端架构就是制定目录结构，接着指定代码规范，用什么组件库 balabala…</p></blockquote><p>那行呗，你开心就好，现在连 webpack 都不兴提一嘴了</p><h3 id="那咋做嘛">那咋做嘛</h3><p>提前说明，前端工程逃不过使用很多工具，包括构建与编译等。这里不讨论以上问题，只有编程「思想」</p><p>扒拉一段软件工程的含义：</p><blockquote><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p></blockquote><p>另外，IBM 的大型机之父布鲁克斯发布了《没有银弹》：</p><blockquote><p>从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等</p></blockquote><p>这里提到了「结构化程序设计」：</p><blockquote><p>结构化编程，一种编程典范。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><p>其实说到底总会有几点：</p><ul><li>高性能</li><li>高可用</li><li>高稳定</li><li><strong>可维护</strong></li></ul><p>关于可维护，这个时候可以来几个经典问题，问问自己，我现在在写的这个应用：</p><ul><li>是否有自动测试：unit test, e2e test？</li><li>是否会出现：点一个地方，哪哪都在 loading？（排除你偷懒连 loading 都不给）</li><li>一样的模块，在不同地方显示是不一样的？</li><li>一旦有一个样式改动，需要改十几个文件？</li></ul><p>这个时候，「组件」思想又被抬上台面，毕竟 <strong>组件化即一种分治思想</strong>。如果逃离了这个，那么单元测试就无法实现，因为<strong>此刻不存在单元</strong>，第一个问题不攻自破</p><p>接着，因为在应用之初根本没对应用进行设计，每个人拿着原型就开始整，最后各自写各自的，数据流都在某个组件里维护。接着产品经理要求「各数据展示需要同步」的时候怎么办？还不是指着产品骂娘然后做了一手操作：在产生 update 的地方后再 fetch 一次数据。所以第二个问题接着不攻自破</p><p>那怎么做其实非常明了：</p><ol><li>应用设计：在应用之初规划数据流</li><li>interface：看起来像爽哥，声音像爽哥，那就是爽哥</li></ol><p>数据流在设计之初就很好办，遇事不决先抄一版 flux —— 用 store 管理各种列表的数据和状态；列表页可以 keep-alive，根据 route 流向决定 store 的更新；VM 做成订阅/发布模型，这样，数据发起更新后，正在订阅数据的 V 可以做出更新……</p><p><strong>别信某些平台的前端爽文。什么 vuex/redux 等被称为状态管理的 library，只能用来管理共享状态，不能用来存放业务数据。ng 看你们这场景不得当场笑裂开</strong></p><p>到这也会发现，各种「台」的大型应用，最后也都是面向对象的思想。应用一旦复杂起来就需要一个充血模型。<s>那就更好办了，前端也直接 DDD ！直接嫖了后端的架构设计图</s></p><p>（顺便非常推荐《人月神话》，即使土，但45年依然流行是有道理的，其对于软件工程和项目管理的经验还有参考价值）</p><h2 id="最后">最后</h2><p>本来写这个文章的时候是想把遇到的事情都嘴臭一遍的，最后还是把这部分都清干净了，作为一个可能有用的文字。在此特别感谢若干 toB 项目，这几年在 toB 的公司中摸爬滚打带给我的一些新思想（都是嫖后端和 GUI 应用的），终于让我这种杂学玩家体现出一点点作用</p><p>同时践行「敏捷开发」也有一段时间了，足够扎实的设计才能敏捷，不然就变成永远在填坑，而不是敏捷</p><p>所以这篇文章也作为开始，现在正在实践把「领域驱动设计」和「C4 模型」整到前端开发中。没错，又想开一个博文坑…</p><p>越来越觉得，前端架构设计可以参考 <code>rust</code> 的 <code>trait</code>，或者 <code>swift</code> 的 <code>protocol</code>，以及他们的设计模式。主观上觉得他们在思想有点相似</p><p>（不知道下次轮到我去面试时，恰好我的面试官看了我的博客，拿这玩意儿狙我…）</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://c4model.com/">The C4 model for visualising software architecture</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">维基百科 - 软件工程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">维基百科 - 结构化编程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">维基百科 - 敏捷软件开发</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科 - 领域驱动设计</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>一次面试发生的真实案例。并提出了「async 要配合 axios 才能用；ajax 没人用了」等理论 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我的 2020</title>
      <link>https://colmugx.github.io/blog/2021/01/04/my-2020/</link>
      <guid>https://colmugx.github.io/blog/2021/01/04/my-2020/</guid>
      <pubDate>Mon, 04 Jan 2021 15:43:06 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;此时并不是在考虑这一年的收获，而是在考虑这是否又是一篇限时文章&lt;br&gt;
又或者说是 RSS 限定？因为 RSS 是不会被动删除的&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;经典一行 TL;DR 吧：2021 流行色现已实装 —— 灰黄使用灰色；今年没给开源干点什么；开始想要知识管理了；读书的书比以往都多对我来说…&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>此时并不是在考虑这一年的收获，而是在考虑这是否又是一篇限时文章<br>又或者说是 RSS 限定？因为 RSS 是不会被动删除的</p></blockquote><p>经典一行 TL;DR 吧：2021 流行色现已实装 —— 灰黄使用灰色；今年没给开源干点什么；开始想要知识管理了；读书的书比以往都多对我来说…</p><a id="more"></a><h2 id="关于博客">关于博客</h2><p>今年计划是推出 gatsby 版本的 nlvi，可惜现在还没有。归结两个原因，有可能因为步子太大扯到蛋，也有是想摸</p><p>hexo 版本的 nlvi 没了维护热情，今年只是给归档页面重新设计了分界。即使如此今年还是零星收获几个 star，是该说对不起呢？还是劝他们一起用 hugo/gatsby 呢？</p><h3 id="流行色不会缺席">流行色不会缺席</h3><p>每年潘通都会宣布下一年的流行色<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，2021 又是一年双色，极度灰与明亮黄</p><p>2020 对于全世界都是一个不如意的年份，人类都陷入了灰色一段时间，但明亮的黄色却代表着希望。</p><blockquote><p>As people look for ways to fortify themselves with energy, clarity, and hope to overcome the continuing uncertainty, spirited and emboldening shades satisfy our quest for vitality.</p></blockquote><p>所以，坚如磐石同时需要充满希望的灰色和黄色即是今年的流行色。</p><p>如果通过页面访问我的博客的家！人！们！可以发现<span style="color: #004373">经典蓝</span>已经下线，虽然黄色是代表希望的一方，但是为了风格还是使用灰色吧</p><p><strong>但！</strong> 也许不久之后，我们就整一把渐变！因为最近有一个设计风格非常吸引我，它正运用在 2020 KDA 与微信读书年度总结</p><h3 id="说回-nlvi">说回 nlvi</h3><p>因为现在开始大面积使用 <code>org-mode</code>，用 hexo 发文章就变得非常麻烦，需要尽早切换到可以直接使用 <code>org</code> 的应用上，这也许是一次催促 gatsby 版甚至是新设计的机会</p><p>立个 flag，今年写一篇《做 nlvi 的时候想了些什么》，也许这个总结对以后更新设计有一定用处</p><h2 id="关于开源">关于开源</h2><p>今年的正经提交真没有。公司在 GitHub 有一个 Organization，工作内容有一部分就是管着这些东西，所以账号上虽然可以看到很多 commit 和 code review 其实大多都来自于这里</p><p>但该开还得开，不仅 gatsby nlvi 和前面关于简历文章提到的 Resumer，还有知识管理编辑器 <code>setsuna</code> 和算是一个工作台的东西 <code>kazusa</code></p><h3 id="编辑器">编辑器</h3><p>这算是机缘巧合，内部应用原本的富文本编辑器不够满足需求，所以希望重(ti)构(huan)编辑器，希望能有比较好的扩展能力要青龙又要白虎的结果最后时间没谈妥，于是决定用 ckeditor 5 干一个，过程还各种论证 npm package 在 GPLv3 到底属于源码分发还是二进制分发…</p><p>这期间看了下 editor.js, prosemirror, quill, 还有需要为 vue 提供前端的 slate core</p><p>加上正在找一个能让自己舒服的管理知识的姿势以及对语雀的嫌弃，所以开始编辑器的鼓捣。希望能写完</p><h2 id="关于技术">关于技术</h2><p>除了前端，应该是花有一半时间在 <code>rust</code> 上，目前还没有什么成果</p><p>今年不知为何又开始整起 e2e 测试，使用 <code>cypress</code> 框架，体验还行。算是在单元测试的基础上又补充集成测试</p><p>年末重新开始使用 emacs，不过与几年前不同，emacs 现在更多是充当一个文档编辑器，但又与普通编辑器不同 —— 可以在文档中直接执行代码块并获得结果 —— 从而可以直接在文档里做很多事情甚至是生成图表。于是做到了不仅保留尝试代码，还保留实验结果</p><p>遗憾的是现在的 emacs 配置被我打碎了在重建，关于编程功能（补全与高亮）达不到可用的程度，还需要继续配置</p><h2 id="知识管理">知识管理</h2><p>不知道为什么，从今年开始就看到很多关于知识管理的文章，所有人都在知识管理，都在卡片式笔记，都在 <code>notion</code>，<code>roam research</code>…不过这倒是一个统计与总结的好机会，了解「卡片式笔记」之后觉得能整，先用 apple 的备忘录整一段时间之后，改用 <code>obsidian</code></p><p>后来思索一会，既然都这么做笔记，为什么不直接用 <code>emacs</code>，<code>org</code> 本身在链接能力就很强。加上因为 <code>roam</code> 的兴起后，<code>org-roam</code> 也应运而生。这应该是 emacs 最吸引人的功能，以至于很多其实不写代码只是为了组织论文的硕博们也在用 emacs</p><p>所以不得不说 org-todo 和 org-agenda，这应该又是 org-mode 用户中几乎都会使用的功能。感觉以后可以写一个文章，记录一下我现在正在怎么使用这个编辑器（好家伙又开了一个坑）</p><p>为什么不用例如 <code>notion</code>，<code>bear</code> 等等，原因是这类应用都属于 SaaS，我会把我的数据放到他们的服务器上。果断说不，我接受不了数据在我看不到的地方</p><p>为了同步，首先考虑到 webdav，dropbox 毕竟有点不方便，退而求其次找到一家网盘服务商 teracloud，直连效率真的好，注册后<s>填一下邀请码 SBTVQ 还能多给 5G 空间</s>（咳咳）</p><p>目前感觉良好，手机端可以用 orgzly(android) 和 beorg(ios)</p><h2 id="书">书</h2><p>说实话，我甚至对这个列表陷入了沉思</p><ul><li>《基本乐理》</li><li>《深入浅出 Rust》</li><li>《前端架构：从入门到微前端》</li><li>《我的第一本算法书》</li><li>《程序员的数学》</li><li>《毛泽东传》（推荐）</li><li>《mysql 必知必会》</li><li>《人月神话》</li><li>《深入核心的敏捷开发》</li><li>《Google软件测试之道》</li></ul><p>几乎一本一个类型</p><p>《基本乐理》应该是今年自我感觉最受用的一本，为此还重构以前写过的一些曲子。所以也理解了为什么有些电子音乐人会说：”不过是公式化音乐“。虽然是「符合和弦的和谐」了，但听着不如重构前「好听」。而且《基本乐理》让人有一种「应试教育」的感觉，<strong>音乐真的应该这么描述吗？</strong> 这是个问题</p><p>接下来读什么书还没想好，数据结构和算法还有 rust 还是继续看，剩下的书继续走一步看一步</p><h2 id="新的目标">新的目标</h2><p>回顾去年总结留下来的目标，意外的发现完成得还不错，至少都达到及格线。索性今年的目标就简单一些：立下的 flag 还有预期要写完的应用都写完，再多写一些我称之为曲苑杂坛式的有趣的文章</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2021">PANTONE COLOR OF THE YEAR 2021</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/colmugx/">colmugx</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/01/04/my-2020/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>composition-api 插件 —— Lifecycle</title>
      <link>https://colmugx.github.io/blog/2020/12/20/vue2-composition-api-4/</link>
      <guid>https://colmugx.github.io/blog/2020/12/20/vue2-composition-api-4/</guid>
      <pubDate>Sun, 20 Dec 2020 05:39:04 GMT</pubDate>
      
      <description>&lt;p&gt;书接上文：&lt;a href=&quot;/blog/2020/11/28/vue2-composition-api-3&quot;&gt;《composition-api 插件 —— Reactive》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;本来觉得没什么好写的，还想逃了……看这个东西真的不如直接看 vue3……&lt;/p&gt;
&lt;p&gt;甚至还不如下一篇文章的东西有趣！&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>书接上文：<a href="/blog/2020/11/28/vue2-composition-api-3">《composition-api 插件 —— Reactive》</a></p><p>本来觉得没什么好写的，还想逃了……看这个东西真的不如直接看 vue3……</p><p>甚至还不如下一篇文章的东西有趣！</p><a id="more"></a><h2 id="lifecycle">lifecycle</h2><p>直接上来就是一行注释掉的句子</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// export const onCreated = createLifeCycle(&#x27;created&#x27;);</span></span><br></pre></td></tr></table></figure><p>太硬核了以至于不知道插件作者是否忘记了 <code>setup</code> 即 <code>beforeCreate </code>和 <code>create</code></p><p>其他的生命周期函数都是统一交给 <code>createLifeCycle</code></p><h3 id="createLifeCycle">createLifeCycle</h3><p>回想一下生命周期函数的使用 —— 塞一个 callback</p><p>所以，确实没什么好写的 —— 配合 <code>injectHookOption</code> 做一个接收一个不使用入参的回调函数的函数。而原理上是使用 <code>optionMergeStrategies</code> 与原本 <code>option api</code>的回调函数们合并</p><p>关于 <code>optionMergeStrategies</code>，第一篇已经提到了，那个时候是用来声明<code>setup</code></p><h2 id="nextTick">nextTick</h2><p>nextTick 的存在是为了方便使用吧，这样就不需要每次想用的时候都在<code>refs.root</code>中取出来</p><p>所以本质上就是在一开始缓存的 Vue 实例中翻出 <code>nextTick</code>，做一次 <code>apply</code>，转移执行目标</p><h2 id="computed">computed</h2><p>使用 <code>computed</code> 的时候会发现一个问题：结构跟 <code>ref</code> 一样。从函数签名可以看到：</p><ul><li>直接给计算函数，则得到返回类型 <code>ComputedRef</code></li><li>像 vue2 一样给读写函数，得到返回类型 <code>WritableComputedRef</code></li><li><code>ComputedRef</code> 通过 <code>WritableComputedRef</code> 继承而得； <code>WritableComputedRef</code> 继承自 <code>Ref</code></li><li>唯一不同的是： <code>ComputedRef</code> 的 value 被打上 <strong>Readonly</strong></li></ul><p>回到函数本身。粗糙的看了一眼，实际上就是 vue2 内部实现 <code>computed</code> 的思路换了一个地方和操作再实现了一次，核心还是用到 <code>Watcher(computed watch)</code></p><h2 id="watch">watch</h2><p>先看这个。这部分 API，根据文档所述与 vue2 的 <code>watch</code> 没有区别</p><p>与 vue2 不一样的是，这里不需要把一个 <code>watch</code> 对象扫一遍拿到 <code>handler</code> ，因为一个 <code>watch</code> 只会有一个 <code>source</code> 作为第一个参数</p><p>所以稍微处理一下就可以送进 <code>createWatcher</code> ，作为共同依赖，放到后面写</p><p>需要留意的是，watch 送给 createWatcher 的参数顺序为：vm, source（第一参数）, callback（理解为第二参数）, opts（第三参数，可选）</p><h3 id="watchEffect">watchEffect</h3><p>说是新函数，结果代码更少 —— 三行</p><p>与 <code>composition-api watch</code> （这么长是为了区分）不同，第一参数为副作用函数，即一旦数据产生更改就会被调用</p><p>为什么上面写的需要留意呢，因为这里的传入顺序是：vm, <strong>ffect</strong>, null, opts</p><p>与 <code>watch</code> 不同于，本是传 source 的地方传入一个类似 callback 的函数</p><h3 id="createWatcher">createWatcher</h3><p>先创建一个用来「可以清空操作」的函数，在文档也可以看到用法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 如果 id 发生改变则会调用 onInvalidate</span></span><br><span class="line">watchEffect(<span class="function">(<span class="params">onInvalidate</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> token = performAsyncOperation(id.value)</span><br><span class="line">  onInvalidate(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">    <span class="comment">// id 改变时 或 停止侦听时</span></span><br><span class="line">    <span class="comment">// 取消之前的异步操作</span></span><br><span class="line">    token.cancel()</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>至于接下来的，其核心还是把 watch 的工作交给了 vue2(<code>vm.$watch</code>)，最后返回一个可以用来停止观察的函数</p><h2 id="小结">小结</h2><p>确实应该直接去看 vue3，新的 diff 手段与新的观察手段啥的</p><p>（其实来没来得及写小结，先敷衍了事）</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/12/20/vue2-composition-api-4/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>composition-api 插件 —— Reactive</title>
      <link>https://colmugx.github.io/blog/2020/12/08/vue2-composition-api-3/</link>
      <guid>https://colmugx.github.io/blog/2020/12/08/vue2-composition-api-3/</guid>
      <pubDate>Tue, 08 Dec 2020 13:17:39 GMT</pubDate>
      
      <description>&lt;p&gt;书接上文：&lt;a href=&quot;/blog/2020/11/28/vue2-composition-api-2&quot;&gt;《composition-api 插件 —— Ref》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最常用 API 之一，创建响应式元素基本方法之一。也可能是这个插件的核心之一&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>书接上文：<a href="/blog/2020/11/28/vue2-composition-api-2">《composition-api 插件 —— Ref》</a></p><p>最常用 API 之一，创建响应式元素基本方法之一。也可能是这个插件的核心之一</p><a id="more"></a><h2 id="reactive-function">reactive(function)</h2><p>首先是验证：需要满足是「对象」、「数组」，或者是 composition-api 定义的「源对象」，又或是只要是个能扩展的(isExtensible)就行。反之原路返回</p><p>接着，将从入参获得的对象传入 <code>observe</code> ，并过一遍 <code>setupAccessControl</code> 后返回</p><p>这么看来响应式工作在 <a href="#observe">observe</a> 完成，在这之前先写 <code>setupAccessControl</code> 发生了什么</p><h3 id="setupAccessControl">setupAccessControl</h3><blockquote><p>注释：代理属性访问，可以做解构或更多其他事情</p></blockquote><p>验证很多，需要：</p><ol><li>是一个对象</li><li>不能是一个「源对象」</li><li>不能是数组</li><li>不能是 <code>ref</code></li><li>isComponentInstance</li><li>不被 <code>accessModifiedSet</code> 记录</li></ol><p>都满足才可以接下来的工作</p><p><code>isComponentInstance</code> 是内部一个辅助函数，简单理解就是用来检查对象是否是 Vue 实例成员</p><p>接着，把对象向 <code>accessModifiedSet</code> 「注册」之后，每个元素都过一遍 <code>defineAccessControl</code></p><h3 id="defineAccessControl">defineAccessControl</h3><blockquote><p>注释：访问属性时自动解构</p></blockquote><p>两层判断：</p><ol><li>key 不是 <code>__ob__</code></li><li>传进来的不是一个「源对象(raw)」</li></ol><p>接着，通过 <code>Object.getOwnPropertyDescriptor</code> 获取一个变量，此举是为了限定在这个对象的这个元素，避免获取到整条原型链上的变量</p><p>所以可能某个 <code>key</code> 在这个对象上找不到，故变量没有值。如果有且这个属性可以被修改，缓存 <code>getter</code> 和 <code>setter</code>；</p><p>如果满足「不止有 <code>getter</code> 」和有两个参数（方法接收 target 和 key），给 <code>val</code> 赋值获取到的「元素」(<code>target[key]</code>)。然后把这个元素再过一遍 <a href="#setupAccessControl">setupAccessControl</a> 工作</p><p>接着，<strong>修改</strong>了这个属性，通过 <code>Object.defineProperty</code> —— 对多一层 <code>value</code> 做一层兼容</p><h3 id="observe">observe</h3><p>（终于到 observe 了…）</p><p>但 <code>observe</code> 逻辑非常简单 —— 能确定是 <code>vue2.6</code> (<code>Vue.observable</code>) 那么直接调用，否则做兼容</p><p>具体工作看 Vue2 源码</p><h3 id="shallowReactive">shallowReactive</h3><p>一个浅响应 <code>reactive</code> ，即只观察第一层的变化</p><p>方法中大篇幅与 <a href="#defineAccessControl">defineAccessControl</a> 相似，<code>getter</code> 与 <code>setter</code> 不同</p><p>而且传入 <code>setupAccessControl</code> 的参数也不同 —— 是一个 <code>Observe</code> 对象，进而导致第一层进入 <code>defineAccessControl</code> 之后第二层遍历时就会停下来，做到了只观察表面</p><p>接着再通过 <code>Object.defineProperty</code> 修改每一个属性到目的想实现的方式</p><h3 id="shallowReadonly">shallowReadonly</h3><p>与 <a href="#shallowReactive">shallowReactive</a> 类似，不过取消掉 <code>setter</code> 让属性无法赋值</p><h2 id="Helpers">Helpers</h2><p>同样跟 <code>reactive</code> 相关有一些辅助函数，但其他方法过于简单可以直接看文档，写一个</p><h3 id="toRaw">toRaw</h3><p>一个对象如果存在 <code>__ob__</code> 尝试返回其 <code>value</code>，否则返回整个对象（返回的对象跟 vue2 拿到的对象相同，所有属性被 <code>defineProperty</code> 处理过）</p><h2 id="阶段总结">阶段总结</h2><p>直到这里都有种读了个寂寞的感觉，主要都是在配合 vue2 原本的设计包装 componsition-api，例如 <code>__ob__</code></p><p>主要观察工作交给 <code>Vue.observe</code>，那么 <code>reactive</code> 就充当了原本 <code>data()</code> 的角色 —— 把一切属性都拆出来套上观察</p><p>下一次是，那些会「影响生命周期」的函数，特别是 <code>computed</code> 和 <code>watch</code></p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/isExtensible">Object.isExtensible</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor">Object.getOwnPropertyDescriptor</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/defineProperty">Object.defineProperty</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/12/08/vue2-composition-api-3/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>composition-api 插件 —— Ref</title>
      <link>https://colmugx.github.io/blog/2020/11/29/vue2-composition-api-2/</link>
      <guid>https://colmugx.github.io/blog/2020/11/29/vue2-composition-api-2/</guid>
      <pubDate>Sun, 29 Nov 2020 08:19:52 GMT</pubDate>
      
      <description>&lt;p&gt;书接上文：&lt;a href=&quot;/blog/2020/11/28/vue2-composition-api-1&quot;&gt;《composition-api 插件 —— install》&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;最常用 API 之一，创建响应式元素基本方法之一&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>书接上文：<a href="/blog/2020/11/28/vue2-composition-api-1">《composition-api 插件 —— install》</a></p><p>最常用 API 之一，创建响应式元素基本方法之一</p><a id="more"></a><h2 id="ref-function">ref(function)</h2><p>如果是 vue3 的实现，这里仅有 <code>createRef</code></p><p>但该插件的实现，首先验证入参是否已经是一个 <code>ref</code> ，如果是则不需要处理，如果不是则作为 <strong><code>reactive</code> 创建</strong>。然后执行 <code>createRef</code> 随之提供 <code>getter</code> 和 <code>setter</code> ，猜测背后是 <code>proxy</code></p><p><code>getter</code> 和 <code>setter</code> 非常常规：普通访问、普通赋值</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  get: <span class="function">() =&gt;</span> value[RefKey] <span class="keyword">as</span> any,</span><br><span class="line">  set: <span class="function">(<span class="params">v</span>) =&gt;</span> ((value[RefKey] <span class="keyword">as</span> any) = v),</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="createRef">createRef</h2><p>首先实例化 <code>RefImpl</code> ，这也是在实用中通过 console.log 能看到的东西</p><p>接着通过 <code>Object.seal</code> 「锁定」对象（实例也是 Object），此举是防止添加属性，也可以防止 <code>value</code> 属性被删掉</p><p>最后在 <code>readonlySet</code> 「注册」之后返回这个值，关于这个 set 大概会在 <code>reactive</code> 章提到（只有那边用到了）</p><h2 id="RefImpl">RefImpl</h2><p>仅为了参数创建一个 <code>proxy</code> 用于响应式，通过参数接收一对 <code>getter</code> 与 <code>setter</code>（例如 <a href="#ref-function">ref(function)</a>）</p><h2 id="Helpers">Helpers</h2><p><code>Ref</code> 提供了一些辅助函数，可能会让使用更加方便</p><h3 id="isRef">isRef</h3><p>判断参数是否是一个 <code>ref</code></p><h3 id="unref">unref</h3><p>对一个 <code>ref</code> 进行解构（直接获得 <code>value</code> ）</p><h3 id="toRefs">toRefs</h3><p>把 <code>reactive</code> 转换为一个个 <code>ref</code> 的辅助函数，所以首先会先确认是否是一个 <code>reactive</code>（编译后不会提示）</p><p>确认后，把这个对象依次使用 <code>toRef</code> 转换并返回</p><h3 id="customRef">customRef</h3><p>一个允许创建「自定义响应」的函数，接受一个「工厂函数」作为参数</p><p>内部实现采用一个「计数器」，并提供给工厂函数「获取」和「计数」的函数供以调用，并把这整个工厂函数作为 <code>createRef</code> 的参数</p><p>所以这个工厂函数<strong>必须</strong>要返回 <code>getter</code> 和 <code>setter</code> ，而且 <code>getter</code> 要调用工厂函数第一个参数函数，<code>setter</code> 要调用工厂函数第二个参数函数以触发计数器更新以触发响应</p><p>所以 <a target="_blank" rel="noopener" href="https://composition-api.vuejs.org/zh/api.html#customref">官方文档</a> 很有心的给这两个函数取名为 <code>track</code> 和 <code>trigger</code> 呢~~~~</p><h3 id="toRef">toRef</h3><p>刚刚 <code>toRefs</code> 用到这个方法，现在看一下怎么回事</p><p>首先，如果是 <code>ref</code> 那么直接返回</p><p>接着，同样使用 <code>createRef</code> 传递一对「普通」的赋值操作，与 <code>ref(function)</code> 一样，不同的只是 <code>toRef</code> 的来源是某个对象的单个属性</p><h3 id="shallowRef">shallowRef</h3><p>与 <code>ref</code> 和 <code>reactive</code> 的关系一样，这是一个与 <code>shallowReactive</code> 相对的方法，留在 <code>reactive</code> 篇章翻开</p><br /><p>所以下一篇：<code>reactive</code>。这个插件所有响应都交给 <code>reactive</code> 了</p><p><strong>「插件是如何模拟新特性」的答案即将水落石出</strong></p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/seal">Object.seal</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/29/vue2-composition-api-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>composition-api 插件 —— install</title>
      <link>https://colmugx.github.io/blog/2020/11/28/vue2-composition-api-1/</link>
      <guid>https://colmugx.github.io/blog/2020/11/28/vue2-composition-api-1/</guid>
      <pubDate>Sat, 28 Nov 2020 03:26:23 GMT</pubDate>
      
      <description>&lt;p&gt;composition-api 是一套诞生在 vue3 时代的提案，针对这份提案社区给出一份 vue2 支持新特性的插件。可以用于以适应新版本特性亦能使想给项目升级至 vue3 一次减少成本的机会&lt;/p&gt;
&lt;p&gt;通过插件的形式让 vue 2 使用 composition-api，不可避免的，因为是&lt;strong&gt;模拟而来的结果所以会造成一点性能损失&lt;/strong&gt;（README 已经提到性能问题）&lt;/p&gt;
&lt;p&gt;感觉东西比较多，所以分段写，剪短篇幅。这篇先写 &lt;code&gt;install&lt;/code&gt; 相关&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>composition-api 是一套诞生在 vue3 时代的提案，针对这份提案社区给出一份 vue2 支持新特性的插件。可以用于以适应新版本特性亦能使想给项目升级至 vue3 一次减少成本的机会</p><p>通过插件的形式让 vue 2 使用 composition-api，不可避免的，因为是<strong>模拟而来的结果所以会造成一点性能损失</strong>（README 已经提到性能问题）</p><p>感觉东西比较多，所以分段写，剪短篇幅。这篇先写 <code>install</code> 相关</p><a id="more"></a><p>vue2 版本的 composition-api 通过 vue 安装插件方式完成三件事情：</p><ol><li>给组件提供 <code>setup</code> 函数。通过 <code>optionMergeStrategies</code> 完成</li><li>做一份 vue 上下文缓存，运行时可用。经典操作：在无法通过内部(如 setup) 获取 <code>context</code> 时可以通过 <code>getCurrentInstance</code> 获得最新上下文</li><li>通过 <code>mixin</code> 修改组件行为</li></ol><h2 id="mixin">mixin</h2><p><code>mixin</code> 干涉了三个生命周期阶段： <code>beforeCreate</code> , <code>mounted</code> , <code>updated</code></p><h3 id="beforeCreate">beforeCreate</h3><p>首先执行 <code>render</code> ，执行前先「激活」缓存的示例，执行后还回去。目的应该是给组件提供「当时」的运行环境</p><p>接着验证 <code>setup</code> ，且 <code>setup</code> 是一个函数</p><p>最后修改 <code>data</code> 的行为：在执行 <code>data</code> 返回之前先初始化 setup（<code>initSetup</code>）。这其中做了一些关于 setup 方法的准备工作：常规的对 props 做响应式、更新 slot，还有执行了一次创建上下文的操作，其中处理过的 <code>props</code> 和 <code>context</code> 为将来 <code>setup</code> 的入参，提供到组件中使用。 <code>context</code> 中包含在 vue2 option-api 的 this 下那些属性，有所不同的是，他们通过 <code>forEach</code> 分别被套上了 <strong><code>proxy</code></strong></p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 节选：mixin.ts - L198</span></span><br><span class="line"><span class="keyword">const</span> props: <span class="built_in">Array</span>&lt;string | [string, string]&gt; = [</span><br><span class="line">  <span class="string">&#x27;root&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;parent&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;refs&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;attrs&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;listeners&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;isServer&#x27;</span>,</span><br><span class="line">  <span class="string">&#x27;ssrContext&#x27;</span>,</span><br><span class="line">]</span><br><span class="line">props.forEach(<span class="function">(<span class="params">key</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">let</span> targetKey: string</span><br><span class="line">  <span class="keyword">let</span> srcKey: string</span><br><span class="line">  <span class="keyword">if</span> (<span class="built_in">Array</span>.isArray(key)) &#123;</span><br><span class="line">    ;[targetKey, srcKey] = key</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    targetKey = srcKey = key</span><br><span class="line">  &#125;</span><br><span class="line">  srcKey = <span class="string">`$<span class="subst">$&#123;srcKey&#125;</span>`</span></span><br><span class="line">  proxy(ctx, targetKey, &#123;</span><br><span class="line">    get: <span class="function">() =&gt;</span> vm[srcKey],</span><br><span class="line">    set() &#123;</span><br><span class="line">      warn(</span><br><span class="line">        <span class="string">`Cannot assign to &#x27;<span class="subst">$&#123;targetKey&#125;</span>&#x27; because it is a read-only property`</span>,</span><br><span class="line">        vm</span><br><span class="line">      )</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>接着，执行 <code>setup</code> ，分成两种情况：返回值可以是函数或者对象。 <code>setup</code> 是可以返回函数的，例如文档中使用返回 JSX 举了例子：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; h, ref, reactive &#125; <span class="keyword">from</span> <span class="string">&#x27;vue&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> &#123;</span><br><span class="line">  setup() &#123;</span><br><span class="line">    <span class="keyword">const</span> count = ref(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">const</span> object = reactive(&#123; <span class="attr">foo</span>: <span class="string">&#x27;bar&#x27;</span> &#125;)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="function">() =&gt;</span> h(<span class="string">&#x27;div&#x27;</span>, [count.value, object.foo])</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而内部也使用与处理 <code>render</code> 函数一样的处理方式</p><p>而如果是一个对象会分几种情况处理：</p><ol><li>如果是方法，执行方法</li><li>广度优先查找含有响应元素，如果有，为其添加 vue2 响应方式</li><li>其他情况套上一层 <code>ref</code></li></ol><p>读到这可以发现，即使 vue2 插件也会开始使用新特性 <code>proxy</code> 了，即使用插件表明彻底放弃 IE</p><h3 id="mounted-updated">mounted &amp; updated</h3><p>这两个生命周期都运行同一个 <code>updateTemplateRef</code> 的函数，使得以在每次阶段更新时都能顺利的更新 <code>ref</code> 。因为 vue3 把 <code>ref</code> 的定义统一，这里通过阅读得知是更新 <code>template</code> 的 ref ，虽然函数名已经准确说明</p><br /><p>这个系列下一篇写其中一个基本的响应类型：<code>ref</code></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%BA%90%E7%A0%81%E9%98%85%E8%AF%BB/">源码阅读</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/28/vue2-composition-api-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>再一次重新设计简历</title>
      <link>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</link>
      <guid>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</guid>
      <pubDate>Wed, 11 Nov 2020 15:22:24 GMT</pubDate>
      
      <description>&lt;p&gt;最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，&lt;s&gt;不同的 HR&lt;/s&gt;&lt;br&gt;
于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。&lt;s&gt;（确认是追了个寂寞）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;但这不是本文重点，这里将要讲新的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 一同带来的新简历模板的设计思路&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Resumer&lt;/code&gt; 正在用 &lt;code&gt;Angular 10&lt;/code&gt; 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…&lt;/p&gt;
&lt;p&gt;所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resume&quot;&gt;Resume&lt;/a&gt;、&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 和 Resumer(ng version)&lt;/p&gt;
&lt;h2 id=&quot;请停止使用这种模板&quot;&gt;请停止使用这种模板&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><a id="more"></a><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>当时认为，前端工程师也是一门艺术，网页设计美感很重要</p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/">设计思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/Resumer/">Resumer</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我又不跨平台我为什么要 electron</title>
      <link>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</link>
      <guid>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</guid>
      <pubDate>Sat, 08 Aug 2020 09:24:29 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;无图版，会更有图版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;上篇文章（最近总是莫名联动）才写了 electron，主观感受，&lt;code&gt;electron&lt;/code&gt; 有这么些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得前端技术可以运用在本地桌面应用&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chromium&lt;/code&gt; 让兼容性不是首要考虑对象&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;NodeJS&lt;/code&gt; 既可以操作系统，也能利用本身能力与生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我好像不需要跨平台&lt;/li&gt;
&lt;li&gt;原生开发更加能操作系统 API&lt;/li&gt;
&lt;li&gt;扯破大天不就是&lt;code&gt;webview&lt;/code&gt;嘛&lt;/li&gt;
&lt;li&gt;依然不需要考虑兼容性，并且体积会大幅减小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，electron 再见！&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><a id="more"></a><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menubar = <span class="type">NSStatusBar</span>.system.statusItem(withLength: <span class="type">NSStatusItem</span>.variableLength)</span><br><span class="line"><span class="keyword">let</span> popover = <span class="type">NSPopover</span>()</span><br></pre></td></tr></table></figure><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if let 爽啊！</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> menuBtn = menubar.button &#123;</span><br><span class="line">   menuBtn.title = <span class="string">&quot;click&quot;</span></span><br><span class="line">   menuBtn.action = #selector(togglePopover)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到</span></span><br><span class="line"><span class="keyword">let</span> popoverController = <span class="type">NSStoryboard</span>(name: <span class="string">&quot;Main&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  .instantiateController(withIdentifier: <span class="string">&quot;PopoverViewController&quot;</span>) <span class="keyword">as</span>? <span class="type">PopoverViewController</span></span><br><span class="line"></span><br><span class="line">popover.behavior = .transient</span><br><span class="line">popover.contentViewController = popoverController</span><br></pre></td></tr></table></figure><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">togglePopover</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> popover.isShown &#123;</span><br><span class="line">        closePopover(sender)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        showPopover(sender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实本文其实用不到，先写着</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PopoverViewController</span>: <span class="title">WKNavigationDelegate</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview.navigationDelegate = <span class="keyword">self</span></span><br><span class="line"><span class="comment">// 通过 userContentController 获取 webview 中的事件</span></span><br><span class="line"><span class="keyword">let</span> contentController = webview.configuration.userContentController</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义与前端交互的方法名</span></span><br><span class="line">contentController.add(<span class="keyword">self</span>, name: <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pagePath = <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;index&quot;</span>, withExtension: <span class="string">&quot;html&quot;</span>, subdirectory: <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="comment">// let devUrl = URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// load 方式也不同，一种是加载文件，一种直接加载 url</span></span><br><span class="line">webview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())</span><br><span class="line"><span class="comment">// webview.load(devUrl)</span></span><br></pre></td></tr></table></figure><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PopoverViewController</span>: <span class="title">WKScriptMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> message.name == <span class="string">&quot;hello&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转</span></span><br><span class="line">            <span class="keyword">let</span> body = (message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里完全可以通过 switch 做模式匹配，不过这里没有</span></span><br><span class="line">            <span class="keyword">if</span> (body[<span class="string">&quot;type&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span>) == <span class="string">&quot;notify&quot;</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> value: <span class="type">String</span> = (message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;)[<span class="string">&quot;value&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">              showNotification(title: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用通知 api，显示通知</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNotification</span><span class="params">(title: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> notification = <span class="type">NSUserNotification</span>()</span><br><span class="line"></span><br><span class="line">        notification.deliveryDate = <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">1</span>)</span><br><span class="line">        notification.title = title</span><br><span class="line"></span><br><span class="line">        <span class="type">NSUserNotificationCenter</span>.<span class="keyword">default</span>.deliver(notification)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击按钮弹出通知</span></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.webkit.messageHandlers.hello.postMessage(&#123;<span class="attr">type</span>: <span class="string">&#x27;notify&#x27;</span>, <span class="attr">value</span>: <span class="string">&quot;Hello World&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 electron 爬图片</title>
      <link>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</link>
      <guid>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</guid>
      <pubDate>Sun, 21 Jun 2020 03:51:10 GMT</pubDate>
      
      <description>&lt;p&gt;有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了&lt;br&gt;
&lt;strong&gt;（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想了一下，切图仔唯一高效 GUI 的选型只有 &lt;code&gt;electron&lt;/code&gt; 了，没得选。但是这次有点特别，因为 &lt;code&gt;electron&lt;/code&gt; 的特殊性，我有了些想法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用的模板是之前实验服务一体化的模板 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/electron-react-koa-template&quot;&gt;electron-react-koa-template&lt;/a&gt;，然后删除了&lt;code&gt;server&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;删了&lt;code&gt;server&lt;/code&gt;……&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;webview&lt;/li&gt;
&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;提供下载&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><a id="more"></a><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">&#x27;webview&#x27;</span>)</span><br><span class="line"><span class="comment">// 当页面加载完成之后会触发这个事件，可以继续做接下来的事情</span></span><br><span class="line">webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>于是封装一下变成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">&#x27;webview&#x27;</span>)</span><br><span class="line">  <span class="comment">// 保险起见</span></span><br><span class="line">  webview.useragent</span><br><span class="line">    = <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) &#x27;</span></span><br><span class="line">    + <span class="string">&#x27;AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">    + <span class="string">&#x27;Chrome/81.0.4044.129 Safari/537.36 Edg/81.0.416.68&#x27;</span></span><br><span class="line">  webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(webview)</span><br><span class="line">  <span class="built_in">this</span>.webview = webview</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search(url) &#123;</span><br><span class="line">  <span class="built_in">this</span>.webview.src = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">    webviewTag: <span class="literal">true</span>,</span><br><span class="line">    nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function">(<span class="params">html</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">    ipcRenderer.send(<span class="string">&#x27;ganhuo&#x27;</span>, html)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">&#x27;ganhuo&#x27;</span>, <span class="function">(<span class="params">e, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(arg)</span><br><span class="line">  <span class="comment">// 各种教程都能看到的</span></span><br><span class="line">  <span class="comment">// 这里没多余操作，是个 img 就拿走</span></span><br><span class="line">  <span class="comment">// 接着 reply 回 renderer</span></span><br><span class="line">  <span class="keyword">const</span> imgs = $(<span class="string">&#x27;body&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).map(<span class="function">(<span class="params">idx, ele</span>) =&gt;</span> $(ele).attr(<span class="string">&#x27;src&#x27;</span>)).get()</span><br><span class="line">  e.reply(<span class="string">&#x27;chuhuo&#x27;</span>, imgs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>renderer</code> 边准备一个接收，这波结束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  ipcRenderer.on(<span class="string">&#x27;chuhuo&#x27;</span>, <span class="function">(<span class="params">e, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      imgs: result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/electron/">electron</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/21/electron-crawler/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>整一个家庭服务器记录</title>
      <link>https://colmugx.github.io/blog/2020/06/07/home-server/</link>
      <guid>https://colmugx.github.io/blog/2020/06/07/home-server/</guid>
      <pubDate>Sun, 07 Jun 2020 05:57:46 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！&lt;/p&gt;
&lt;h3 id=&quot;系统选择&quot;&gt;系统选择&lt;/h3&gt;
&lt;p&gt;推荐三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot;&gt;raspbian&lt;/a&gt;（树莓派）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://clearlinux.org/&quot;&gt;clear linux&lt;/a&gt;（英特尔CPU）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.debian.org/index.zh-cn.html&quot;&gt;debian&lt;/a&gt;（传统服务器系统）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><a id="more"></a><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%95%B4%E7%82%B9%E8%8A%B1%E6%B4%BB/">整点花活</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2020/06/07/home-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</link>
      <guid>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</guid>
      <pubDate>Thu, 04 Jun 2020 14:30:36 GMT</pubDate>
      
      <description>&lt;p&gt;这应该是连载得最近的一次，书接上回：&lt;a href=&quot;/blog/2020/06/02/hammerspoon-ts/&quot;&gt;《或许可以用 TypeScript 编写 hammerspoon》&lt;/a&gt;（也就是下面那篇）&lt;/p&gt;
&lt;p&gt;这里只会描述通过 &lt;code&gt;TypeScript&lt;/code&gt; 实现的过程&lt;/p&gt;
&lt;p&gt;以下内容可能产生不适（因为&lt;code&gt;hammerspoon&lt;/code&gt;的 &lt;code&gt;d.ts&lt;/code&gt; 全是 &lt;code&gt;interface&lt;/code&gt; 一把梭，编码不好看）&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建界面&lt;/li&gt;
&lt;li&gt;实现剪贴板读取&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;绑定快捷键&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><a id="more"></a><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容</span></span><br><span class="line"><span class="keyword">const</span> completionFn = <span class="function"><span class="params">choice</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一般来说这个判断不可省略，这样可以方便排除取消的情况</span></span><br><span class="line">  <span class="keyword">if</span> (choice) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> chooser = hs.chooser.new(completionFn)</span><br></pre></td></tr></table></figure><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chooser.show()</span><br><span class="line">chooser.hide()</span><br></pre></td></tr></table></figure><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.readString() <span class="comment">// 读取最后一次剪贴板的文本</span></span><br><span class="line">pasteboard.readImage() <span class="comment">// 读取最后一次剪贴板的图片数据</span></span><br></pre></td></tr></table></figure><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.changeCount()</span><br></pre></td></tr></table></figure><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboard = <span class="keyword">new</span> Clipboard()</span><br><span class="line"><span class="comment">// 我选择 1s 检查一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clipWatcher = hs.timer.new(<span class="number">1</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> now = hs.pasteboard.changeCount()</span><br><span class="line">  <span class="keyword">if</span> (now !== preCount) &#123;</span><br><span class="line">    pcall(clipboard.save.bind(clipboard))</span><br><span class="line">    preCount = now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">clipWatcher.start()</span><br></pre></td></tr></table></figure><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">save() &#123;</span><br><span class="line">  <span class="keyword">const</span> types = hs.pasteboard.contentTypes&lt;ModelChoice[<span class="string">&#x27;type&#x27;</span>]&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">type</span> <span class="keyword">of</span> types) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isImgType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.saveImage(<span class="keyword">type</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTextType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.saveText(<span class="keyword">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(clipboardConf.hotkey[<span class="number">0</span>], clipboardConf.hotkey[<span class="number">1</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  clipboard.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.chooser!.choices(choices)</span><br><span class="line"><span class="built_in">this</span>.chooser!.show()</span><br></pre></td></tr></table></figure><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</link>
      <guid>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</guid>
      <pubDate>Tue, 02 Jun 2020 14:59:20 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;lua&lt;/code&gt; 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 &lt;code&gt;cocos2d&lt;/code&gt; 的时候，就接触了这个语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hammerspoon&lt;/code&gt; 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整&lt;/p&gt;
&lt;p&gt;早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了&lt;/p&gt;
&lt;p&gt;当然还有其他方案，比如常见的用到了 &lt;code&gt;moonscript&lt;/code&gt;，这是一个类 &lt;code&gt;coffeescript&lt;/code&gt; 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境&lt;/p&gt;
&lt;p&gt;前些日子关注到有一个项目 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/TypeScriptToLua/TypeScriptToLua&quot;&gt;TypeScriptToLua / TypeScriptToLua&lt;/a&gt;，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><a id="more"></a><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">yarn add typescript-to-lua --dev</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;tstl --watch&quot;,</span><br><span class="line">&quot;build&quot;: &quot;tstl&quot;</span><br></pre></td></tr></table></figure><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>docker 容器内通信</title>
      <link>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</link>
      <guid>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</guid>
      <pubDate>Sun, 29 Mar 2020 10:00:28 GMT</pubDate>
      
      <description>&lt;p&gt;除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud&lt;/p&gt;
&lt;p&gt;最后整了一个本地 webdav 😆&lt;/p&gt;
&lt;p&gt;当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云&lt;/p&gt;
&lt;p&gt;docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了&lt;/p&gt;
&lt;p&gt;**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的&lt;/p&gt;
&lt;p&gt;所以，水一篇文，单纯记录一下&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br></pre></td></tr></table></figure><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network my_bridge [...]</span><br></pre></td></tr></table></figure><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/docker/">docker</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 Context 传递多语言文本</title>
      <link>https://colmugx.github.io/blog/2020/01/31/react-translate/</link>
      <guid>https://colmugx.github.io/blog/2020/01/31/react-translate/</guid>
      <pubDate>Fri, 31 Jan 2020 06:38:39 GMT</pubDate>
      
      <description>&lt;p&gt;Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…&lt;/p&gt;
&lt;p&gt;找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上&lt;code&gt;react-intl&lt;/code&gt;，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个&lt;/p&gt;
&lt;p&gt;但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 &lt;code&gt;gatsby-plugin-i18n&lt;/code&gt; 或者 &lt;code&gt;react-intl&lt;/code&gt; 就可以了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><a id="more"></a><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> langContext = createContext(&#123;&#125; <span class="keyword">as</span> ContextInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文后输出 Provider 和 Consumer 还是要的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = langContext.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = langContext.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps: 其实 Consumer 用不上...</span></span><br></pre></td></tr></table></figure><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> genTranslate = <span class="function">(<span class="params">lang: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _message = <span class="built_in">require</span>(<span class="string">`@/lang/<span class="subst">$&#123;lang&#125;</span>.json`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_message) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;lang&#125;</span> language json was not found.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatMessage = (&#123; id, defaultMsg &#125;: FormatMessageType): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="comment">// _get 来自 lodash</span></span><br><span class="line">    _get(_message, id) || defaultMsg || <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatter = <span class="function">() =&gt;</span> (&#123; formatMessage, _message &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> formatter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useIntl = (): <span class="function"><span class="params">ContextInterface</span> =&gt;</span> useContext(langContext)</span><br></pre></td></tr></table></figure><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; formatMessage: t &#125; = useIntl()</span><br></pre></td></tr></table></figure><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/">前端实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/01/31/react-translate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>创建一个 rust web server</title>
      <link>https://colmugx.github.io/blog/2019/12/29/try-actix/</link>
      <guid>https://colmugx.github.io/blog/2019/12/29/try-actix/</guid>
      <pubDate>Sun, 29 Dec 2019 04:29:34 GMT</pubDate>
      
      <description>&lt;p&gt;玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 &lt;code&gt;perfect&lt;/code&gt; 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。&lt;br&gt;
rust 社区中关注了 &lt;code&gt;rocket&lt;/code&gt; 一段时间，后面发现 &lt;code&gt;actix-web&lt;/code&gt; 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。&lt;/p&gt;
&lt;p&gt;这里会以重构我的闹钟后端作为蓝本，逐步做个记录。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;直接用 &lt;code&gt;cargo&lt;/code&gt; 创建应用&lt;/li&gt;
&lt;li&gt;装载 &lt;code&gt;actix-web&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写一个 api&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><a id="more"></a><h2 id="创建应用">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"><span class="attr">actix-rt</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="attr">dotenv</span> = <span class="string">&quot;0.15.0&quot;</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.8&quot;</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.7.1&quot;</span></span><br></pre></td></tr></table></figure><p>然后在<code>main.rs</code>创建启动函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;App, HttpServer, get&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; HttpResponse &#123;</span><br><span class="line">    HttpResponse::<span class="literal">Ok</span>().body(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> app = || App::new().service(index);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;serving on localhost:7001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(<span class="string">&quot;localhost:7001&quot;</span>)?</span><br><span class="line">        .run()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">| +-- controller</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- services</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- models</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- middleware</span><br><span class="line">| | +-- mod.rs</span><br></pre></td></tr></table></figure><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># serde</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0.104&quot;</span></span><br><span class="line"><span class="attr">serde_derive</span> = <span class="string">&quot;1.0.104&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.44&quot;</span></span><br><span class="line"><span class="attr">json</span> = <span class="string">&quot;0.12.0&quot;</span></span><br></pre></td></tr></table></figure><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_derive::&#123;Serialize, Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Payload</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> code: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> message: <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[serde(skip_serializing_if = <span class="meta-string">&quot;Option::is_none&quot;</span>, default)]</span></span><br><span class="line">    <span class="keyword">pub</span> payload: <span class="built_in">Option</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，从<code>controller/index</code>开始</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span> &#123;</span><br><span class="line">    message: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>(query: web::Query&lt;Info&gt;) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Query拿到与 Info 结构一样的参数</span></span><br><span class="line">    <span class="comment">// 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理</span></span><br><span class="line">    <span class="comment">// rust 真严格..</span></span><br><span class="line">    <span class="keyword">let</span> result = crate::services::index::get_helloworld(query.message.clone());</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(HttpResponse::<span class="literal">Ok</span>().json(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::models::payload::Payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单写一个服务</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_helloworld</span></span>(msg: <span class="built_in">String</span>) -&gt; Payload&lt;()&gt; &#123;</span><br><span class="line">    Payload &#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        message: msg.to_string(),</span><br><span class="line">        payload: <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后改一下<code>main.rs</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+mod controllers;</span></span><br><span class="line"><span class="addition">+mod models;</span></span><br><span class="line"><span class="addition">+mod services;</span></span><br><span class="line"></span><br><span class="line">#[actix_rt::main]</span><br><span class="line">async fn main() -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let app = || App::new()</span><br><span class="line"><span class="deletion">-        .service(index);</span></span><br><span class="line"><span class="addition">+        .service(controllers::index::index);</span></span><br><span class="line"></span><br><span class="line">    info!(&quot;serving on localhost:7001&quot;);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(&quot;localhost:7001&quot;)?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br></pre></td></tr></table></figure><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/">服务实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/actix/">actix</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/12/29/try-actix/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如果我把 Rust 用在网页呢</title>
      <link>https://colmugx.github.io/blog/2019/10/13/try-wasm/</link>
      <guid>https://colmugx.github.io/blog/2019/10/13/try-wasm/</guid>
      <pubDate>Sun, 13 Oct 2019 15:47:21 GMT</pubDate>
      
      <description>&lt;p&gt;已知&lt;code&gt;Rust&lt;/code&gt;是个很硬核的编程语言&lt;/p&gt;
&lt;p&gt;又已知&lt;code&gt;JavaScript&lt;/code&gt;或者说在浏览器上的&lt;code&gt;JavaScript&lt;/code&gt;在某种情况无法胜任工作。&lt;/p&gt;
&lt;p&gt;So？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🦀 Rust + 🕸 Wasm = ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情&lt;/p&gt;
&lt;p&gt;那么前提是，你已经弄清楚了 &lt;code&gt;wasm-pack&lt;/code&gt; 是怎么回事了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了</p><a id="more"></a><h2 id="题干？">题干？</h2><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h2 id="板条箱？">板条箱？</h2><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/DaGenix/rust-crypto">DaGenix/rust-crypto</a></li><li><a target="_blank" rel="noopener" href="https://github.com/RustCrypto">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buttercup/rust-crypto-wasm">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h2 id="创建？">创建？</h2><blockquote><p>&gt; cargo generate --git <a target="_blank" rel="noopener" href="https://github.com/rustwasm/wasm-pack-template">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">wasm-bindgen</span> = <span class="string">&quot;0.2&quot;</span> <span class="comment"># 核心</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.7.2&quot;</span> <span class="comment"># 但接下来用不上</span></span><br><span class="line"><span class="attr">aes</span> = <span class="string">&quot;0.3.2&quot;</span> <span class="comment"># 添加这个只是为了分组依赖与类型</span></span><br><span class="line"><span class="attr">cfb-mode</span> = <span class="string">&quot;0.3.2&quot;</span> <span class="comment"># 这个才是加密核心</span></span><br></pre></td></tr></table></figure><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h2 id="食用？">食用？</h2><h3 id="编译源码">编译源码</h3><ol><li>加载 crate（上板条！）</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> aes;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cfb_mode;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明依赖，或者说<code>import</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> aes::Aes256; <span class="comment">// 使用 256</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; <span class="comment">// cfb是基于流加密其中一种</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::Cfb; <span class="comment">// 需要用这个结构体</span></span><br></pre></td></tr></table></figure><ol start="3"><li>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AesCfb</span></span> = Cfb&lt;Aes256&gt;;</span><br></pre></td></tr></table></figure><ol start="4"><li>随便写个加密</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key: &amp;[<span class="built_in">u8</span>; <span class="number">32</span>] = <span class="string">b&quot;nashizhendeniup,,nashizhendeniup&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> iv: &amp;[<span class="built_in">u8</span>; <span class="number">16</span>]  = <span class="string">b&quot;unique,un,unique&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;那你是真的牛皮&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> buffer = msg.as_bytes().to_vec();</span><br><span class="line"></span><br><span class="line">  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;<span class="keyword">mut</span> buffer);</span><br><span class="line"></span><br><span class="line">  buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="到前端使用">到前端使用</h3><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx&gt;.wasm</li><li>&lt;xxx&gt;.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>&gt; npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">&#x27;crypto-test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</span><br></pre></td></tr></table></figure><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)</span><br><span class="line">(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)</span><br><span class="line">(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)</span><br><span class="line">  i32.const 1056732</span><br><span class="line">  get_local $p0</span><br></pre></td></tr></table></figure><p>看得我都有女装的冲动了（大雾</p><h2 id="结束？">结束？</h2><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h2 id="（附加资料）加密？">（附加资料）加密？</h2><h3 id="分组密码">分组密码</h3><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h3 id="AES">AES</h3><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h4 id="iv">iv?</h4><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h4 id="key">key?</h4><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h4 id="padding">padding?</h4><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h3 id="AES256-128">AES256? 128?</h3><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h3 id="AES256CFB">AES256CFB?</h3><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/">前端实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/10/13/try-wasm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（一） —— Vapor</title>
      <link>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</link>
      <guid>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</guid>
      <pubDate>Sun, 23 Jun 2019 08:17:53 GMT</pubDate>
      
      <description>&lt;p&gt;Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”&lt;/p&gt;
&lt;p&gt;所以，直接干吧&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧</p><a id="more"></a><h2 id="安装">安装</h2><p>直接装个工具集吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap vapor&#x2F;tap</span><br><span class="line">brew install vapor&#x2F;tap&#x2F;vapor</span><br></pre></td></tr></table></figure><h2 id="生成应用">生成应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor new Hello</span><br></pre></td></tr></table></figure><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;Hello</span><br><span class="line">vapor xcode</span><br></pre></td></tr></table></figure><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h2 id="编写体验">编写体验</h2><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DirectoryConfig.detect().workDir 项目绝对路径</span></span><br><span class="line"><span class="keyword">let</span> storePath = <span class="type">DirectoryConfig</span>.detect().workDir + <span class="string">&quot;Db/store.db&quot;</span></span><br><span class="line"><span class="keyword">let</span> sqlite = <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>(storage: .file(path: storePath))</span><br></pre></td></tr></table></figure><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h2 id="相关信息">相关信息</h2><p>Vapor 自己提供一个<a target="_blank" rel="noopener" href="http://vapor.university/">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/">服务实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（零） —— Perfect</title>
      <link>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</link>
      <guid>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</guid>
      <pubDate>Fri, 07 Jun 2019 08:39:39 GMT</pubDate>
      
      <description>&lt;p&gt;因为不可抗力没上班，看着新&lt;code&gt;swift&lt;/code&gt;和&lt;code&gt;swiftUI&lt;/code&gt;发布，决定搞&lt;code&gt;Perfect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）&lt;/p&gt;
&lt;p&gt;篇幅不长，仅做一个尝试和介绍，原因在最后。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装还是相当容易，官方编译器起一个可执行类型项目&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;swift package &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; --type=executable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h2 id="安装">安装</h2><p>安装还是相当容易，官方编译器起一个可执行类型项目</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package <span class="keyword">init</span> --type=executable</span><br></pre></td></tr></table></figure><a id="more"></a><p>其次，在<code>Package.swift</code>中添加依赖</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies: [</span><br><span class="line">    .package(url: <span class="string">&quot;https://github.com/PerfectlySoft/Perfect-HTTPServer.git&quot;</span>, from: <span class="string">&quot;3.0.0&quot;</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接着，编译即安装依赖（熟悉啊！）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br></pre></td></tr></table></figure><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h2 id="编写体验">编写体验</h2><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><s>后来发现，我好像用不上</s></p><p>按照习惯创建了一个结构体用来存放配置内容</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GlobalConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> baseRoute = <span class="string">&quot;/api/v1&quot;</span></span><br><span class="line">    <span class="keyword">let</span> httpPort = <span class="number">8081</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectHTTP</span><br><span class="line"><span class="keyword">import</span> PerfectHTTPServer</span><br><span class="line"><span class="comment">// 字典不是JSON，使用库中方法得以把字典转为JSON</span></span><br><span class="line"><span class="keyword">import</span> PerfectLib</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="type">GlobalConfig</span>()</span><br><span class="line"><span class="keyword">let</span> server = <span class="type">HTTPServer</span>()</span><br><span class="line"><span class="keyword">var</span> routes = <span class="type">Routes</span>(baseUri: config.baseRoute)</span><br></pre></td></tr></table></figure><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: [[<span class="type">String</span>: <span class="type">Any</span>]] = [</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;index&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;show&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;create&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.post],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;update&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.put],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.delete]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RoutesConfig</span>().list.<span class="built_in">map</span> &#123;</span><br><span class="line">    routes.add(method: $<span class="number">0</span>[<span class="string">&quot;method&quot;</span>] <span class="keyword">as</span>! <span class="type">HTTPMethod</span>, uri: $<span class="number">0</span>[<span class="string">&quot;url&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span>, handler: &#123; (request, response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> json: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">&quot;code&quot;</span>: <span class="number">0</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>]</span><br><span class="line">        <span class="keyword">let</span> variables = request.urlVariables</span><br><span class="line">        <span class="keyword">var</span> newJson = json</span><br><span class="line">        <span class="keyword">if</span> (!variables.isEmpty) &#123;</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> variables &#123;</span><br><span class="line">                newJson[e.key] = variables[e.key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">try</span>! newJson   <span class="comment">// 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）</span></span><br><span class="line">            .jsonEncodedString()</span><br><span class="line">        response</span><br><span class="line">            .setHeader(.contentType, value: <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">            .appendBody(string: output)</span><br><span class="line">            .completed()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.addRoutes(routes)</span><br><span class="line">server.serverPort = <span class="type">UInt16</span>(config.httpPort)</span><br></pre></td></tr></table></figure><p>最后（简单）执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> server.start()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;\(error)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原因">原因</h2><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/">服务实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>react函数级写法和继承写法有什么区别？</title>
      <link>https://colmugx.github.io/blog/2019/05/28/react-component-method/</link>
      <guid>https://colmugx.github.io/blog/2019/05/28/react-component-method/</guid>
      <pubDate>Tue, 28 May 2019 15:48:21 GMT</pubDate>
      
      <description>&lt;p&gt;这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的&lt;code&gt;react 0.x&lt;/code&gt;时代，于是我默默把想法干掉了。&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;createClass&lt;/code&gt;和&lt;code&gt;extends React.Component&lt;/code&gt;，还有点意思。如果是&lt;code&gt;functional component&lt;/code&gt;，那您怎么不用同样很「渐进式」同时又更牛逼的&lt;code&gt;vue&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;简单对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;createClass&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Component/PureComponent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;propTypes/getDefaultProp&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Component.defaultProps/Component.propType&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;this 已被指定&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;属性 this 不默认指向组件（实例）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin（被取消，不建议，做不到，HOC）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对我来说，这两个的区别可能&lt;code&gt;mixin&lt;/code&gt;最有意思&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思</p><a id="more"></a><h2 id="编写风格">编写风格</h2><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h2 id="default-props">default props</h2><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h2 id="this">this</h2><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h2 id="mixin">mixin</h2><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<s>与复读</s>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/05/28/react-component-method/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>defineProperty? Proxy?</title>
      <link>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</link>
      <guid>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</guid>
      <pubDate>Sat, 20 Apr 2019 04:47:12 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;听说 Vue3 数据绑定要切换到 Proxy，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是这篇文章的原因，来源于某个牛逼公司的面试。&lt;s&gt;我真的应该学会怎么清楚表达观点…&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defineProperty&lt;/code&gt; 和 &lt;code&gt;Proxy&lt;/code&gt; 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;defineProperty&quot;&gt;defineProperty&lt;/h2&gt;
&lt;p&gt;这是一个 &lt;code&gt;ES5&lt;/code&gt; 的方法。一个 &lt;code&gt;defineProperty&lt;/code&gt; 需要三个参数，都是 &lt;code&gt;require&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<s>我真的应该学会怎么清楚表达观点…</s></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h2 id="defineProperty">defineProperty</h2><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code></p><a id="more"></a><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;colmugx&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h2 id="Proxy">Proxy</h2><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="？">？</h2><h3 id="数据拦截">数据拦截</h3><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">key</span>: <span class="literal">undefined</span>&#125;, &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="comment">// 由于代理了所有操作，那么返回 404 纯属意愿</span></span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="string">&#x27;404 Not Found&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    target[prop] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h3 id="只需要-defineProperty？怎么可能？">只需要 defineProperty？怎么可能？</h3><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h3 id="为什么-Proxy？">为什么 Proxy？</h3><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">这个问题</a>，解决这个问题的方法有点骚，<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="string">&#x27;???&#x27;</span> &#125;&#125;&#125;&#125;&#125;  <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  apply(target, context, args) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h3 id="补充">补充</h3><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h2 id="为什么-Vue2-不直接用-Proxy">为什么 Vue2 不直接用 Proxy</h2><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h2 id="Vue-React">Vue &amp; React</h2><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
