<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    
    <image>
      <url>https://avatars2.githubusercontent.com/u/21327913?v=3&amp;s=466</url>
      <title>Colmugx &#39;s Blog</title>
      <link>https://colmugx.github.io/blog/</link>
    </image>
    
    <atom:link href="https://colmugx.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Sun, 15 Nov 2020 16:06:46 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>再一次重新设计简历</title>
      <link>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</link>
      <guid>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</guid>
      <pubDate>Wed, 11 Nov 2020 15:22:24 GMT</pubDate>
      
      <description>&lt;p&gt;最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，&lt;s&gt;不同的 HR&lt;/s&gt;&lt;br&gt;
于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。&lt;s&gt;（确认是追了个寂寞）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;但这不是本文重点，这里将要讲新的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 一同带来的新简历模板的设计思路&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Resumer&lt;/code&gt; 正在用 &lt;code&gt;Angular 10&lt;/code&gt; 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…&lt;/p&gt;
&lt;p&gt;所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resume&quot;&gt;Resume&lt;/a&gt;、&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 和 Resumer(ng version)&lt;/p&gt;
&lt;h2 id=&quot;请停止使用这种模板&quot;&gt;请停止使用这种模板&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><a id="more"></a><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>当时认为，前端工程师也是一门艺术，网页设计美感很重要</p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/">设计思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/Resumer/">Resumer</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我又不跨平台我为什么要 electron</title>
      <link>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</link>
      <guid>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</guid>
      <pubDate>Sat, 08 Aug 2020 09:24:29 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;无图版，会更有图版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;上篇文章（最近总是莫名联动）才写了 electron，主观感受，&lt;code&gt;electron&lt;/code&gt; 有这么些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得前端技术可以运用在本地桌面应用&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chromium&lt;/code&gt; 让兼容性不是首要考虑对象&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;NodeJS&lt;/code&gt; 既可以操作系统，也能利用本身能力与生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我好像不需要跨平台&lt;/li&gt;
&lt;li&gt;原生开发更加能操作系统 API&lt;/li&gt;
&lt;li&gt;扯破大天不就是&lt;code&gt;webview&lt;/code&gt;嘛&lt;/li&gt;
&lt;li&gt;依然不需要考虑兼容性，并且体积会大幅减小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，electron 再见！&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><a id="more"></a><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> menubar = <span class="type">NSStatusBar</span>.system.statusItem(withLength: <span class="type">NSStatusItem</span>.variableLength)</span><br><span class="line"><span class="keyword">let</span> popover = <span class="type">NSPopover</span>()</span><br></pre></td></tr></table></figure><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// if let 爽啊！</span></span><br><span class="line"><span class="keyword">if</span> <span class="keyword">let</span> menuBtn = menubar.button &#123;</span><br><span class="line">   menuBtn.title = <span class="string">&quot;click&quot;</span></span><br><span class="line">   menuBtn.action = #selector(togglePopover)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到</span></span><br><span class="line"><span class="keyword">let</span> popoverController = <span class="type">NSStoryboard</span>(name: <span class="string">&quot;Main&quot;</span>, bundle: <span class="literal">nil</span>)</span><br><span class="line">  .instantiateController(withIdentifier: <span class="string">&quot;PopoverViewController&quot;</span>) <span class="keyword">as</span>? <span class="type">PopoverViewController</span></span><br><span class="line"></span><br><span class="line">popover.behavior = .transient</span><br><span class="line">popover.contentViewController = popoverController</span><br></pre></td></tr></table></figure><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@objc</span> <span class="function"><span class="keyword">func</span> <span class="title">togglePopover</span><span class="params">(<span class="number">_</span> sender: AnyObject)</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> popover.isShown &#123;</span><br><span class="line">        closePopover(sender)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        showPopover(sender)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 其实本文其实用不到，先写着</span></span><br><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PopoverViewController</span>: <span class="title">WKNavigationDelegate</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview.navigationDelegate = <span class="keyword">self</span></span><br><span class="line"><span class="comment">// 通过 userContentController 获取 webview 中的事件</span></span><br><span class="line"><span class="keyword">let</span> contentController = webview.configuration.userContentController</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义与前端交互的方法名</span></span><br><span class="line">contentController.add(<span class="keyword">self</span>, name: <span class="string">&quot;hello&quot;</span>)</span><br></pre></td></tr></table></figure><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> pagePath = <span class="type">Bundle</span>.main.url(forResource: <span class="string">&quot;index&quot;</span>, withExtension: <span class="string">&quot;html&quot;</span>, subdirectory: <span class="string">&quot;build&quot;</span>)</span><br><span class="line"><span class="comment">// let devUrl = URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// load 方式也不同，一种是加载文件，一种直接加载 url</span></span><br><span class="line">webview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())</span><br><span class="line"><span class="comment">// webview.load(devUrl)</span></span><br></pre></td></tr></table></figure><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">extension</span> <span class="title">PopoverViewController</span>: <span class="title">WKScriptMessageHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">userContentController</span><span class="params">(<span class="number">_</span> userContentController: WKUserContentController, didReceive message: WKScriptMessage)</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> message.name == <span class="string">&quot;hello&quot;</span> &#123;</span><br><span class="line">            <span class="comment">// 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转</span></span><br><span class="line">            <span class="keyword">let</span> body = (message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;)</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里完全可以通过 switch 做模式匹配，不过这里没有</span></span><br><span class="line">            <span class="keyword">if</span> (body[<span class="string">&quot;type&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span>) == <span class="string">&quot;notify&quot;</span> &#123;</span><br><span class="line">              <span class="keyword">let</span> value: <span class="type">String</span> = (message.body <span class="keyword">as</span>! <span class="type">Dictionary</span>&lt;<span class="type">String</span>, <span class="type">Any</span>&gt;)[<span class="string">&quot;value&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span></span><br><span class="line">              showNotification(title: value)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 调用通知 api，显示通知</span></span><br><span class="line">    <span class="function"><span class="keyword">func</span> <span class="title">showNotification</span><span class="params">(title: String)</span></span> &#123;</span><br><span class="line">        <span class="keyword">let</span> notification = <span class="type">NSUserNotification</span>()</span><br><span class="line"></span><br><span class="line">        notification.deliveryDate = <span class="type">Date</span>(timeIntervalSinceNow: <span class="number">1</span>)</span><br><span class="line">        notification.title = title</span><br><span class="line"></span><br><span class="line">        <span class="type">NSUserNotificationCenter</span>.<span class="keyword">default</span>.deliver(notification)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 点击按钮弹出通知</span></span><br><span class="line"><span class="keyword">const</span> handleClick = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">window</span>.webkit.messageHandlers.hello.postMessage(&#123;<span class="attr">type</span>: <span class="string">&#x27;notify&#x27;</span>, <span class="attr">value</span>: <span class="string">&quot;Hello World&quot;</span>&#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%8E%A9%E5%85%B7%E5%88%B6%E9%80%A0/">玩具制造</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 electron 爬图片</title>
      <link>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</link>
      <guid>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</guid>
      <pubDate>Sun, 21 Jun 2020 03:51:10 GMT</pubDate>
      
      <description>&lt;p&gt;有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了&lt;br&gt;
&lt;strong&gt;（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想了一下，切图仔唯一高效 GUI 的选型只有 &lt;code&gt;electron&lt;/code&gt; 了，没得选。但是这次有点特别，因为 &lt;code&gt;electron&lt;/code&gt; 的特殊性，我有了些想法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用的模板是之前实验服务一体化的模板 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/electron-react-koa-template&quot;&gt;electron-react-koa-template&lt;/a&gt;，然后删除了&lt;code&gt;server&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;删了&lt;code&gt;server&lt;/code&gt;……&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;webview&lt;/li&gt;
&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;提供下载&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><a id="more"></a><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">&#x27;webview&#x27;</span>)</span><br><span class="line"><span class="comment">// 当页面加载完成之后会触发这个事件，可以继续做接下来的事情</span></span><br><span class="line">webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure><p>于是封装一下变成</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  <span class="keyword">const</span> webview = <span class="built_in">document</span>.createElement(<span class="string">&#x27;webview&#x27;</span>)</span><br><span class="line">  <span class="comment">// 保险起见</span></span><br><span class="line">  webview.useragent</span><br><span class="line">    = <span class="string">&#x27;Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_2) &#x27;</span></span><br><span class="line">    + <span class="string">&#x27;AppleWebKit/537.36 (KHTML, like Gecko) &#x27;</span></span><br><span class="line">    + <span class="string">&#x27;Chrome/81.0.4044.129 Safari/537.36 Edg/81.0.416.68&#x27;</span></span><br><span class="line">  webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;&#125;)</span><br><span class="line"></span><br><span class="line">  <span class="built_in">document</span>.body.appendChild(webview)</span><br><span class="line">  <span class="built_in">this</span>.webview = webview</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">search(url) &#123;</span><br><span class="line">  <span class="built_in">this</span>.webview.src = url</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mainWindow = <span class="keyword">new</span> BrowserWindow(&#123;</span><br><span class="line">  webPreferences: &#123;</span><br><span class="line">    <span class="comment">// 这里</span></span><br><span class="line">    webviewTag: <span class="literal">true</span>,</span><br><span class="line">    nodeIntegration: <span class="literal">true</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function">(<span class="params">html</span>) =&gt;</span> &#123;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">webview.addEventListener(<span class="string">&#x27;dom-ready&#x27;</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  webview</span><br><span class="line">  .executeJavaScript(</span><br><span class="line">    <span class="string">`function gethtml () &#123; return new Promise(resolve =&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();`</span>,</span><br><span class="line">  )</span><br><span class="line">  .then(<span class="function"><span class="params">html</span> =&gt;</span> &#123;</span><br><span class="line">    ipcRenderer.send(<span class="string">&#x27;ganhuo&#x27;</span>, html)</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ipcMain.on(<span class="string">&#x27;ganhuo&#x27;</span>, <span class="function">(<span class="params">e, arg</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> $ = cheerio.load(arg)</span><br><span class="line">  <span class="comment">// 各种教程都能看到的</span></span><br><span class="line">  <span class="comment">// 这里没多余操作，是个 img 就拿走</span></span><br><span class="line">  <span class="comment">// 接着 reply 回 renderer</span></span><br><span class="line">  <span class="keyword">const</span> imgs = $(<span class="string">&#x27;body&#x27;</span>).find(<span class="string">&#x27;img&#x27;</span>).map(<span class="function">(<span class="params">idx, ele</span>) =&gt;</span> $(ele).attr(<span class="string">&#x27;src&#x27;</span>)).get()</span><br><span class="line">  e.reply(<span class="string">&#x27;chuhuo&#x27;</span>, imgs)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p><code>renderer</code> 边准备一个接收，这波结束</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">  ipcRenderer.on(<span class="string">&#x27;chuhuo&#x27;</span>, <span class="function">(<span class="params">e, result</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.setState(&#123;</span><br><span class="line">      imgs: result,</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/electron/">electron</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/21/electron-crawler/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>整一个家庭服务器记录</title>
      <link>https://colmugx.github.io/blog/2020/06/07/home-server/</link>
      <guid>https://colmugx.github.io/blog/2020/06/07/home-server/</guid>
      <pubDate>Sun, 07 Jun 2020 05:57:46 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！&lt;/p&gt;
&lt;h3 id=&quot;系统选择&quot;&gt;系统选择&lt;/h3&gt;
&lt;p&gt;推荐三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot;&gt;raspbian&lt;/a&gt;（树莓派）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://clearlinux.org/&quot;&gt;clear linux&lt;/a&gt;（英特尔CPU）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.debian.org/index.zh-cn.html&quot;&gt;debian&lt;/a&gt;（传统服务器系统）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><a id="more"></a><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%8E%A9%E5%85%B7%E5%88%B6%E9%80%A0/">玩具制造</category>
      
      
      
      <comments>https://colmugx.github.io/blog/2020/06/07/home-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</link>
      <guid>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</guid>
      <pubDate>Thu, 04 Jun 2020 14:30:36 GMT</pubDate>
      
      <description>&lt;p&gt;这应该是连载得最近的一次，书接上回：&lt;a href=&quot;/blog/2020/06/02/hammerspoon-ts/&quot;&gt;《或许可以用 TypeScript 编写 hammerspoon》&lt;/a&gt;（也就是下面那篇）&lt;/p&gt;
&lt;p&gt;这里只会描述通过 &lt;code&gt;TypeScript&lt;/code&gt; 实现的过程&lt;/p&gt;
&lt;p&gt;以下内容可能产生不适（因为&lt;code&gt;hammerspoon&lt;/code&gt;的 &lt;code&gt;d.ts&lt;/code&gt; 全是 &lt;code&gt;interface&lt;/code&gt; 一把梭，编码不好看）&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建界面&lt;/li&gt;
&lt;li&gt;实现剪贴板读取&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;绑定快捷键&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><a id="more"></a><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容</span></span><br><span class="line"><span class="keyword">const</span> completionFn = <span class="function"><span class="params">choice</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="comment">// 一般来说这个判断不可省略，这样可以方便排除取消的情况</span></span><br><span class="line">  <span class="keyword">if</span> (choice) &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> chooser = hs.chooser.new(completionFn)</span><br></pre></td></tr></table></figure><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chooser.show()</span><br><span class="line">chooser.hide()</span><br></pre></td></tr></table></figure><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.readString() <span class="comment">// 读取最后一次剪贴板的文本</span></span><br><span class="line">pasteboard.readImage() <span class="comment">// 读取最后一次剪贴板的图片数据</span></span><br></pre></td></tr></table></figure><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pasteboard.changeCount()</span><br></pre></td></tr></table></figure><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clipboard = <span class="keyword">new</span> Clipboard()</span><br><span class="line"><span class="comment">// 我选择 1s 检查一次</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> clipWatcher = hs.timer.new(<span class="number">1</span>, <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> now = hs.pasteboard.changeCount()</span><br><span class="line">  <span class="keyword">if</span> (now !== preCount) &#123;</span><br><span class="line">    pcall(clipboard.save.bind(clipboard))</span><br><span class="line">    preCount = now</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">clipWatcher.start()</span><br></pre></td></tr></table></figure><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">save() &#123;</span><br><span class="line">  <span class="keyword">const</span> types = hs.pasteboard.contentTypes&lt;ModelChoice[<span class="string">&#x27;type&#x27;</span>]&gt;()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">type</span> <span class="keyword">of</span> types) &#123;</span><br><span class="line">    <span class="keyword">if</span> (isImgType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.saveImage(<span class="keyword">type</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (isTextType(<span class="keyword">type</span>)) &#123;</span><br><span class="line">      <span class="built_in">this</span>.saveText(<span class="keyword">type</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hs.hotkey.bind(clipboardConf.hotkey[<span class="number">0</span>], clipboardConf.hotkey[<span class="number">1</span>], <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  clipboard.show()</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">this</span>.chooser!.choices(choices)</span><br><span class="line"><span class="built_in">this</span>.chooser!.show()</span><br></pre></td></tr></table></figure><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%8E%A9%E5%85%B7%E5%88%B6%E9%80%A0/">玩具制造</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</link>
      <guid>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</guid>
      <pubDate>Tue, 02 Jun 2020 14:59:20 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;lua&lt;/code&gt; 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 &lt;code&gt;cocos2d&lt;/code&gt; 的时候，就接触了这个语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hammerspoon&lt;/code&gt; 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整&lt;/p&gt;
&lt;p&gt;早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了&lt;/p&gt;
&lt;p&gt;当然还有其他方案，比如常见的用到了 &lt;code&gt;moonscript&lt;/code&gt;，这是一个类 &lt;code&gt;coffeescript&lt;/code&gt; 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境&lt;/p&gt;
&lt;p&gt;前些日子关注到有一个项目 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/TypeScriptToLua/TypeScriptToLua&quot;&gt;TypeScriptToLua / TypeScriptToLua&lt;/a&gt;，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><a id="more"></a><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">npm init</span><br><span class="line">yarn add typescript-to-lua --dev</span><br></pre></td></tr></table></figure><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;dev&quot;: &quot;tstl --watch&quot;,</span><br><span class="line">&quot;build&quot;: &quot;tstl&quot;</span><br></pre></td></tr></table></figure><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%8E%A9%E5%85%B7%E5%88%B6%E9%80%A0/">玩具制造</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>docker 容器内通信</title>
      <link>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</link>
      <guid>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</guid>
      <pubDate>Sun, 29 Mar 2020 10:00:28 GMT</pubDate>
      
      <description>&lt;p&gt;除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud&lt;/p&gt;
&lt;p&gt;最后整了一个本地 webdav 😆&lt;/p&gt;
&lt;p&gt;当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云&lt;/p&gt;
&lt;p&gt;docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了&lt;/p&gt;
&lt;p&gt;**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的&lt;/p&gt;
&lt;p&gt;所以，水一篇文，单纯记录一下&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><a id="more"></a><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker network create -d bridge my-bridge</span><br></pre></td></tr></table></figure><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run --network my_bridge [...]</span><br></pre></td></tr></table></figure><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/docker/">docker</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 Context 传递多语言文本</title>
      <link>https://colmugx.github.io/blog/2020/01/31/react-translate/</link>
      <guid>https://colmugx.github.io/blog/2020/01/31/react-translate/</guid>
      <pubDate>Fri, 31 Jan 2020 06:38:39 GMT</pubDate>
      
      <description>&lt;p&gt;Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…&lt;/p&gt;
&lt;p&gt;找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上&lt;code&gt;react-intl&lt;/code&gt;，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个&lt;/p&gt;
&lt;p&gt;但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 &lt;code&gt;gatsby-plugin-i18n&lt;/code&gt; 或者 &lt;code&gt;react-intl&lt;/code&gt; 就可以了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><a id="more"></a><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createContext &#125; <span class="keyword">from</span> <span class="string">&#x27;react&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> langContext = createContext(&#123;&#125; <span class="keyword">as</span> ContextInterface)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建上下文后输出 Provider 和 Consumer 还是要的</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Provider = langContext.Provider</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> Consumer = langContext.Consumer</span><br><span class="line"></span><br><span class="line"><span class="comment">// ps: 其实 Consumer 用不上...</span></span><br></pre></td></tr></table></figure><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> genTranslate = <span class="function">(<span class="params">lang: <span class="built_in">string</span></span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> _message = <span class="built_in">require</span>(<span class="string">`@/lang/<span class="subst">$&#123;lang&#125;</span>.json`</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (!_message) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="built_in">Error</span>(<span class="string">`<span class="subst">$&#123;lang&#125;</span> language json was not found.`</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatMessage = (&#123; id, defaultMsg &#125;: FormatMessageType): <span class="function"><span class="params">string</span> =&gt;</span></span><br><span class="line">    <span class="comment">// _get 来自 lodash</span></span><br><span class="line">    _get(_message, id) || defaultMsg || <span class="string">&#x27;&#x27;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> formatter = <span class="function">() =&gt;</span> (&#123; formatMessage, _message &#125;)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> formatter()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> useIntl = (): <span class="function"><span class="params">ContextInterface</span> =&gt;</span> useContext(langContext)</span><br></pre></td></tr></table></figure><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; formatMessage: t &#125; = useIntl()</span><br></pre></td></tr></table></figure><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/01/31/react-translate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>创建一个 rust web server</title>
      <link>https://colmugx.github.io/blog/2019/12/29/try-actix/</link>
      <guid>https://colmugx.github.io/blog/2019/12/29/try-actix/</guid>
      <pubDate>Sun, 29 Dec 2019 04:29:34 GMT</pubDate>
      
      <description>&lt;p&gt;玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 &lt;code&gt;perfect&lt;/code&gt; 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。&lt;br&gt;
rust 社区中关注了 &lt;code&gt;rocket&lt;/code&gt; 一段时间，后面发现 &lt;code&gt;actix-web&lt;/code&gt; 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。&lt;/p&gt;
&lt;p&gt;这里会以重构我的闹钟后端作为蓝本，逐步做个记录。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;直接用 &lt;code&gt;cargo&lt;/code&gt; 创建应用&lt;/li&gt;
&lt;li&gt;装载 &lt;code&gt;actix-web&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写一个 api&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><a id="more"></a><h2 id="创建应用">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">actix-web</span> = <span class="string">&quot;2.0&quot;</span></span><br><span class="line"><span class="attr">actix-rt</span> = <span class="string">&quot;1.0&quot;</span></span><br><span class="line"><span class="comment"># env</span></span><br><span class="line"><span class="attr">dotenv</span> = <span class="string">&quot;0.15.0&quot;</span></span><br><span class="line"><span class="attr">log</span> = <span class="string">&quot;0.4.8&quot;</span></span><br><span class="line"><span class="attr">env_logger</span> = <span class="string">&quot;0.7.1&quot;</span></span><br></pre></td></tr></table></figure><p>然后在<code>main.rs</code>创建启动函数</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> actix_web::&#123;App, HttpServer, get&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>() -&gt; HttpResponse &#123;</span><br><span class="line">    HttpResponse::<span class="literal">Ok</span>().body(<span class="string">&quot;Hello World&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[actix_rt::main]</span></span><br><span class="line"><span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() -&gt; io::<span class="built_in">Result</span>&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">let</span> app = || App::new().service(index);</span><br><span class="line"></span><br><span class="line">    info!(<span class="string">&quot;serving on localhost:7001&quot;</span>);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(<span class="string">&quot;localhost:7001&quot;</span>)?</span><br><span class="line">        .run()</span><br><span class="line">        .<span class="keyword">await</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">+-- src</span><br><span class="line">| +-- controller</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- services</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- models</span><br><span class="line">| | +-- mod.rs</span><br><span class="line">| +-- middleware</span><br><span class="line">| | +-- mod.rs</span><br></pre></td></tr></table></figure><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="comment"># serde</span></span><br><span class="line"><span class="attr">serde</span> = <span class="string">&quot;1.0.104&quot;</span></span><br><span class="line"><span class="attr">serde_derive</span> = <span class="string">&quot;1.0.104&quot;</span></span><br><span class="line"><span class="attr">serde_json</span> = <span class="string">&quot;1.0.44&quot;</span></span><br><span class="line"><span class="attr">json</span> = <span class="string">&quot;0.12.0&quot;</span></span><br></pre></td></tr></table></figure><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> serde_derive::&#123;Serialize, Deserialize&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[derive(Serialize, Deserialize, Clone)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="class"><span class="keyword">struct</span> <span class="title">Payload</span></span>&lt;T&gt; &#123;</span><br><span class="line">    <span class="keyword">pub</span> code: <span class="built_in">isize</span>,</span><br><span class="line">    <span class="keyword">pub</span> message: <span class="built_in">String</span>,</span><br><span class="line">    <span class="meta">#[serde(skip_serializing_if = <span class="meta-string">&quot;Option::is_none&quot;</span>, default)]</span></span><br><span class="line">    <span class="keyword">pub</span> payload: <span class="built_in">Option</span>&lt;T&gt;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，从<code>controller/index</code>开始</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[derive(Deserialize)]</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Info</span></span> &#123;</span><br><span class="line">    message: <span class="built_in">String</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#[get(<span class="meta-string">&quot;/&quot;</span>)]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="keyword">async</span> <span class="function"><span class="keyword">fn</span> <span class="title">index</span></span>(query: web::Query&lt;Info&gt;) -&gt; <span class="built_in">Result</span>&lt;HttpResponse, Error&gt; &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 在Query拿到与 Info 结构一样的参数</span></span><br><span class="line">    <span class="comment">// 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理</span></span><br><span class="line">    <span class="comment">// rust 真严格..</span></span><br><span class="line">    <span class="keyword">let</span> result = crate::services::index::get_helloworld(query.message.clone());</span><br><span class="line"></span><br><span class="line">    <span class="literal">Ok</span>(HttpResponse::<span class="literal">Ok</span>().json(result))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> crate::models::payload::Payload;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 简单写一个服务</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">get_helloworld</span></span>(msg: <span class="built_in">String</span>) -&gt; Payload&lt;()&gt; &#123;</span><br><span class="line">    Payload &#123;</span><br><span class="line">        code: <span class="number">0</span>,</span><br><span class="line">        message: msg.to_string(),</span><br><span class="line">        payload: <span class="literal">None</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后改一下<code>main.rs</code></p><figure class="highlight diff"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="addition">+mod controllers;</span></span><br><span class="line"><span class="addition">+mod models;</span></span><br><span class="line"><span class="addition">+mod services;</span></span><br><span class="line"></span><br><span class="line">#[actix_rt::main]</span><br><span class="line">async fn main() -&gt; io::Result&lt;()&gt; &#123;</span><br><span class="line"></span><br><span class="line">    let app = || App::new()</span><br><span class="line"><span class="deletion">-        .service(index);</span></span><br><span class="line"><span class="addition">+        .service(controllers::index::index);</span></span><br><span class="line"></span><br><span class="line">    info!(&quot;serving on localhost:7001&quot;);</span><br><span class="line"></span><br><span class="line">    HttpServer::new(app)</span><br><span class="line">        .bind(&quot;localhost:7001&quot;)?</span><br><span class="line">        .run()</span><br><span class="line">        .await</span><br></pre></td></tr></table></figure><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">&quot;code&quot;</span>: <span class="number">0</span>,</span><br><span class="line">    <span class="attr">&quot;message&quot;</span>: <span class="string">&quot;helloworld&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/actix/">actix</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/12/29/try-actix/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>如果我把 Rust 用在网页呢</title>
      <link>https://colmugx.github.io/blog/2019/10/13/try-wasm/</link>
      <guid>https://colmugx.github.io/blog/2019/10/13/try-wasm/</guid>
      <pubDate>Sun, 13 Oct 2019 15:47:21 GMT</pubDate>
      
      <description>&lt;p&gt;已知&lt;code&gt;Rust&lt;/code&gt;是个很硬核的编程语言&lt;/p&gt;
&lt;p&gt;又已知&lt;code&gt;JavaScript&lt;/code&gt;或者说在浏览器上的&lt;code&gt;JavaScript&lt;/code&gt;在某种情况无法胜任工作。&lt;/p&gt;
&lt;p&gt;So？&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;🦀 Rust + 🕸 Wasm = ❤&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情&lt;/p&gt;
&lt;p&gt;那么前提是，你已经弄清楚了 &lt;code&gt;wasm-pack&lt;/code&gt; 是怎么回事了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了</p><a id="more"></a><h2 id="题干？">题干？</h2><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h2 id="板条箱？">板条箱？</h2><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/DaGenix/rust-crypto">DaGenix/rust-crypto</a></li><li><a target="_blank" rel="noopener" href="https://github.com/RustCrypto">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buttercup/rust-crypto-wasm">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h2 id="创建？">创建？</h2><blockquote><p>&gt; cargo generate --git <a target="_blank" rel="noopener" href="https://github.com/rustwasm/wasm-pack-template">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖</p><figure class="highlight toml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">[dependencies]</span></span><br><span class="line"><span class="attr">wasm-bindgen</span> = <span class="string">&quot;0.2&quot;</span> <span class="comment"># 核心</span></span><br><span class="line"><span class="attr">rand</span> = <span class="string">&quot;0.7.2&quot;</span> <span class="comment"># 但接下来用不上</span></span><br><span class="line"><span class="attr">aes</span> = <span class="string">&quot;0.3.2&quot;</span> <span class="comment"># 添加这个只是为了分组依赖与类型</span></span><br><span class="line"><span class="attr">cfb-mode</span> = <span class="string">&quot;0.3.2&quot;</span> <span class="comment"># 这个才是加密核心</span></span><br></pre></td></tr></table></figure><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h2 id="食用？">食用？</h2><h3 id="编译源码">编译源码</h3><ol><li>加载 crate（上板条！）</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> aes;</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">crate</span> cfb_mode;</span><br></pre></td></tr></table></figure><ol start="2"><li>声明依赖，或者说<code>import</code></li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">use</span> aes::Aes256; <span class="comment">// 使用 256</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; <span class="comment">// cfb是基于流加密其中一种</span></span><br><span class="line"><span class="keyword">use</span> cfb_mode::Cfb; <span class="comment">// 需要用这个结构体</span></span><br></pre></td></tr></table></figure><ol start="3"><li>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度</span></span><br><span class="line"><span class="class"><span class="keyword">type</span> <span class="title">AesCfb</span></span> = Cfb&lt;Aes256&gt;;</span><br></pre></td></tr></table></figure><ol start="4"><li>随便写个加密</li></ol><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#[wasm_bindgen]</span></span><br><span class="line"><span class="keyword">pub</span> <span class="function"><span class="keyword">fn</span> <span class="title">test</span></span>() -&gt; <span class="built_in">Vec</span>&lt;<span class="built_in">u8</span>&gt; &#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> key: &amp;[<span class="built_in">u8</span>; <span class="number">32</span>] = <span class="string">b&quot;nashizhendeniup,,nashizhendeniup&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> iv: &amp;[<span class="built_in">u8</span>; <span class="number">16</span>]  = <span class="string">b&quot;unique,un,unique&quot;</span>;</span><br><span class="line">  <span class="keyword">let</span> msg = <span class="string">&quot;那你是真的牛皮&quot;</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> <span class="keyword">mut</span> buffer = msg.as_bytes().to_vec();</span><br><span class="line"></span><br><span class="line">  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;<span class="keyword">mut</span> buffer);</span><br><span class="line"></span><br><span class="line">  buffer</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="到前端使用">到前端使用</h3><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx&gt;.wasm</li><li>&lt;xxx&gt;.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>&gt; npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;test&#125; <span class="keyword">from</span> <span class="string">&#x27;crypto-test&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(test())</span><br></pre></td></tr></table></figure><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</span><br></pre></td></tr></table></figure><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)</span><br><span class="line">(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)</span><br><span class="line">  get_local $p0</span><br><span class="line">  i32.load</span><br><span class="line">  get_local $p1</span><br><span class="line">  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)</span><br><span class="line">(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)</span><br><span class="line">  i32.const 1056732</span><br><span class="line">  get_local $p0</span><br></pre></td></tr></table></figure><p>看得我都有女装的冲动了（大雾</p><h2 id="结束？">结束？</h2><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h2 id="（附加资料）加密？">（附加资料）加密？</h2><h3 id="分组密码">分组密码</h3><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h3 id="AES">AES</h3><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h4 id="iv">iv?</h4><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h4 id="key">key?</h4><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h4 id="padding">padding?</h4><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h3 id="AES256-128">AES256? 128?</h3><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h3 id="AES256CFB">AES256CFB?</h3><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/10/13/try-wasm/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（一） —— Vapor</title>
      <link>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</link>
      <guid>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/</guid>
      <pubDate>Sun, 23 Jun 2019 08:17:53 GMT</pubDate>
      
      <description>&lt;p&gt;Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”&lt;/p&gt;
&lt;p&gt;所以，直接干吧&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧</p><a id="more"></a><h2 id="安装">安装</h2><p>直接装个工具集吧</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">brew tap vapor&#x2F;tap</span><br><span class="line">brew install vapor&#x2F;tap&#x2F;vapor</span><br></pre></td></tr></table></figure><h2 id="生成应用">生成应用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vapor new Hello</span><br></pre></td></tr></table></figure><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;Hello</span><br><span class="line">vapor xcode</span><br></pre></td></tr></table></figure><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h2 id="编写体验">编写体验</h2><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// DirectoryConfig.detect().workDir 项目绝对路径</span></span><br><span class="line"><span class="keyword">let</span> storePath = <span class="type">DirectoryConfig</span>.detect().workDir + <span class="string">&quot;Db/store.db&quot;</span></span><br><span class="line"><span class="keyword">let</span> sqlite = <span class="keyword">try</span> <span class="type">SQLiteDatabase</span>(storage: .file(path: storePath))</span><br></pre></td></tr></table></figure><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h2 id="相关信息">相关信息</h2><p>Vapor 自己提供一个<a target="_blank" rel="noopener" href="http://vapor.university/">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/06/23/try-vapor-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>来自 swift 的跨界执法（零） —— Perfect</title>
      <link>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</link>
      <guid>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/</guid>
      <pubDate>Fri, 07 Jun 2019 08:39:39 GMT</pubDate>
      
      <description>&lt;p&gt;因为不可抗力没上班，看着新&lt;code&gt;swift&lt;/code&gt;和&lt;code&gt;swiftUI&lt;/code&gt;发布，决定搞&lt;code&gt;Perfect&lt;/code&gt;。&lt;/p&gt;
&lt;p&gt;这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）&lt;/p&gt;
&lt;p&gt;篇幅不长，仅做一个尝试和介绍，原因在最后。&lt;/p&gt;
&lt;h2 id=&quot;安装&quot;&gt;安装&lt;/h2&gt;
&lt;p&gt;安装还是相当容易，官方编译器起一个可执行类型项目&lt;/p&gt;
&lt;figure class=&quot;highlight swift&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;swift package &lt;span class=&quot;keyword&quot;&gt;init&lt;/span&gt; --type=executable&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h2 id="安装">安装</h2><p>安装还是相当容易，官方编译器起一个可执行类型项目</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package <span class="keyword">init</span> --type=executable</span><br></pre></td></tr></table></figure><a id="more"></a><p>其次，在<code>Package.swift</code>中添加依赖</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dependencies: [</span><br><span class="line">    .package(url: <span class="string">&quot;https://github.com/PerfectlySoft/Perfect-HTTPServer.git&quot;</span>, from: <span class="string">&quot;3.0.0&quot;</span>)</span><br><span class="line">],</span><br></pre></td></tr></table></figure><p>接着，编译即安装依赖（熟悉啊！）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift build</span><br></pre></td></tr></table></figure><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code></p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">swift package generate-xcodeproj</span><br></pre></td></tr></table></figure><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h2 id="编写体验">编写体验</h2><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><s>后来发现，我好像用不上</s></p><p>按照习惯创建了一个结构体用来存放配置内容</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">GlobalConfig</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> baseRoute = <span class="string">&quot;/api/v1&quot;</span></span><br><span class="line">    <span class="keyword">let</span> httpPort = <span class="number">8081</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> PerfectHTTP</span><br><span class="line"><span class="keyword">import</span> PerfectHTTPServer</span><br><span class="line"><span class="comment">// 字典不是JSON，使用库中方法得以把字典转为JSON</span></span><br><span class="line"><span class="keyword">import</span> PerfectLib</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> config = <span class="type">GlobalConfig</span>()</span><br><span class="line"><span class="keyword">let</span> server = <span class="type">HTTPServer</span>()</span><br><span class="line"><span class="keyword">var</span> routes = <span class="type">Routes</span>(baseUri: config.baseRoute)</span><br></pre></td></tr></table></figure><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> list: [[<span class="type">String</span>: <span class="type">Any</span>]] = [</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;index&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;show&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.<span class="keyword">get</span>],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;create&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.post],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;update&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.put],</span><br><span class="line">    [<span class="string">&quot;name&quot;</span>: <span class="string">&quot;delete&quot;</span>, <span class="string">&quot;url&quot;</span>: <span class="string">&quot;/home/&#123;id&#125;&quot;</span>, <span class="string">&quot;method&quot;</span>: <span class="type">HTTPMethod</span>.delete]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RoutesConfig</span>().list.<span class="built_in">map</span> &#123;</span><br><span class="line">    routes.add(method: $<span class="number">0</span>[<span class="string">&quot;method&quot;</span>] <span class="keyword">as</span>! <span class="type">HTTPMethod</span>, uri: $<span class="number">0</span>[<span class="string">&quot;url&quot;</span>] <span class="keyword">as</span>! <span class="type">String</span>, handler: &#123; (request, response) <span class="keyword">in</span></span><br><span class="line">        <span class="keyword">let</span> json: [<span class="type">String</span>: <span class="type">Any</span>] = [<span class="string">&quot;code&quot;</span>: <span class="number">0</span>, <span class="string">&quot;message&quot;</span>: <span class="string">&quot;success&quot;</span>]</span><br><span class="line">        <span class="keyword">let</span> variables = request.urlVariables</span><br><span class="line">        <span class="keyword">var</span> newJson = json</span><br><span class="line">        <span class="keyword">if</span> (!variables.isEmpty) &#123;</span><br><span class="line">            <span class="keyword">for</span> e <span class="keyword">in</span> variables &#123;</span><br><span class="line">                newJson[e.key] = variables[e.key]</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">let</span> output = <span class="keyword">try</span>! newJson   <span class="comment">// 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）</span></span><br><span class="line">            .jsonEncodedString()</span><br><span class="line">        response</span><br><span class="line">            .setHeader(.contentType, value: <span class="string">&quot;application/json&quot;</span>)</span><br><span class="line">            .appendBody(string: output)</span><br><span class="line">            .completed()</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">server.addRoutes(routes)</span><br><span class="line">server.serverPort = <span class="type">UInt16</span>(config.httpPort)</span><br></pre></td></tr></table></figure><p>最后（简单）执行</p><figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> server.start()</span><br><span class="line">&#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="built_in">fatalError</span>(<span class="string">&quot;\(error)&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="原因">原因</h2><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/06/07/try-swift-perfect/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>react函数级写法和继承写法有什么区别？</title>
      <link>https://colmugx.github.io/blog/2019/05/28/react-component-method/</link>
      <guid>https://colmugx.github.io/blog/2019/05/28/react-component-method/</guid>
      <pubDate>Tue, 28 May 2019 15:48:21 GMT</pubDate>
      
      <description>&lt;p&gt;这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的&lt;code&gt;react 0.x&lt;/code&gt;时代，于是我默默把想法干掉了。&lt;/p&gt;
&lt;p&gt;如果是&lt;code&gt;createClass&lt;/code&gt;和&lt;code&gt;extends React.Component&lt;/code&gt;，还有点意思。如果是&lt;code&gt;functional component&lt;/code&gt;，那您怎么不用同样很「渐进式」同时又更牛逼的&lt;code&gt;vue&lt;/code&gt;呢？&lt;/p&gt;
&lt;p&gt;简单对比：&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th style=&quot;text-align:center&quot;&gt;createClass&lt;/th&gt;
&lt;th style=&quot;text-align:center&quot;&gt;Component/PureComponent&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES5&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;ES6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;propTypes/getDefaultProp&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;Component.defaultProps/Component.propType&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;this 已被指定&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;属性 this 不默认指向组件（实例）&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin&lt;/td&gt;
&lt;td style=&quot;text-align:center&quot;&gt;mixin（被取消，不建议，做不到，HOC）&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;其中对我来说，这两个的区别可能&lt;code&gt;mixin&lt;/code&gt;最有意思&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思</p><a id="more"></a><h2 id="编写风格">编写风格</h2><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h2 id="default-props">default props</h2><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h2 id="this">this</h2><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h2 id="mixin">mixin</h2><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<s>与复读</s>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/">编程议论</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/05/28/react-component-method/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>defineProperty? Proxy?</title>
      <link>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</link>
      <guid>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/</guid>
      <pubDate>Sat, 20 Apr 2019 04:47:12 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;听说 Vue3 数据绑定要切换到 Proxy，为什么？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这就是这篇文章的原因，来源于某个牛逼公司的面试。&lt;s&gt;我真的应该学会怎么清楚表达观点…&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;code&gt;defineProperty&lt;/code&gt; 和 &lt;code&gt;Proxy&lt;/code&gt; 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;defineProperty&quot;&gt;defineProperty&lt;/h2&gt;
&lt;p&gt;这是一个 &lt;code&gt;ES5&lt;/code&gt; 的方法。一个 &lt;code&gt;defineProperty&lt;/code&gt; 需要三个参数，都是 &lt;code&gt;require&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<s>我真的应该学会怎么清楚表达观点…</s></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h2 id="defineProperty">defineProperty</h2><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code></p><a id="more"></a><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;name&#x27;</span>, &#123;</span><br><span class="line">  value: <span class="string">&#x27;colmugx&#x27;</span>,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h2 id="Proxy">Proxy</h2><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  get(target, name) &#123;</span><br><span class="line">    <span class="keyword">return</span> name <span class="keyword">in</span> target ? target[name] : target</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="？">？</h2><h3 id="数据拦截">数据拦截</h3><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;</span><br><span class="line"><span class="keyword">let</span> value = <span class="literal">undefined</span></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, <span class="string">&#x27;key&#x27;</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">  &#125;</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    value = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;<span class="attr">key</span>: <span class="literal">undefined</span>&#125;, &#123;</span><br><span class="line">  get(target, prop) &#123;</span><br><span class="line">    <span class="comment">// 由于代理了所有操作，那么返回 404 纯属意愿</span></span><br><span class="line">    <span class="keyword">return</span> prop <span class="keyword">in</span> target ? target[prop] : <span class="string">&#x27;404 Not Found&#x27;</span></span><br><span class="line">  &#125;</span><br><span class="line">  set(val) &#123;</span><br><span class="line">    target[prop] = val</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h3 id="只需要-defineProperty？怎么可能？">只需要 defineProperty？怎么可能？</h3><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h3 id="为什么-Proxy？">为什么 Proxy？</h3><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">这个问题</a>，解决这个问题的方法有点骚，<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="attr">a</span>: &#123; <span class="attr">b</span>: &#123; <span class="attr">c</span>: &#123; <span class="attr">d</span>: &#123; <span class="attr">e</span>: <span class="string">&#x27;???&#x27;</span> &#125;&#125;&#125;&#125;&#125;  <span class="comment">// ???</span></span><br></pre></td></tr></table></figure><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="keyword">new</span> <span class="built_in">Proxy</span>(&#123;&#125;, &#123;</span><br><span class="line">  apply(target, context, args) &#123;&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h3 id="补充">补充</h3><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h2 id="为什么-Vue2-不直接用-Proxy">为什么 Vue2 不直接用 Proxy</h2><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h2 id="Vue-React">Vue &amp; React</h2><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/">编程议论</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/04/20/why-vue-proxy/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>关于 Nlvi 「添加到桌面」</title>
      <link>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</link>
      <guid>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/</guid>
      <pubDate>Wed, 17 Apr 2019 09:36:28 GMT</pubDate>
      
      <description>&lt;p&gt;其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。&lt;s&gt;好想换 iPad Mini (new)&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/nlvi-ios-desktop.gif&quot; alt=&quot;nlvi-ios-desktop&quot;&gt;&lt;/p&gt;
&lt;p&gt;目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关&lt;code&gt;meta&lt;/code&gt;配置（包括”识别为&lt;code&gt;WebApp&lt;/code&gt;“），然后你告诉我这东西不是 PWA？&lt;/p&gt;
&lt;p&gt;本来确实想支持 PWA 的，想到除了要 &lt;code&gt;manifest.json&lt;/code&gt;，还要搞定对应生成 &lt;code&gt;service worker&lt;/code&gt;，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 &lt;code&gt;pjax&lt;/code&gt; 然后添加到桌面，阅读体验还是挺好的。&lt;/p&gt;
&lt;p&gt;所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<s>好想换 iPad Mini (new)</s></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。</p><a id="more"></a><h2 id="meta">meta</h2><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-touch-fullscreen&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-capable&quot;</span> <span class="attr">content</span>=<span class="string">&quot;yes&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-title&quot;</span> <span class="attr">content</span>=<span class="string">&quot;Colmugx&#x27;s Blog&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">name</span>=<span class="string">&quot;apple-mobile-web-app-status-bar-style&quot;</span> <span class="attr">content</span>=<span class="string">&quot;default&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon&quot;</span>  <span class="attr">sizes</span>=<span class="string">&quot;72x72&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;icon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-icon-precomposed&quot;</span>  <span class="attr">sizes</span>=<span class="string">&quot;72x72&quot;</span>  <span class="attr">href</span>=<span class="string">&quot;icon.ico&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(device-width: 375px)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;apple-launch-1125x2436.png&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;apple-touch-startup-image&quot;</span> <span class="attr">media</span>=<span class="string">&quot;(orientation: landscape)&quot;</span> <span class="attr">href</span>=<span class="string">&quot;apple-touch-startup-image-2048x1496.png&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h2 id="apple-touch-startup-image">apple-touch-startup-image</h2><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a target="_blank" rel="noopener" href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/nlvi/">nlvi</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/04/17/about-nlvi-pwa/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我今天给 let 安排了</title>
      <link>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</link>
      <guid>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/</guid>
      <pubDate>Wed, 27 Mar 2019 10:13:29 GMT</pubDate>
      
      <description>&lt;h3 id=&quot;Round-1&quot;&gt;Round 1&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;- 我现在把所有东西都注释掉，改成这样&lt;br&gt;
function a() {&lt;br&gt;
return inner;&lt;br&gt;
let inner;&lt;br&gt;
}&lt;br&gt;
返回什么？&lt;/p&gt;
&lt;p&gt;- 那就应该 undefined 了，反正后面不执行&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，出了门掏出全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;inner is not defined&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;确实是不执行，但好像不是 &lt;code&gt;undefined&lt;/code&gt; 啊╭(*ﾟДﾟ*)╮&lt;/p&gt;
&lt;h3 id=&quot;Round-2&quot;&gt;Round 2&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;- 如果改成这样呢&lt;br&gt;
function a() {&lt;br&gt;
function inner() {}&lt;br&gt;
return inner;&lt;br&gt;
let inner;&lt;br&gt;
}&lt;br&gt;
返回什么？&lt;/p&gt;
&lt;p&gt;- 返回方法&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;自信的不行，同样用全世界最牛逼的千元机&lt;strong&gt;坚果 Pro 2S&lt;/strong&gt;，验证了一下。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Identifier ‘inner’ has already been declared&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h3 id="Round-1">Round 1</h3><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h3 id="Round-2">Round 2</h3><blockquote><p>- 如果改成这样呢<br>function a() {<br>function inner() {}<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？</p><a id="more"></a><h2 id="Why">Why?</h2><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"></span><br><span class="line">  a = <span class="string">&#x27;caonima&#x27;</span> <span class="comment">// 下面有 let，a 直接被该块锁定，这里报错</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> a <span class="comment">// 到这里才完成初始化，变量开始正常使用，但变量早已提升</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// 这里不是 caonima 而是 undefined</span></span><br><span class="line"></span><br><span class="line">  a = <span class="string">&#x27;woshinidie&#x27;</span></span><br><span class="line">  <span class="built_in">console</span>.log(a) <span class="comment">// woshinidie</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/issues/767">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28140450">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zhihusucks">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E7%BC%96%E7%A8%8B%E8%AE%AE%E8%AE%BA/">编程议论</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/03/27/you-dont-know-let/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>最后的 Nlvi</title>
      <link>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</link>
      <guid>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/</guid>
      <pubDate>Mon, 25 Mar 2019 06:34:53 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;Nlvi&lt;/code&gt; 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。&lt;/p&gt;
&lt;p&gt;那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。&lt;/p&gt;
&lt;p&gt;过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。&lt;/p&gt;
&lt;p&gt;为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……&lt;/p&gt;
&lt;p&gt;但，我的意思是，&lt;strong&gt;我不想维护 hexo 版本的 Nlvi 了&lt;/strong&gt;，我的意思是，诶嘿嘿嘿嘿嘿！&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！</p><a id="more"></a><p>所以 2.0 到 3.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%97%A5%E5%B8%B8%E5%90%90%E6%A7%BD/">日常吐槽</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/nlvi/">nlvi</category>
      
      <category domain="https://colmugx.github.io/blog/tags/colmugx/">colmugx</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/03/25/bye-nlvi/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>做不完的题目</title>
      <link>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</link>
      <guid>https://colmugx.github.io/blog/2019/03/23/last-test-questions/</guid>
      <pubDate>Sat, 23 Mar 2019 06:00:50 GMT</pubDate>
      
      <description>&lt;p&gt;又在「杂乱的工作台上」完成文章……&lt;/p&gt;
&lt;p&gt;没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。&lt;/p&gt;
&lt;p&gt;不留遗憾，把它搞完。题源就不说了。&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。</p><a id="more"></a><h2 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟">1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h2><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> requests: <span class="built_in">Promise</span>&lt;<span class="built_in">string</span>&gt;[]</span><br><span class="line">  = [<span class="string">&#x27;/a&#x27;</span>, <span class="string">&#x27;/b&#x27;</span>, <span class="string">&#x27;/c&#x27;</span>, <span class="string">&#x27;/d&#x27;</span>]</span><br><span class="line">  .map(<span class="function"><span class="params">v</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> time = <span class="built_in">Math</span>.floor(<span class="built_in">Math</span>.random()*<span class="number">1000</span>)</span><br><span class="line">    <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">      resolve(<span class="string">`<span class="subst">$&#123;v&#125;</span> spent <span class="subst">$&#123;time&#125;</span>`</span>)</span><br><span class="line">    &#125;, time);</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line"><span class="built_in">Promise</span>.race(requests).then(<span class="built_in">console</span>.log)</span><br></pre></td></tr></table></figure><h2 id="2-使用你擅长的方式实现-Dialog">2. 使用你擅长的方式实现 Dialog</h2><p>这个一直在暗示可以使用 <code>vue</code> 或者 <code>react</code>，但是我有些紧张，一时半会只能想到只能用原生的方式</p><p>最后只能说是搬石头砸自己的脚，没写过一时没思路，导致写不完</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">&quot;dialog&quot;</span>&gt;</span>直视我！栽种！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="css">    <span class="selector-class">.dialog</span> &#123;</span></span><br><span class="line">      display: none;</span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 50%;</span><br><span class="line">      left: 50%;</span><br><span class="line">      transform: translate(-50%, -50%);</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-id">#fff</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">box-shadow</span>: 1<span class="selector-tag">px</span> 2<span class="selector-tag">px</span> 8<span class="selector-tag">px</span> 0 <span class="selector-id">#c0c0c0</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#666</span>;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.mask</span> &#123;</span></span><br><span class="line">      z-index: 1;</span><br><span class="line">      position: fixed;</span><br><span class="line">      top: 0;</span><br><span class="line">      left: 0;</span><br><span class="line"><span class="css">      <span class="selector-tag">background</span>: <span class="selector-tag">rgba</span>(0, 0, 0, 0<span class="selector-class">.65</span>);</span></span><br><span class="line">      filter: blur(80%);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.dialog-header</span> &#123;</span></span><br><span class="line">      width: 100%;</span><br><span class="line">      height: 45px;</span><br><span class="line">      margin: 8px 16px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.isShow</span> &#123;</span></span><br><span class="line">      display: block;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.footer</span> &#123;</span></span><br><span class="line">      position: absolute;</span><br><span class="line">      bottom: 0;</span><br><span class="line">      left: 0;</span><br><span class="line">      right: 0;</span><br><span class="line">      height: 50px;</span><br><span class="line">      display: flex;</span><br><span class="line">      flex-flow: row nowrap;</span><br><span class="line">      justify-content: flex-end;</span><br><span class="line">      align-items: center;</span><br><span class="line">      margin: 0 16px;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="css">    <span class="selector-class">.cancel-btn</span> &#123;</span></span><br><span class="line">      outline: 0;</span><br><span class="line"><span class="css">      <span class="selector-tag">border</span>: 2<span class="selector-tag">px</span> <span class="selector-tag">solid</span> <span class="selector-id">#ccc</span>;</span></span><br><span class="line"><span class="css">      <span class="selector-tag">color</span>: <span class="selector-id">#999</span>;</span></span><br><span class="line">      display: flex;</span><br><span class="line">      justify-content: center;</span><br><span class="line">      align-items: center;</span><br><span class="line">      padding: 8px;</span><br><span class="line">      border-radius: 8px;</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="javascript">    <span class="class"><span class="keyword">class</span> <span class="title">TheDialog</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">constructor</span>(id) &#123;</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.btn = <span class="built_in">document</span>.querySelector(<span class="string">&#x27;#dialog&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.width = <span class="number">500</span></span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.height = <span class="number">300</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.template()</span></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.listener()</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.appendChild(<span class="built_in">this</span>.container)</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      template() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> container = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        container.style.width = <span class="built_in">this</span>.width + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">        container.style.height = <span class="built_in">this</span>.height + <span class="string">&#x27;px&#x27;</span></span></span><br><span class="line"><span class="javascript">        container.classList.add(<span class="string">&#x27;dialog&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        container.appendChild(<span class="built_in">this</span>.headerTem())</span></span><br><span class="line"><span class="javascript">        container.appendChild(<span class="built_in">this</span>.bodyTem())</span></span><br><span class="line"><span class="javascript">        container.appendChild(<span class="built_in">this</span>.footerTem())</span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.container = container</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      bodyTem() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> body = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        body.innerHTML = <span class="string">&#x27;Hello World&#x27;</span></span></span><br><span class="line"><span class="javascript">        body.style.margin = <span class="string">&#x27;16px&#x27;</span></span></span><br><span class="line"><span class="javascript">        body.style.color = <span class="string">&#x27;#333&#x27;</span></span></span><br><span class="line"><span class="javascript">        body.style.fontSize = <span class="string">&#x27;24px&#x27;</span></span></span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> body</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      headerTem() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> header = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        header.classList.add(<span class="string">&#x27;dialog-header&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> title = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        title.innerHTML = <span class="string">&#x27;Dialog&#x27;</span></span></span><br><span class="line">        header.appendChild(title)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> header</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      footerTem() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> footer = <span class="built_in">document</span>.createElement(<span class="string">&#x27;div&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> btn = <span class="built_in">document</span>.createElement(<span class="string">&#x27;button&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        footer.classList.add(<span class="string">&#x27;footer&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        btn.classList.add(<span class="string">&#x27;cancel-btn&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        btn.innerHTML = <span class="string">&#x27;CANCEL&#x27;</span></span></span><br><span class="line"><span class="javascript">        btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line">          e.stopPropagation()</span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.close()</span></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        footer.appendChild(btn)</span><br><span class="line"></span><br><span class="line"><span class="javascript">        <span class="keyword">return</span> footer</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      listener() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.btn.addEventListener(<span class="string">&#x27;click&#x27;</span>, <span class="function"><span class="params">e</span> =&gt;</span> &#123;</span></span><br><span class="line">          e.stopPropagation()</span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.toggle()</span></span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      toggle() &#123;</span><br><span class="line"><span class="javascript">        <span class="keyword">const</span> isShow = <span class="built_in">this</span>.container.classList.contains(<span class="string">&#x27;isShow&#x27;</span>)</span></span><br><span class="line">        if (isShow) &#123;</span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.close()</span></span><br><span class="line"><span class="javascript">        &#125; <span class="keyword">else</span> &#123;</span></span><br><span class="line"><span class="javascript">          <span class="built_in">this</span>.container.classList.add(<span class="string">&#x27;isShow&#x27;</span>)</span></span><br><span class="line"><span class="javascript">          <span class="built_in">document</span>.body.classList.add(<span class="string">&#x27;mask&#x27;</span>)</span></span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      close() &#123;</span><br><span class="line"><span class="javascript">        <span class="built_in">this</span>.container.classList.remove(<span class="string">&#x27;isShow&#x27;</span>)</span></span><br><span class="line"><span class="javascript">        <span class="built_in">document</span>.body.classList.remove(<span class="string">&#x27;mask&#x27;</span>)</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="javascript">    (<span class="function">() =&gt;</span> &#123;</span></span><br><span class="line"><span class="javascript">      <span class="keyword">const</span> theDialog = <span class="keyword">new</span> TheDialog()</span></span><br><span class="line"><span class="javascript">      <span class="built_in">window</span>.dialog = theDialog</span></span><br><span class="line">    &#125;)()</span><br><span class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这样凑合能用</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/03/23/last-test-questions/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>Redux —— combineReducers</title>
      <link>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/</link>
      <guid>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/</guid>
      <pubDate>Fri, 08 Mar 2019 06:49:12 GMT</pubDate>
      
      <description>&lt;p&gt;事出有因，写 &lt;code&gt;rabbit&lt;/code&gt; 的时候，一条单测出了问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Reducer _object returned undefined during initialization.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;想来必然是 &lt;code&gt;reducer&lt;/code&gt; 缺少默认的 &lt;code&gt;state&lt;/code&gt; 所致，&lt;s&gt;但是我的单测是从 &lt;code&gt;dva&lt;/code&gt; 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 &lt;code&gt;dva&lt;/code&gt; 可以接受 &lt;code&gt;reducers&lt;/code&gt; 是空对象，但应用运行起来有一样问题。&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;主要是这个问题无伤大雅，&lt;code&gt;model&lt;/code&gt; 不会出现只有 &lt;code&gt;reducers&lt;/code&gt; 这种情况。我也给出了解决：构建 &lt;code&gt;reducer&lt;/code&gt; 给一个默认 &lt;code&gt;state&lt;/code&gt; 顶着（但我认为一个 &lt;code&gt;model&lt;/code&gt; 应该强制存在 &lt;code&gt;state&lt;/code&gt;）&lt;/p&gt;
&lt;p&gt;显然这次并不想讲这个，而是想理解 &lt;code&gt;combineReducers&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<s>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</s></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code></p><a id="more"></a><p><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h2 id="getUndefinedStateErrorMessage">getUndefinedStateErrorMessage</h2><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h2 id="assertReducerShape">assertReducerShape</h2><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h2 id="combineReducers">combineReducers</h2><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 提取对象中所有字段名，一个 key 对应一个 reducer 方法</span></span><br><span class="line"><span class="keyword">const</span> reducerKeys = <span class="built_in">Object</span>.keys(reducers)</span><br><span class="line"><span class="comment">// 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。</span></span><br><span class="line"><span class="keyword">const</span> finalReducers = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> reducers[key] === <span class="string">&#x27;function&#x27;</span>) &#123;</span><br><span class="line">  finalReducers[key] = reducers[key]</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 再把初步验证过的 reducer 取出</span></span><br><span class="line"><span class="keyword">const</span> finalReducerKeys = <span class="built_in">Object</span>.keys(finalReducers)</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> shapeAssertionError</span><br><span class="line"><span class="comment">// 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  assertReducerShape(finalReducers)</span><br><span class="line">&#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">  shapeAssertionError = e</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个对比记录变量以及新 state</span></span><br><span class="line"><span class="keyword">let</span> hasChanged = <span class="literal">false</span></span><br><span class="line"><span class="keyword">const</span> nextState = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 遍历刚刚验证完的 reducer key 数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; finalReducerKeys.length; i++) &#123;</span><br><span class="line">  <span class="keyword">const</span> key = finalReducerKeys[i]</span><br><span class="line">  <span class="keyword">const</span> reducer = finalReducers[key]</span><br><span class="line">  <span class="comment">// 获取当前 state</span></span><br><span class="line">  <span class="keyword">const</span> previousStateForKey = state[key]</span><br><span class="line">  <span class="comment">// 通过执行 reducer 得到新的 state</span></span><br><span class="line">  <span class="keyword">const</span> nextStateForKey = reducer(previousStateForKey, action)</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nextStateForKey === <span class="string">&#x27;undefined&#x27;</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> errorMessage = getUndefinedStateErrorMessage(key, action)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(errorMessage)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）</span></span><br><span class="line">  nextState[key] = nextStateForKey</span><br><span class="line">  <span class="comment">// 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证</span></span><br><span class="line">  hasChanged = hasChanged || nextStateForKey !== previousStateForKey</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 返回：有改变的返回新的，无改变返回原 state。</span></span><br><span class="line"><span class="keyword">return</span> hasChanged ? nextState : state</span><br></pre></td></tr></table></figure><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/Redux/">Redux</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/03/08/redux-combinereducers/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
      <link>https://colmugx.github.io/blog/2019/03/02/about-redux/</link>
      <guid>https://colmugx.github.io/blog/2019/03/02/about-redux/</guid>
      <pubDate>Sat, 02 Mar 2019 10:00:19 GMT</pubDate>
      
      <description>&lt;p&gt;我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。&lt;/p&gt;
&lt;h2 id=&quot;createStore&quot;&gt;createStore&lt;/h2&gt;
&lt;p&gt;Redux 最核心的部分，提供基础的功能。&lt;code&gt;createStore&lt;/code&gt;接受三个参数：&lt;code&gt;reducer&lt;/code&gt;, &lt;code&gt;initialState&lt;/code&gt;, &lt;code&gt;enhancer&lt;/code&gt;。前两个比较好理解，&lt;code&gt;enhancer&lt;/code&gt;主要用在接受中间件中。返回产物我们主要使用三个方法：&lt;code&gt;getState&lt;/code&gt;, &lt;code&gt;dispatch&lt;/code&gt;, &lt;code&gt;subscribe&lt;/code&gt;。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;getState&lt;/code&gt;：获取当前 state 值&lt;/li&gt;
&lt;li&gt;&lt;code&gt;subscribe&lt;/code&gt;：接受监听，存入 &lt;code&gt;listeners&lt;/code&gt; 池中&lt;/li&gt;
&lt;li&gt;&lt;code&gt;dispatch&lt;/code&gt;：处理 &lt;code&gt;reducer&lt;/code&gt; 操作，触发 &lt;code&gt;listeners&lt;/code&gt; 方法&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h2 id="createStore">createStore</h2><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法</li></ul><a id="more"></a><p>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</p><h2 id="copy">copy</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">store</span>(<span class="params">state</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> currentState = state || &#123;&#125;</span><br><span class="line">  <span class="keyword">let</span> listeners = []</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &#123; getState, dispatch, subscribe &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">getState</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">subscribe</span>(<span class="params">listener</span>) </span>&#123;</span><br><span class="line">    listeners.push(listener)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">dispatch</span>(<span class="params">action</span>) </span>&#123;</span><br><span class="line">    action.call(<span class="built_in">this</span>, currentState)</span><br><span class="line">    listeners.forEach(<span class="function"><span class="params">f</span> =&gt;</span> f.call(<span class="literal">null</span>))</span><br><span class="line">    <span class="keyword">return</span> currentState</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%AE%9E%E8%B7%B5%E5%B0%9D%E8%AF%95/">实践尝试</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/03/02/about-redux/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
