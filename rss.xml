<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Colmugx &#39;s Blog</title>
    <link>https://colmugx.github.io/blog/</link>
    
    <image>
      <url>https://avatars2.githubusercontent.com/u/21327913?v=3&amp;s=466</url>
      <title>Colmugx &#39;s Blog</title>
      <link>https://colmugx.github.io/blog/</link>
    </image>
    
    <atom:link href="https://colmugx.github.io/blog/rss.xml" rel="self" type="application/rss+xml"/>
    
    <description>Co1MugX Blog</description>
    <pubDate>Tue, 14 Feb 2023 16:01:15 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>重新学习 JavaScript</title>
      <link>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</link>
      <guid>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/</guid>
      <pubDate>Tue, 14 Feb 2023 12:13:14 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;孔子曾说：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“温故而知新，可以为师矣”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Confucius 曾经也说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？&lt;/p&gt;
&lt;p&gt;想一想，从 16 年到现在一直用 &lt;code&gt;TypeScript&lt;/code&gt;，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 &lt;code&gt;JavaScript&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;并且，孔子还说过：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;知之者不如好之者，好之者不如乐之者&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;所以我决定邀请各位，请让你&lt;strong&gt;身边&lt;/strong&gt;的人一起学&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）</p></blockquote><p>孔子曾说：</p><blockquote><p>“温故而知新，可以为师矣”</p></blockquote><p>Confucius 曾经也说过：</p><blockquote><p>“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”</p></blockquote><p>意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？</p><p>想一想，从 16 年到现在一直用 <code>TypeScript</code>，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 <code>JavaScript</code></p><p>并且，孔子还说过：</p><blockquote><p>知之者不如好之者，好之者不如乐之者</p></blockquote><p>所以我决定邀请各位，请让你<strong>身边</strong>的人一起学</p><span id="more"></span><h2 id="环境">环境</h2><p>虽然直接使用浏览器方便一些，但我们现在应该本地都有一个 <code>node</code>，这可能对我们来说更为方便。顺便的可以温习一遍简单的 <code>File IO</code>，毕竟这是几乎所有语言入门都需要接触的部分</p><p>本文环境配置如下：</p><ul><li>OS：最新最时尚最卡的 MacOS Ventura</li><li>node: v16.13.2</li></ul><h2 id="基本类型">基本类型</h2><p><code>JavaScript</code> 是一款“函数式” <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 解释型脚本语言，所以这部分我们可以使用 Node REPL</p><p>打开终端，输入这个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node</code></pre><p>首先是基本类型：<code>JavaScript</code> 有<strong>三种</strong>基本类型：<code>string</code>, <code>number</code>, <code>boolean</code></p><p><code>string</code> 叫字符串，如果有其他编译型语言经验的话一时会觉得奇怪，在 <code>JavaScript</code> 没那么讲究，就是基础类型。字符串由一对引号包起来，这里也没那么多讲究 —— 单引号双引号都可以</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &#39;I love you&#39;&#39;I love you&#39;&gt; &quot;I love you, too&quot;&#39;I love you, too&#39;</code></pre><p>而如果你的字符串出现了必要的单引号（例如 do not 的缩写），这时为了避免歧义，应该用另一种引号来作为语法识别，这样字符串内就可以使用另一对引号</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &quot;I don&#39;t hate you&quot;&quot;I don&#39;t hate you&quot;</code></pre><p><code>number</code> 叫 number，同样也没那么多讲究 —— 不分 32 位 64 位，不分整浮点，甚至双精，甚至 <code>decimal</code>，配合一些基本的操作符（operators）我们可以把 REPL 作为计算器使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 1+12&gt; 1*11</code></pre><p>计算机的世界，计算没有大括号（{}），没有中括号（[]），只用小括号表示优先级，嵌套越深则越优先。举个例子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 4 * (40 - (2 - 12) + 40 * 2)520</code></pre><p>这个时候你再除以 0。我们小学都学过，除法里是不能除以 0 的。但是学计算机，就是要敢猜敢试</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 520 &#x2F; 0Infinity</code></pre><p>看，尝试得到了新的理解 —— <strong>这个式子也许对你还有另一种含义</strong></p><p><code>boolean</code> 指布尔值，指一对真实反义词，例如对和错，真和假，0和1。通常用在逻辑分支</p><p>计算机是严格的，对就是对的，错就是错的。<strong>但你们之间，没有对错</strong></p><p>懂行的人别急，确实还有两种：<code>undefined</code> 和 <code>null</code>，它们一般情况下指「没有」，但他们严格来说不是一个意思：<code>null</code> 指这个值是空的，但本身也是一个值；<code>undefined</code> 是真的没有，且未知</p><p>就像你现在问你身旁的人问你今天有没有想她，你回答 “没有”。虽说可能真的没想你，但其实心里还有你</p><p><strong>而有些人想都没得想！</strong></p><h2 id="函数">函数</h2><p>在复习函数之前先随便复习一下定义变量</p><p>严格 ES6 之前我们只会用 <code>var</code>，但如今我们都默认有两种定义方式：<code>var</code>, <code>let</code>，还有一种定量定义方式：<code>const</code></p><p>变量指定义之后，值还能改；定量指定义之后，<strong>值无法修改</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var lovedGame &#x3D; &#39;League of Legends&#39;lovedGame &#x3D; &#39;JX Online 3&#39; &#x2F;&#x2F; 世界上最好的 MMORPLGconst lovedOne &#x3D; &#39;You&#39;lovedOne &#x3D; &#39;Her&#39;&#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</code></pre><p>严格讲，<code>var</code> 和 <code>let</code> 有一点区别，<code>let</code> 有声明使用顺序（死区）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和作用域限制，换句话说更“安全”，所以现在对于新手来说，无论如何优先使用 <code>let</code></p><p>接下来到函数，一般声明一个函数会有两种方式，一种是正常的函数声明，一种是基于语言特性的声明</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1.function fn() &#123;&#125;&#x2F;&#x2F; 2.const fn &#x3D; () &#x3D;&gt; &#123;&#125;</code></pre><p>第二种其实就是一种「把函数也当做一个变量/定量」的思路，具体区别不展开<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>调用一个函数很简单</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn() &#x2F;&#x2F; 函数有参数就照着传</code></pre><p>Ok，小节实践，尝试以下函数并调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function calc(n) &#123;  return ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n&#125;&#x2F;&#x2F; 也可以这么写，是不是更帅了const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n</code></pre><p>（可以在 REPL 运行）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * nundefined</code></pre><p>REPL 是这样的，输入的下一行永远是返回值。接下来输入调用看看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; calc(1)520.1314&gt; calc(51)520.1314&gt; calc(564)520.1314</code></pre><p>你们也是这么简单纯粹吧 —— <strong>不管你变成了什么，都会一直爱你</strong></p><h2 id="实践">实践</h2><p>接下来就不用 REPL 了，因为接下来想整 <code>Network</code> 和 <code>File IO</code>。纯 <code>JavaScript</code> 这个语言是不带 IO 实现的</p><p>这一次就随便练一下写文件好了，我们的目的是：获取一个网络上的资源，并写下来</p><p>首先创建一个文件，就叫 <code>love.js</code>，随便放在你能找到的地方</p><p>先定义一些变量，<strong>照着复制就完事了</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fileName &#x3D; &#39;love.txt&#39;</code></pre><p>接下来是 file system，由于现在已经是 <code>import/export</code> stable 的时代了，所以包引用哪种都可以，但如果使用 <code>module</code> 模式的话需要将 <code>package.json</code> 的类型更改为 <code>module</code></p><p>我们直接执行，我们也不引入 npm 概念，所以我们还可以用 <code>CommonJS</code></p><p>在最顶上（也就是在上面两个变量的上方）写入</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 文件系统const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 路径模块（用于系统各种跟路径相关的工具）const path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 网络const http &#x3D; require(&#39;https&#39;)</code></pre><p>接着我们在最开始写的变量（fileName）下面新增一行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 将要保存文件的路径（自动拼接绝对路径）const currentDir &#x3D; path.resolve(__dirname, fileName)</code></pre><p>然后是网络请求，我们一般都会封装成一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  http.get(    &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,    res &#x3D;&gt; &#123;      let data &#x3D; [];      res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;        data.push(chunk);      &#125;);      res.on(&#39;end&#39;, () &#x3D;&gt; &#123;        return data.toString()      &#125;);    &#125;)&#125;</code></pre><p>最后一行写上文件写入就行啦（这里不考虑错误边界）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request())</code></pre><p>接下来在终端运行它吧！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node .&#x2F;love.js</code></pre><p>然后报错！这个时候我们应该学会看错误</p><blockquote><p>The “data” argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined</p></blockquote><p>这里说的是获取到一个 <code>undefined</code>，这个是不支持写入的</p><p>Actually，我们会给一个未知变量做边界控制，这里简单的直接短路吧</p><p>（剧本味也太重了草，事已至此只能做一个违背祖宗的决定了）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request() || &#39;&#39;)</code></pre><p>这个时候不报错了，我们去看一下这个目录下生成的 <code>love.txt</code> 文件吧！</p><p>当我们兴奋地打开之后发现，<strong>这是一个空文件</strong></p><p>不要想着「我的努力我的付出，得不到回报」。不要灰心，学习编程的过程就是不断发现问题，不断解决问题。<strong>感情也是如此</strong></p><p>但我们要的不是对「你错在哪儿了？」进行一个精准的回答，而是 <strong>code review</strong></p><p>通过 review 我们发现，request 写错了 —— 异步函数是不能直接获取返回值的</p><blockquote><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p></blockquote><p>而网络，对于一个 node 程序来说，就是一个异步工作</p><p>发现问题了，这个时候就要解决问题</p><p>对于异步工作，我们总会很习惯的使用 <code>Promise</code> 来解决「回调嵌套」问题，使得代码看起来「同步」，而且可以非常直觉的处理「返回值」</p><blockquote><p>Promise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象</p></blockquote><p>所以，对 request 进行修改吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  return new Promise(resolve &#x3D;&gt; &#123;     http.get(      &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,      res &#x3D;&gt; &#123;        let data &#x3D; [];        res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;          data.push(chunk.toString())        &#125;);        res.on(&#39;end&#39;, () &#x3D;&gt; &#123;          resolve(data.toString().replace(&#x2F;\\n&#x2F;g, &#39;\n&#39;))        &#125;);      &#125;)  &#125;)&#125;</code></pre><p>同时，「文件写入」语句也要做相应的修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, await request() || &#39;&#39;)</code></pre><p>这个时候再执行一遍！当我们再一次打开 <code>love.txt</code> 文件时，我们会看到</p><p><img src="/blog/Image/heart.webp" alt="heart"></p><p>所以说，爱有时候也应该像这样：<strong>等一会(await)又怎样嘛，我们已经约好(promise)了呀</strong></p><p>（其实如果你有留意到这篇文章分类是在「曲苑杂坛」下，或许早就知道了）</p><h2 id="Links-2">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266495749/answer/309719982">如何用数学的方法表白? - 知乎</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">异步 JavaScript 简介</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises">如何使用 Promise</a></li><li>本博客</li></ul><p>真是温故知新啊，看看这个引用区 ↓</p><p>全都是年轻不懂事的自己，瞎几把写</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>JavaScript 可以是函数式语言，但是极端还是存在争议，这里过分严谨一些 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我今天给 let 安排了 · Colmugx 's Blog</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我就写个方法，这么麻烦？ · Colmugx 's Blog</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/JavaScript/">JavaScript</category>
      
      
      <comments>https://colmugx.github.io/blog/2023/02/14/relearn-javascript/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>成为玩家 2022</title>
      <link>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</link>
      <guid>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/</guid>
      <pubDate>Sat, 31 Dec 2022 08:51:19 GMT</pubDate>
      
      <description>&lt;p&gt;本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了&lt;/p&gt;
&lt;p&gt;边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了</p><p>边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x</p><span id="more"></span><h2 id="我想做的就是-JRPG">我想做的就是 JRPG</h2><p>今年有更多的时间花在系统学习音乐上，为什么</p><p>首先，JRPG 更强调剧情的推进，且有更强烈的 role play（相对于欧美RPG来说，代入日式RPG更需要想象），所以相对来说，JRPG 有一个更抽象的世界观。怎么交代清楚「现在身处一个怎样的环境」，<strong>除了文案旁敲侧击暗示之外，配乐起到非常关键的作用</strong></p><p>自从去年聊完《原神》之后，我发现越来越多的新游戏（所谓的二次元游戏）都开始强调配乐（这个时候我真想吐槽某个游戏吃老本的功力是真的得天独厚）。但毕竟不是谁家都是 HoYoVerse，从一开始就深入跟策划文案磨世界观，和游戏基本到开发末期再“配乐”，本质上还是有所区别</p><p>所以在游戏，音乐有一个更新的称呼：互动音乐（设计），且这是我们能叫出名的国外游戏公司的标配（比如真有你的 SE）</p><p>举个例子，最近的《宝可梦朱/紫》，四个地区分别有自己一个 theme，但每一个 theme 在步行、骑行、水边、特殊场景、战斗所使用的配器均不同，且使用的配器更适合当时的环境 —— 步行更多是一个比较纯净的钢琴，一旦上了摩托就会变成一个带 epic 的管弦，<strong>并且他们无缝衔接</strong>。这让探索旅途中，既体现了地区风格，又带给游玩者一个“更真实”的情绪</p><p>再加个例子，《八方旅人》和《异度之刃3》有一个差不多的设计</p><p>介绍下背景，《八方旅人》讲的是八个不同的角色为了实现各自不同的目标在同一片大陆展开冒险的游戏。在他们分别进 boss 战之前都有一段嘴炮用于剧情铺垫，此时配乐开始使用对应角色一个可以循环的短音乐，进战斗之后开始切为一个从这个短音乐的音阶和节奏型转换为战斗配乐的音阶和节奏型（大多是升音阶，学者中间段先接上前面的 3/4 转 6/8 一路卡到 4/4 进战斗）</p><p>也就是每个角色 boss 战之前配乐是这样的：循环段 -&gt; 过渡 -&gt; 战斗</p><p>这么做的好处同样很清晰：<strong>当你沉浸在故事时，不会因为配乐切换而打断情绪</strong>。同时游戏大多时候在嘴炮期就已经让你感觉到气愤/可怜，而在过渡段自然地滑进 battle theme 之后，玩家的情绪也已经非常自然地提到了激情的状态，巴不得直接就扬了面前这个B</p><p>而《异度之刃3》要提的是冠名怪（You Will Know Our Names-Finale-，这首也是系列第一首使用了完整的互动音乐设计的音乐</p><p>冠名怪的配乐被分成了四段：进去一段，怪进狂暴期一段（血条在火焰之后），濒死一段，<strong>收势两段</strong>。是的，收势分为以 Chain Attack 结束和普通结束。</p><p>上面描写了很多信息，那跟我有锤子关系？巧了，我想做的就是 JRPG。<strong>如果制作人都不知道自己的游戏将会是什么样，那又有谁会知道呢</strong></p><p>所以日后只要写关于游戏简评的文章，都会加上一个新章节：配乐分享</p><p>虽然但是，今年的钢琴没有任何进步。明年除了乐理要继续安排时间学习，要开始翻《配器法》</p><h2 id="好故事还要讲得好">好故事还要讲得好</h2><p>故事对于 RPG 来说非常重要，无论是美式 RPG 还是日式 RPG。关于日式和美式对于故事的区别我跟一些业内人员（世界观设计，文案）算是有过沉重的讨论，这里不谈，可以以后单独写一篇我的观点</p><p>翻看我的微信读书，发现《故事》读了 8 个月，我记得很清楚，其中第五章第六章花费了绝大多数时间。如何「科学」的写出一部能让众人娓娓而谈的小说是一件非常难做到的事情</p><p>这是写故事，好故事所需要的前置条件。再是讲故事，因为不管多好的故事，它终究暂时是在纸上。读小说吸引人的其中一点也在于画面与描写都在每个人的大脑中，每个人都有每个人想要的画面和理解，一千个读者眼中就会有一千个哈姆雷特</p><p>《故事》列举了非常多的影视作品片段作为案例用于解释故事点，实际上对于现代游戏来说…也没问题。现在能端上台面的 RPG 游戏，要求可越来越高了。除了需要成熟或独特的游戏玩法，镜头语言、场面调度等等影视手段也在不断地搬到游戏作品中去，加上这个时代出现了「虚幻5」这样的游戏引擎，越来越多不可能逐渐变成可能</p><h2 id="游戏首先要好玩">游戏首先要好玩</h2><p>今年刚好内部有一个 gamejam，抱着试一试的心态参加了。拿到主题之后，我们首先有一个世界观想法，然后开始写 GDD，开始决定类型、特点、关卡设计、<strong>音乐设计</strong>…</p><p>虽然我们最后因为其他原因没有参赛（报名了但没参赛），但在路演期间，在去试玩其他组的游戏，特别是一个后来成为冠军的游戏时，我突然悟了一个道理</p><blockquote><p>游戏首先要好玩 —— 魏皮特</p></blockquote><p>任天堂也是这样的主张，游戏设计再好，它不好玩就不是好游戏。所以<strong>从最开始我们的路线就是错的</strong> —— 浪费时间在决定是 2D 是 3D，是像素还是写实，<strong>甚至是 gamejam 没有时间考虑的音乐设计</strong>，都是无用功</p><p>也许这是 JRPG 的路线，但对于 gamejam 来说就是不适合，因为流程太长，无法在玩法上一击命中，那么短的试玩时间根本无法给试玩者留下任何印象，他们都是没有耐心的。在开发时也无故增加了许多工作量</p><p>并且我们在常规关卡设计中预计使用「华容道」，这其实已经被证明过多次这是个“偷懒”的游戏设计，如果关卡设计太难，这又会失去更多一部分玩家</p><p>总而言之，从此刻开始悟道什么是纯粹的快乐。明年再来</p><h2 id="减少后悔">减少后悔</h2><p>在复盘整年时，我发现上一节提到了 gamejam，实际上我本就有一个符合主题的游戏 —— 去年学习游戏开发时的原型《Pong Evolution》，真的本质上就完全符合主题</p><p>但为什么会想不起来？<strong>能力不够</strong>。能让我发现这个问题的依然是那个比赛的第一名，让我得到「原来主题还可以这样理解」的启发</p><p>这让我又有一个新的想法：如果我就以一个游戏原型，不断地去参加内部的比赛，每次都为了贴合主题添加新的元素，积累下来会不会非常有意思？</p><p>多做减少后悔，现在我是这样想的</p><h2 id="你做的前十个游戏都是垃圾">你做的前十个游戏都是垃圾</h2><blockquote><p>你做的前十个游戏都是垃圾，所以赶紧做掉吧 —— Jesse Schell</p></blockquote><p>上面提到的 JRPG 确实是我目前在游戏工作中最大的梦想，但我不可能一直吊死在一个项目上，停留在「完美的设计」上，即使这是我最想做好的游戏</p><p>我能理解标题的含义，初出茅庐就做出完成度非常高的作品几乎不可能。与其纸上谈兵不如先做起来。十个必然是一个虚数，其含义是不断地做，坚持做，越做越多，越来越多的错误，越来越多的总结…</p><p>作为程序员应该更能理解。刚开始写一个应用程序的时候，我肯定大多数人都还无法理解设计模式的重要性（说不定现在大多数前端也不理解，所以我还是不认为这些前端是程序员（x</p><p>Wwise 是一个商业软件，自然它也官方适配同样是商业引擎的 Unity 和 Unreal，而对于目前作为我学习伴侣的 godot 就没有这种完美适配。所以在我开始学习「交互音乐设计」同时也在思考「如何设计一个在 godot 比较方便我自己使用的声音管理类？」、「autoload 是否就可以做到？」</p><p>这大概就是「垃圾」的意义</p><p>这个游戏我至今都一直在修改和补充 GDD，但确实不会贸然开始设计程序，因为我的垃圾还没写完（x</p><h2 id="是该有所不一样了">是该有所不一样了</h2><p>去年的这个时候还在抑郁的期间，总结非常的 down</p><p>今年更多被一个压力更大的工作看上了，几乎一整年都在围绕这个工作</p><p>公司给机会了所以尝试开发一个框架。在最开始设计的时候并没有把它当框架设计，今年开始发现业务复杂度越来越「奇妙」之后，决定给它加个核心转成框架，以后讲</p><p>加上在公司活整得很散，所以今年感觉比较疲，几乎所有开坑的产品都是 idle</p><ul><li>kazusa - 游戏剧本编辑器</li><li>setsuna - 个人事项管理</li><li>ayaka - 文档生成器（CSR, SSG）</li><li>hikari - 图片预览器</li></ul><p>是该有所不一样了，原本给自己设计的知识管理工具后面推翻改成游戏剧本/文案编辑器，应该以后更多都会根据自己的需求开发工具</p><p>有太多想做的事情，甚至当前很想去开发《无限暖暖》…</p><p>就这样，今年没有那么多抱怨和抱负，大概是因为正在生病</p>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/31/to-be-a-gamer-2022/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>web 「性能优化」</title>
      <link>https://colmugx.github.io/blog/2022/12/15/web-optimization/</link>
      <guid>https://colmugx.github.io/blog/2022/12/15/web-optimization/</guid>
      <pubDate>Thu, 15 Dec 2022 14:23:45 GMT</pubDate>
      
      <description>&lt;p&gt;如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢&lt;/p&gt;
&lt;p&gt;而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-8&quot;&gt;TL;DR&lt;/h2&gt;
&lt;p&gt;总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;减少加载体积&lt;/li&gt;
&lt;li&gt;懒加载/延迟加载：利用 import/export 做代码分段&lt;/li&gt;
&lt;li&gt;充分利用 http2 和 vite（开箱即用版 rollup ）&lt;/li&gt;
&lt;li&gt;非常巧合的做法，指跟 React Beta 版文档异曲同工&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢</p><p>而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方</p><h2 id="TL-DR-8">TL;DR</h2><p>总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间</p><ul><li>减少加载体积</li><li>懒加载/延迟加载：利用 import/export 做代码分段</li><li>充分利用 http2 和 vite（开箱即用版 rollup ）</li><li>非常巧合的做法，指跟 React Beta 版文档异曲同工</li></ul><span id="more"></span><h2 id="减少加载体积">减少加载体积</h2><p>前端的静态资源都在依赖网络传输，所以在第一屏尽量加载最小的资源。</p><h3 id="使用-preact">使用 preact</h3><p>这个应用在建立的时候 react 版本是 17，虽然已经有 react 18 但还不 stable。考虑一番之后觉得没有并发和批处理的 react 不够有吸引力。与此同时，preact 10 有：</p><ul><li>更小的体积，即使带着 <code>compact</code> 最后也就不到 10k，保守预估</li><li>更快的运行</li><li>react 16 兼容，沉淀组件直接用不用考虑需不需要升级或适配</li><li><code>&lt;Suspense&gt;</code> 在当时已经稳定</li></ul><p>当时的考虑是：现在用 preact 以后迁移回 react 18 问题也不是很大，所以在 react 18 没有稳定之前都可以用 preact。只不过在 <code>TypeScript</code> 环境下，写类型稍微痛苦了一些 —— 毕竟只有 <code>api</code> 是兼容的，类型可不兼容</p><h3 id="JS-加载">JS 加载</h3><p>首先是编译期处理，举个例子</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; use-noop.tsexport function useNoop() &#123;  return () &#x3D;&gt; &#123;&#125;&#125;&#x2F;&#x2F; page.tsimport &#123; useNoop &#125; from &#39;.&#x2F;use-noop&#39;</code></pre><p>首先我们的规范决定了：工具放在 <code>utils</code> 目录中且<strong>一个文件仅有一个函数，并通过 <code>export</code> 导出</strong></p><p>所以我们在最开始就解决了一个问题：尽可能拆掉首包体积，或是能自然的利用 ES Module Tree Shaking (Rollup)</p><p>接着，由于我们的目标是Chromium(cef) 76 往上，那么<strong>可以直接使用 module 的形式加载</strong>且不需要 <code>polyfill</code></p><h2 id="懒加载">懒加载</h2><p>懒加载内容分两个：</p><ul><li>原本一起打包但已经 split 的 JS 文件</li><li>从网络上加载的媒体资源（图片，视频）</li></ul><h3 id="媒体资源懒加载">媒体资源懒加载</h3><p>这里主要是图片，虽然 Chrome 已经有浏览器级别的懒加载（loading=“lazy”）</p><p>Chrome 会根据当前网络环境决定要加载多远的图片，不过 Chrome 的阈值有点捉摸不透。最后还是决定使用 <code>lazysizes</code>，并且自己控制加载距离 —— 大概就在屏幕外面多一点点</p><p>于是「不必要」的网络请求又节省下来一点</p><h3 id="JS-懒加载">JS 懒加载</h3><p>可以懒加载的 JS 不少，对于我们来说大概有几种：</p><ul><li>首屏用不到的模块，懒加载</li><li>路由，组件懒加载</li></ul><p>首屏用不到的，或者在生产中用不到的模组例如 <code>vconsole</code>、<code>hls.js</code>，在第一次不参与加载</p><p>其次，我们在架构组织上采用分层组织，即页面组件(pages)作为消费层，业务代码根据需求和 <code>feature</code> 一一关联</p><p>我愿称之为渐进式 DDD，因为就是从 DDD 的思想不断简化，再通过磨合时间和程度逐步加上去，最后都习惯并理解「为什么持续维护项目型需要 DDD」</p><p>有机会的话下一篇分享 DDD 在我们实际场景中的运用。这里推荐一个项目叫 <a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh</a>，比较可惜的是这个框架诞生于我们的决定之后</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 这里隐藏掉了部分细节- common  - component  - model  - repository  - service- [feature]  - component  - model  - repository  - service...- pages  - [page]</code></pre><p>这样，<code>page</code> 对于我们来说只是一个组合功能的载体，从而又带来一个好处：<strong>一个页面可以决定哪部分直接添加，哪部分进 lazyload</strong>。加上 <code>preact</code> 已经稳定的<code>&lt;Suspense&gt;</code>，就可以实现不那么生硬的体验效果</p><p>并且所有的 <code>page</code> 都是通过路由 lazyload 的，也就是第一次加载不会加载到别的页面的 JS（这好像已经变成了基操）</p><p>到这其实有个问题：以上关于一个页面拆分懒加载，但它们始终都要在第一屏加载，下载量可是不变的</p><p>所以还有下一步操作，大小尽量砍了，该想怎么弄快了</p><h2 id="利用-http2">利用 http2</h2><p>http2 没有改动 http 的语义，但改动了头部压缩，新增优先级排序和多路复用</p><p>在 http1.1，由于每个请求都会开一个连接，所以早期前端优化有这么一手：把静态资源分布在不同域名下，例如 <a target="_blank" rel="noopener" href="http://img1.example.com">img1.example.com</a>，<a target="_blank" rel="noopener" href="http://img2.example.com">img2.example.com</a>。其实现在观察 github 也能看到类似的做法</p><p>但因为 http2 有了二进制分帧，所以基于此实现了共享TCP，到位了再根据标记和头部重新组装报文。在这之前 http1.1 是一整块纯文本，分区用的换行符（指头部和身体）</p><p>其实以上都「不重要」，只需要知道现在同一CDN下载不阻塞了。所以在 h2 之下，<strong>静态资源可以同时加载</strong>。这就解答了上面关于页面拆分的问题</p><h2 id="异曲同工？">异曲同工？</h2><p>Dan Abramov 也就是 react 的创作者，被小右也就是 vue 的创作者大狙点头之后，对 react beta 文档爆更了 3 天。原因就是被吐槽 TTI 和 TBT 占用时间太长被 vue 的文档吊锤</p><p>所以他对 react beta 文档改动了什么？</p><ul><li>工具函数拆分，改成一文件一函数</li><li>移除过时浏览器支持，从而移除 <code>polyfill</code> 的加载（react 现在也仅支持现代浏览器）</li><li>懒加载资源，例如 <code>@codemirror/lint</code> 和 <code>eslint</code></li></ul><p>所以现代前端优化，好像基础版就这么些操作，大家都是一样的。首先尽可能压低大小（可仅参考 gzip 之后大小），然后尽可能抬高加载速度显示速度（SSR，CDN）</p><p>实在不行，发现瓶颈出现在远端数据，那就上缓存！资源慢缓存资源，数据接口慢缓存数据，什么 service worker 全给它叠起来（x</p><h2 id="Links-3">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/mq2thez/blog/blob/main/upgrade-react-etsy/preact-vs-react.md">Updating React at Etsy</a></li><li><a target="_blank" rel="noopener" href="https://web.dev/browser-level-image-lazy-loading/">Browser-level image lazy-loading for the web</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/geekculture/how-does-dan-abramov-optimize-beta-reactjs-org-after-be-complained-about-website-speed-840b02cf5ee8">How Does Dan Abramov Optimize beta.reactjs.org After Be Complained about Website Speed?</a></li><li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/HTTP--2.html">什么是HTTP/2？</a></li><li><a target="_blank" rel="noopener" href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a></li><li><a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh-js/remesh</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/preact/">preact</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E6%80%A7%E8%83%BD%E4%BC%98%E5%8C%96/">性能优化</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/15/web-optimization/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我早就想拿 QuickJS 做 SSR 了</title>
      <link>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</link>
      <guid>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/</guid>
      <pubDate>Mon, 12 Dec 2022 12:33:01 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;鸽了一年，不重要，下一篇解释&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在几乎现代框架 SSR 默认都是用 &lt;code&gt;node&lt;/code&gt;，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 &lt;code&gt;React&lt;/code&gt; 举例子，SSR 分两个步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 &lt;code&gt;renderToString&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行时水合，也就是不用 &lt;code&gt;render&lt;/code&gt; 而是 &lt;code&gt;hydrate&lt;/code&gt;，因为已经不需要在运行时创建节点，只需要绑定&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以问题就很清晰：默认或者常规手段的 &lt;code&gt;hydrate&lt;/code&gt; 和 &lt;code&gt;renderToString&lt;/code&gt; 都是 JS 函数&lt;/p&gt;
&lt;p&gt;当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：&lt;strong&gt;这 B 是不是可以直接拿来做 SSR ？&lt;/strong&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>鸽了一年，不重要，下一篇解释</p></blockquote><p>现在几乎现代框架 SSR 默认都是用 <code>node</code>，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 <code>React</code> 举例子，SSR 分两个步骤：</p><ol><li>静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 <code>renderToString</code></li><li>运行时水合，也就是不用 <code>render</code> 而是 <code>hydrate</code>，因为已经不需要在运行时创建节点，只需要绑定</li></ol><p>所以问题就很清晰：默认或者常规手段的 <code>hydrate</code> 和 <code>renderToString</code> 都是 JS 函数</p><p>当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：<strong>这 B 是不是可以直接拿来做 SSR ？</strong></p><span id="more"></span><h2 id="Why-QuickJS">Why QuickJS</h2><p>毕竟 rust 早就有 v8 绑定，<code>deno</code> 用的就是</p><p>你说得对，但是 QuickJS 是由著名神仙 Fabrice Bellard 所打造的一个小型并且可嵌入的 Javascript 引擎，它支持ES2020规范，包括模块，异步生成器和代理器。在这里，你可以用任何现代的 JavaScript 语言片段在几乎任何语言环境中运行，在自由的环境中邂逅不同的语言和技术栈，同时它还支持 Decimal 提案和运算符重载提案……</p><p>其实就是不挑</p><h2 id="前端">前端</h2><p>流水账，主要是踩坑流程</p><p>前端部分自不必多说，玩了两年半的 <code>solidjs</code>，现在只要不是上班都是用这款（其实上班能夹带私货的时候也用）</p><p><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a> 提供 SSR 各种形态的 demo，但他们都有一个特点：使用非常原生的 <code>rollup</code> 插件作为演示<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，那我正经用也不用这个啊，那不行，就得按 vite 工作流来。</p><p>so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm dlx degit solidjs&#x2F;templates&#x2F;ts</code></pre><p>首先 <code>vite.config.ts</code> 有两处调整：</p><ul><li>solid 插件激活 ssr，这在处理 ssr 输出时有用</li><li><code>noExternal</code>，后面讲为什么</li></ul><p>改完之后大概是这样</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default defineConfig(&#123;  plugins: [solidPlugin(&#123; ssr: true &#125;)],  build: &#123;    target: &quot;esnext&quot;,  &#125;,  ssr: &#123;    noExternal: true,  &#125;,&#125;);</code></pre><p><code>package.json</code> 新增一个 <code>script</code>，不加也行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;vite build --outDir .&#x2F;dist&#x2F;client&quot;,    &quot;build:server&quot;: &quot;vite build --ssr .&#x2F;src&#x2F;entry-server.tsx --outDir .&#x2F;dist&#x2F;server&quot;,  &#125;&#125;</code></pre><p>这里把输出路径都有点调整，目的是把客户端产物和服务端产物分开，不这么做也行。<strong>但入口是肯定分开的</strong>，即使这很基操不需要写下来</p><p>按照 vite 建议的做法，客户端入口从 <code>index.tsx</code> 改为 <code>entry-client.tsx</code>，则服务端入口为 <code>entry-server.tsx</code>，内容每个框架都差不多，按照前端框架的建议做即可</p><p><strong>记得客户端真实入口 <code>index.html</code> 里的 script 路径也要改！</strong></p><p>过一下 build，能看到 dist 下两组目录，下一步</p><h2 id="服务端">服务端</h2><p>Web Framework 不用挑，用的最多的（可能也是两年半），可能也是目前来说依然最虎的 <code>actix-web</code>，需要花心思的是找 binding</p><p>首先用的是 <a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a>，在品鉴这个项目的时候还顺便搜到另一个项目 <a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a>，这是一个类似的操作：通过 QuickJS SSR Vue，可以读读看</p><blockquote><p>Node outperforms QuickJS by a wide margin. Especially with enough cores and memory. However, QuickJS is very small and has very low memory consumption, so running it threaded in a Rust shell makes it possible to have very high throughput using very few resources in comparison.</p></blockquote><p>顺便品鉴完这个项目之后，开始缝合。不出意外的话马上要出意外了</p><h3 id="坑1：">坑1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unsupported keyword: export</code></pre><p>这里可以讲讲为什么上面要 <code>noExternal</code> ，原因很简答，vite 默认你是会用 node 的，加上 type 是 <code>module</code>，结果就是编译后的服务端入口依然有 <code>import</code> 和 <code>export</code></p><p>所以目的很简单：把所有用到的 js 都打成一个文件。并且这里还需要一个操作：去掉最后一行，也就是 <code>export</code> 部分</p><p>默认情况下是在 QuickJS global 环境下 eval 程序，直接当成 <code>REPL</code> 来用就完事了</p><h3 id="坑2：">坑2：</h3><blockquote><p>找不到 setTimeout</p></blockquote><p>一番查找，<code>setTimeout</code> 由 QuickJS 内置 module: os 提供，按道理来说 <code>setTimeout</code> 应该能在 globalThis 直接调用</p><p>没关系，直接 eval 进去吧</p><h3 id="坑3：">坑3：</h3><blockquote><p>不存在 os</p></blockquote><p><strong>这你妈你说你妈呢？</strong> 这怎么可能啊</p><p>只见 Issue 区赫然有这么一行</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs/issues/123">Is there any way to use std, os, and global?</a></li></ul><p>Ok，寄</p><h3 id="Finish">Finish</h3><p>本来看着是 star 最多的库</p><p>算了，还得是直接绑定来得稳定，虽然比较麻烦，相当于换个语言直接使用框架。但高级封装至少比低级封装容易使用</p><p>于是改用这个高级封装：<a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a>，这个就非常纯，需要直接生吃 Document</p><p>简单验证</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let test &#x3D; ctx.eval(&quot;let a &#x3D; 1; let b &#x3D; 2; a + b&quot;).unwrap();assert!(3, test);</code></pre><p>发现没问题，直接搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let result &#x3D; context.with(|ctx| &#123;    let _a: String &#x3D; ctx.eval_file(&quot;ssr&#x2F;dist&#x2F;server&#x2F;entry-server.js&quot;).unwrap();    let result: Object &#x3D; ctx.eval(r#&quot;render()&quot;#).unwrap();    let head: String &#x3D; result.get(&quot;head&quot;).unwrap();    let body: String &#x3D; result.get(&quot;body&quot;).unwrap();    let mut map &#x3D; HashMap::&lt;String, String&gt;::new();    map.insert(&quot;body&quot;.to_string(), body);    map.insert(&quot;head&quot;.to_string(), head);    map&#125;);</code></pre><p>这里转一次 <code>HashMap</code> 的原因是：<code>Object</code> 的类型没有声明，直接 return 出去有静态检查问题，rust 不允许</p><p>但因为是概念验证，先转成已知类型出去顶着用</p><p>编译没问题，继续搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let template &#x3D; read_to_string(&quot;ssr&#x2F;dist&#x2F;client&#x2F;index.html&quot;).unwrap();let html &#x3D; template    .replace(&quot;&lt;!--app-head--&gt;&quot;, result.get(&quot;head&quot;).unwrap())    .replace(&quot;&lt;!--app-body--&gt;&quot;, result.get(&quot;body&quot;).unwrap());</code></pre><p>打印 html，确认内容就是一个完整的 html 文件。<strong>成了！</strong></p><p>那直接上 server-side，简简单单写个 get</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[get(&quot;&#x2F;&quot;)]async fn hello() -&gt; impl Responder &#123;    let html &#x3D; make_html();    HttpResponse::Ok()        .status(StatusCode::OK)        .content_type(&quot;text&#x2F;html&quot;)        .body(html)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123;    HttpServer::new(|| &#123;        App::new()            &#x2F;&#x2F; 静态文件映射            .service(Files::new(&quot;&#x2F;assets&quot;, &quot;ssr&#x2F;dist&#x2F;client&#x2F;assets&quot;))            .service(hello)    &#125;)    .bind((&quot;127.0.0.1&quot;, 8080))?    .run()    .await&#125;</code></pre><p>浏览器输入一个令人熟悉的 <code>localhost:8080</code>，正常运行，JS 绑定也一切正常</p><p>代码会发布在 <a target="_blank" rel="noopener" href="https://github.com/colmugx/quickjs-ssr">colmugx/quickjs-ssr</a></p><h2 id="最后-3">最后</h2><p>这里只是一个简单验证，SSR 的 real world 肯定不是这么两步就能完成，否则就不需要像 <code>next.js</code> 和 <code>SolidStart</code> 这样的上层框架</p><p>并且，除了服务端需要考虑线程池等等这些问题之外，拥有 JIT 的 v8 可能性能上会更优</p><p>但我的目的也很简单，我要的不是 SSR，而是两个需求</p><ul><li>给 <code>ayaka</code> 提供一个静态页面生成的方式，但默认还是像 <code>saika</code> 那样的运行时 fetch</li><li>给 <code>kazusa</code> 提供脚本执行环境，不过这是个 optional，主要维护还是 lua 执行环境，这与既定用户群有关</li></ul><p>别问为什么又来一个 <code>ayaka</code>，问就是灵感来源 <a target="_blank" rel="noopener" href="https://github.com/2nthony/saika">2nthony/saika</a>，而不叫<code>sakuya</code>的原因仅是因为那会在玩原神银趴</p><p>最后，这可能是第一篇来自于这个主题 3.5 版本的文章，想给用 hexo 的这段时间一个完美的休止符，然后去开发有新设计风格的 nlvi 4</p><p>但是重构一半，交互上还是有缺陷，只不过说不影响阅读</p><h2 id="Links">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>solidjs 的 vite 插件来源于 rollup 插件的上层封装 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/quickjs/">quickjs</category>
      
      <category domain="https://colmugx.github.io/blog/tags/vite/">vite</category>
      
      <category domain="https://colmugx.github.io/blog/tags/solid/">solid</category>
      
      <category domain="https://colmugx.github.io/blog/tags/ssr/">ssr</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/12/12/quickjs-ssr/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>作为玩家 成为玩家</title>
      <link>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</link>
      <guid>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/</guid>
      <pubDate>Fri, 07 Jan 2022 11:21:34 GMT</pubDate>
      
      <description>&lt;p&gt;实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;那是一篇极其消极的文章&lt;/li&gt;
&lt;li&gt;本文是一次自我救赎&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;so，这也许是更合适的“年终总结”&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-6&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;虽然还是前端，但身处游戏&lt;/li&gt;
&lt;li&gt;对于以上，为什么&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：</p><ul><li>那是一篇极其消极的文章</li><li>本文是一次自我救赎</li></ul><p>so，这也许是更合适的“年终总结”</p><h2 id="TL-DR-6">TL;DR</h2><ul><li>虽然还是前端，但身处游戏</li><li>对于以上，为什么</li></ul><span id="more"></span><h2 id="因为热爱">因为热爱</h2><blockquote><p>从主观感受聊到游戏设计，这大概就是热爱吧 —— 2021.4.30</p></blockquote><p>我觉得故事不用从盘古开天辟地开始讲起</p><p>非常幸运的是，当时的工作环境中，团队所有人都玩游戏，大部分都玩高品质单机游戏，所以我们业余茶歇都会聊游戏。甚至分享可以讨论游戏，甚至在会议室玩《决斗链接》，两人duel，其他人通过电视观战。而那会面试的时候，我们经常问的“你业余时间一般会做什么”，在得到瞬间的回答“我平时不玩游戏”反而会感到诧异</p><p>在当时，除了会讨论游戏好不好玩之外，我经常又会往下继续讨论。跟另外一位同事经常讨论现在的热点，以及游戏细节，和“我为什么喜欢xx游戏”。那个时候根本没想过会到游戏公司服务，大家只是玩家</p><p>后来遇到一些朋友，无一例外都来自于游戏公司。于是在氛围煽动下，我离开了所处不久的新环境。这里只能说：感谢 VP 的理解和支持，同时我没办法回应你的欣赏，实属抱歉</p><h2 id="“黑暗降临”">“黑暗降临”</h2><blockquote><p>永远不要忘记第一次听《疾如猛火》后潸然泪下的那个中午</p></blockquote><p>作为一个营销碰瓷游戏，在此之前我从来没有关心过，黑暗降临也指的是第一次的营销碰瓷。但在一次内部分享之前，一切都改变了</p><p>分享的大概主题是“原神的音乐设计”，发生在分享之前，游戏新闻也多多少少提到：</p><blockquote><p>《崩坏3》和《原神》的音乐火到出圈</p></blockquote><p>于是，这是我与原神的第一次接触 —— 我打开了原神的主主题（Main Theme）。那个层次的细腻和画面感一下子涌入脑中，光听音乐已经能大概能看到这是一片幻想大陆</p><p>紧接着，我听了一些场景音乐。有个熟悉的特点，场景音乐都分为日间和夜间，这个设计在这之前仅有《异度之刃》系列对我印象深刻</p><p>当天中午，引用的故事发生了。在五声宫调跳进中古调，加上民乐领跑，饱满的感情直接轰入灵魂。因为原神的早期世界观架在欧洲，主题也就偏中古调式。《疾如猛火》就是一首同时具有璃月主题与原神主题的战斗音乐，也就是就东方体裁碰撞西方体裁，民乐器碰撞管弦乐，毫不突兀，又交相辉映……就这样一下子崩不住了。落泪原因简单：在我们生活的这片土地上，真的诞生了品质如此优秀的游戏</p><p>其实很长一段时间我都没有打开过原神，下载过原神。但城邦、人物性格、人际特点几乎都靠音乐云了个七七八八。蒙德有大大小小的西欧建筑，遍地风车，人们过着惬意的生活；繁荣的璃月港口络绎不绝，不仅存在丰富的中华文化，更是做到最大的文化包容；像是一个存在于战争或荒乱的稻妻，人民憧憬和平，满怀希望。在绀田村的表达中更为明显，仿佛妻离子散，每天都盼望家人回家……而每个元素也有独特的风格，雷元素会有重金属或者电子音乐，火元素有急躁的风格或者摇滚，水元素总会用带有故事感的钢琴带情绪……</p><p>且不谈游戏质量，这已经能证明这是成功的游戏音乐了</p><p>这是一个即使现在想起来还是会鼻尖一酸的回忆，<strong>所以我不断提醒自己，不要忘记这个感觉。</strong>《鬼谷八荒》、《风来之国》、《戴森球计划》等等证明了我们是可以做出优秀的游戏，《原神》向我们展示了我们也能做出贴近日系上游品质的游戏。但是 <strong>这个日系游戏并没有屈服于这个 title —— 璃月的刻画告诉了全世界什么是中华文化。</strong> 原本我没有喜欢过任何一个角色，现在有了：<strong>红毹婵娟 —— 云堇</strong></p><p>与其说是爱上了 miHoYo，不如说只是喜欢 HoYo-MiX。我还是不会主动向人推荐《原神》</p><h2 id="“未成年保护”">“未成年保护”</h2><blockquote><p>周五、周六、周日和法定节假日<br>20:00 ~ 21:00</p></blockquote><p>两个朋友同一时间离职，相继去了三个不同的行业：游戏、教育、房地产。于是后面发生了什么已经不用讲了（笑</p><p>虽然 ban 的是网络游戏。但难免有些感慨。国内的游戏环境还是太糟糕了，被各种数值网游污染，导致人们根本没办法理解什么是游戏，怎么对待游戏。现在还有绝大多数人认为游戏 = 打怪升级刷刷刷，他们不懂《双人成行》为什么必须两个人玩；《风之旅人》为什么不告诉玩家 NPC 的由来；《传说之下》为什么不能打怪升级；《我的世界》为什么能成为电子工程摇篮（x</p><p>针对游戏问题，更重要的是成长期的陪伴。任天堂在 2000 年的时候就推出了“防沉迷机制”<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但人家是如何理解防沉迷的？</p><blockquote><p>Wii的“家长监控”模式，最终选择了记录孩子的游戏时间，让他们和家长自行沟通决定游戏时间，用主机里的“游戏履历”督促孩子遵守约定，达到和“断电”同样的目的。</p><p>总之，大部分限制都能调整，只要家长和孩子商量好就行。这是任天堂“家长监控”系统的最大亮点。</p></blockquote><p>任天堂在本来是提供给监护人的信《致监护人》预判了“孩子可能正在寻找解除限制的方式”，并留下了一段话告诉小朋友：</p><blockquote><p>不守诺言，整天玩游戏肯定是不行的<br>但如果是“我才玩了一会……”就被爸爸妈妈说了<br>那或许就是没有好好决定游戏时间的缘故了！</p><p>确定一个规则，然后让爸爸妈妈通过这个软件监督自己，这样就能开开心心玩游戏了</p></blockquote><p>我是相信人在思维最发散的时候是应该接触电子游戏或者沙盘游戏的，而且应该培养一个健康的游戏价值观。<strong>至于那些什么“电子海洛因”的家长，反正每一代都有上瘾的东西。</strong> 尝试反问你的家长，上学的时候有没有沉迷过武侠小说，有没有沉迷过滚铁环，至少我屡试不爽。什么时候为人父母才能懂得：<strong>家庭才是第一教育场所，陪伴才是第一教育资源。</strong> 怪电视，怪游戏，怪玩具，怪邻居都是不可能解决问题的</p><p>你觉得你很忙，没时间陪孩子，把手机一丢让孩子自己玩。即使你手机没有王者荣耀，你的孩子也会因为抖音上瘾。到时候你敢举报抖音吗？你不敢！因为你也正上瘾着呢！</p><h2 id="主程摆烂">主程摆烂</h2><blockquote><ul><li>这个实现不了</li><li>我们最近太忙了，有空看一下</li></ul></blockquote><p>这来自于真实情况，但我只能轻描淡写</p><p>作为发行，确实有很多运营工作是需要我们做的，其中就有游戏中的社区入口。我们对接的两个游戏，一个 webview 不撑满，一个 webview 保留默认工具栏，更甚的是 android 与 iOS 的工具栏位置不同，但它们都会挤压视图空间。而这两个问题本不是问题，对于 unity editor 来说仅仅是一个开关而已。而当我们提出了问题时，对方回复了引用1；而当我们提出解决方式：仅加一条声明，对方回复了引用2</p><p>并且在合作过程中，游戏方经常爱理不理，甚至出现内存泄露时还直接推锅是社区造成的，<strong>并转发崩溃堆栈给我们排查问题，你他妈是认真的吗？</strong></p><p>这让我感受到了，“带着热爱工作”只是我的一厢情愿而已，无论到哪都是如此。我不再出声，用 unity 模拟了我们需要的调试环境（只用了一个 webview，并对 webview 定制），并加入他们不愿意做的退出功能（不愿意取消工具栏的原因是没有工具栏退出不了场景）。以此来解决我们的调试工作经常受阻导致我们自己的开发周期被压缩，最后再进游戏运行一遍确认效果即可</p><p>彼时彼刻我真的很敬仰腾讯游戏，在《腾讯游戏开发精粹2》里他们描述到了，他们在三个游戏引擎都开发了渲染后端，让社区和活动页面都能直接渲染在游戏引擎中。这种做法无论什么角度都是完美的，而我们却还在这种狗屁事情纠缠不清</p><h2 id="浅墨离世">浅墨离世</h2><blockquote><p>愿这本书，能帮助那些热爱游戏编程、怀揣游戏开发梦想，却苦于难以入门的人们，让他们少走弯路。</p><p>愿这本书，能为国产游戏、国产游戏引擎的崛起，开启一扇门，迎接新的黎明。</p><p>我们都还年轻，该做的梦及时去做，该追寻的梦想用力去追寻。</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><blockquote><p>我有一个梦想，将来的某一天，大家都能玩到拥有自己本土文化的优质游戏。</p><p>我有一个梦想，有一天，西游记能出ACT，让老外去体会中国文化西游记中“斗战胜佛”的打击快感，那一定比西方的动作巅峰之作《战神》、《鬼泣》更加深邃。</p><p>我有一个梦想，有一天，上海滩能出沙盒游戏，而不是玩《GTA》感受美国梦，亦或是玩着《热血无赖》体验国外公司强行塞给我们的“中国文化”。</p><p>我有一个梦想，有一天，不少3A大作不需要汉化，因为是我们自己的游戏，配音是中国的，文化也是中国的。</p><p>我有一个梦想，将来的某一天，国产游戏能像中国的其他产业一样，以一个领跑者的姿态，面对全世界，面对全宇宙，器宇轩昂，扬眉吐气。</p><p>这会是由我们一起去完成的梦想。</p><p>等着我们的好消息！</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><p>我不会揣摩已故之人，但能写下如此文字的人最后的结果竟然如此令人遗憾，想必在那瞬间肯定是无比绝望吧</p><p>我对浅墨并不熟悉，在这之前仅通过 opencv 了解过。在这之前因为方向不同，所以对 shader 等等也不关心。在某个周六，兄弟加班出门吃饭时，看到了某座楼下面围起来了，还在叹息：</p><blockquote><p>XX游戏怎么又……（为什么加又）</p></blockquote><p>当知道当事人是如此追梦人时，没有人不是心酸的。但凡在知乎看过那两则招聘文章，即使评论区各种冷嘲热讽，也能感受到作者对这件事抱足了信心。</p><p>也许世界就是这么现实吧。有人正在坚持“技术宅改变世界”，有人在摆烂，有人因为可能过高投入导致评估收益不清晰而在投入之前终止了投入</p><h2 id="最后-4">最后</h2><blockquote><p>在我的名片上，我是一个公司总裁；<br>在我自己来看，我是一名游戏开发者；<br>而在内心深处，我是一名玩家。</p><p>—— 岩田聪 -《玩者之心》- GDC2005</p></blockquote><p>故事是经过排列的，每发生一个事件，这种无助又坚定的心情就加深一层</p><p>《原神》向我们和世界展示了国产优秀的架空世界观和国产游戏音乐，我们再也不用羡慕史克威尔的音乐；《黑神话：悟空》向我们和世界展示了各个角度的正版“斗战胜佛”，我们再也不用羡慕拥有《战神》的圣莫妮卡。未来还有更多可能</p><p>但我们的环境还是很糟糕。所以，我能不能也做点什么，能不能不再是少数人的世界，能不能让更多人理解，即使这对我来说完全陌生。打嘴炮是最简单的，但这件事可能真的入脑了 —— 我开始怀疑我的选择和自己：我真的可以做到吗？我可什么都不会啊！</p><p>就像 2022 年潘通流行色<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>想要表达的那样（老样子，博客换颜色了），也刚好贴近自己和博客一直的追求：<strong>让一切充满想象力</strong>，希望可以继续坚持下去。毕竟，整个评论区可都是“你可以！！”啊</p><p>其实 <code>godot-pong</code> 是有在做的，现在是填充基本规则和做了音效音乐（音乐觉得做废了打算重做所以迟迟没上传）</p><p>希望 2021 年留下来的这篇文章，在未来不会被自己删除，并时刻提醒自己</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/461405.html">https://www.huxiu.com/article/461405.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2022">PANTONE COLOR OF THE YEAR 2022</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E5%B9%B4%E5%BA%A6%E6%80%BB%E7%BB%93/">年度总结</category>
      
      
      <comments>https://colmugx.github.io/blog/2022/01/07/to-be-a-gamer/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>为什么我没想过 EventBus</title>
      <link>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</link>
      <guid>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/</guid>
      <pubDate>Wed, 24 Nov 2021 14:32:35 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;以下全是暴论&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是一个发生在今年的对话：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Q：组件通信有几种方式？&lt;br&gt;
A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children&lt;br&gt;
Q：还有吗？&lt;br&gt;
A：postmessage 可以算吗&lt;br&gt;
Q：也行，还有吗？&lt;br&gt;
A：localStorage/sessionStorage 可以算吗？&lt;br&gt;
Q：算半个，还有吗？&lt;/p&gt;
&lt;p&gt;这 TM 不就这些方式还有吗？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;回来一拉清单，各家文章盘点确实还多了一个：&lt;code&gt;EventBus&lt;/code&gt;&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>以下全是暴论</p></blockquote><p>这是一个发生在今年的对话：</p><blockquote><p>Q：组件通信有几种方式？<br>A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children<br>Q：还有吗？<br>A：postmessage 可以算吗<br>Q：也行，还有吗？<br>A：localStorage/sessionStorage 可以算吗？<br>Q：算半个，还有吗？</p><p>这 TM 不就这些方式还有吗？</p></blockquote><p>回来一拉清单，各家文章盘点确实还多了一个：<code>EventBus</code></p><span id="more"></span><h2 id="什么是-eventbus">什么是 eventbus</h2><p>简单理解：事件总线，一种订阅/发布模型，即是在希望发生事件处理的地方创造一个监听器(listener)，接着在希望影响到监听器所在位置变化或更新的地方加上发射器(emitter)</p><p>这样的好处是，任何位置都可以透传。因为事件总线（可以）是全局的</p><p>从名字上看，它应该是属于事件驱动设计的产物。这没问题，GUI 一直都跟事件驱动有关，浏览器在交互部分也是这么做的</p><p>那，这么多前端框架有没有使用事件驱动的？有，御三家里的 <code>Angular</code>。除了御三家那更多了，反而数据驱动才是新品种</p><p>OK 目的达成，我就是要绕到这个点上：为什么面试上问 Vue，甚至是 React，我就没想过 EventBus。<strong>因为这本来就跟数据驱动没关系</strong></p><h2 id="为什么我不用-eventbus">为什么我不用 eventbus</h2><p>不带 Vue 玩了这领域有争议。就一个问题：什么时候 React 会触发更新？</p><p>这个时候就应该有个经典公式：view = f(props, state)。也就是当 <code>props</code> 或者 <code>state</code> 发生更新了，<code>view</code> 会更新。或者换句话说，<strong>数据更新了视图会更新</strong></p><p>那这里就有一个问题：如果触发了某个事件，视图会更新吗？<strong>会更个几把！</strong> 要会更新你还需要 <code>setState</code> 吗？这也是为什么 <code>rxjs</code> 在 <code>React</code> 用起来就是没有 <code>Angular</code> 来得无尿点，最核心的一点就是你想通过 <code>rxjs</code> 通知视图更新就肯定需要在订阅做一次 <code>setState</code>，不管你封装了还是在 business code 里订阅一次写一次</p><p>而且我不用还有另一个原因：这东西在我的理解中，就是一个 <code>goto</code> —— 它会把代码弄得非常糟。本来是单向的数据流向，现在会完全不知道某个组件会因为什么而产生更新，流向变得不可观察</p><p>你可能会说，那 context 也是这么传的啊！可 eventbus 可不禁止子组件 call 父组件，不约定好就造成逆数据流</p><p>除此之外，事件名称是一个字符串（暂且只能是字符串），那么这个时候需要保证事件名不要重复。为了解决这个问题可能就会引入一个叫事件表的东西 —— 但你想用到某一个事件时，import 这个常量，毕竟常量背后什么静态值对于事件来说无所谓，对得上就行。这会发生什么问题？在生产过程中这问题发生得不要太多，最经典的就是忘记更新事件表，或者嫌麻烦摆烂直接写，最后发现因为一个大小写导致事件对不上……</p><p>除此之外还有！毕竟是一个订阅发布模型，你订阅了是不是得取消订阅。事件的东西你一旦开了他就会一直留存在内存中，处理不当的话可能会出现两个一模一样的 listener，而这个原因仅是因为上一个没有销毁……当然了最轻的问题就是你的某一个事件处理会响应 n 次，是的这只是最轻的</p><p>总之这非常反思维，在一个数据驱动的环境中，为了一点点 buff 而引入大量 debuff 是否得不偿失。经过一轮网上冲浪后发现，相关讨论不少（指两个）</p><ul><li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/t/event-bus-is-it-a-good-idea/49853">Event bus - is it a good idea?</a></li><li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/androiddev/comments/eksepr/why_some_people_dislike_eventbus/">Why some people dislike EventBus?</a></li><li><a target="_blank" rel="noopener" href="https://tkacz.pro/vue-js-why-event-bus-is-bad-idea/">Vue.js: why event bus is bad idea</a></li></ul><h2 id="你真的需要-eventbus？你用来做什么？">你真的需要 eventbus？你用来做什么？</h2><p>Vue 有 provider/inject，React 有 Context API，这应该够用了</p><p>跟数据有关的 API，Vue 有 Vuex，React 有 React / Recoil。他们本身也会遵循单向数据流</p><p>所以，到底是哪里需要在 React 环境中引入一个不属于数据驱动的东西。或者换个思路（挖个坑）：</p><p><strong>我们是否正在被框架绑定？一个本只是视图层框架，现在还包含了逻辑层？</strong></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9E%B6%E6%9E%84%E6%80%9D%E8%80%83/">架构思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/vue/">vue</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/11/24/why-not-eventbus/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 一起玩吧</title>
      <link>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</link>
      <guid>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/</guid>
      <pubDate>Fri, 03 Sep 2021 17:52:52 GMT</pubDate>
      
      <description>&lt;p&gt;稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-4&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;启动页面、得分牌&lt;/li&gt;
&lt;li&gt;加入简单的 AI&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-4">TL;DR</h2><ul><li>启动页面、得分牌</li><li>加入简单的 AI</li></ul><span id="more"></span><h2 id="完成情况-2">完成情况</h2><p>这把已经像一个游戏了。所以，可以一起玩吧</p><p>以下是记录本次更新一部分内容</p><h3 id="UI">UI</h3><p>目前是加了一个标题场景，但是过于没东西讲。老前端熟悉的 <code>flex</code> 布局思路一通搞完事</p><h4 id="切换场景">切换场景</h4><p>游戏是按场景(scene)来区分页面(非常前端的描述)，比如关卡类游戏一般会做很多 level 的场景。不同的是这可没有所谓的路由，而是直接切换(change)</p><p>这里使用的是：获取场景树，得到实例，切换场景(change_scene)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get_tree()-&gt;change_scene(path);</code></pre><p>这个项目里的实现是：把这种按钮直接做成「组件」，暴露场景接口。在标题场景 <code>connect</code> 所有这个类型的事件，用统一事件处理跳转。这样就封装了跳转场景，方便以后处理设置界面啥的</p><h4 id="记分牌动画">记分牌动画</h4><p>有一个控件 <code>AnimationPlayer</code> ，用来控制能访问到的节点的动画，例如运动、变形。如果使用过 <code>flash</code> 那是相当熟悉 —— 关键帧打起来</p><h3 id="加入-AI">加入 AI</h3><p>周伯通虽然也行，但是自己玩还是得有个「对手」</p><p>现在看到 AI 人就不知觉紧张起来，感觉是个非常难的东西。其实 AI 就只是「人工智能」，其目的就是「假装是个人」，那游戏 AI 就是「假装有个陪你打游戏的人」。只不过现在的「机器学习」确实给游戏 AI 也带来了不少想象力 —— 他们的操作越来越像人的思维方式了</p><p>多智能还得看开发者。例如中小学机器人编程比赛中的经典项目足球项目和灭火项目，</p><blockquote><p>足球项目：最简单的逻辑就是通过传感器（指南针）判断两边方向，超声波测距，忘记什么传感器用来找球。摸到球之后直接把球往对方门里「撞」，完事。</p></blockquote><blockquote><p>灭火项目：都带着指南针和热力传感，主要还是看谁的寻路比较nb</p></blockquote><p>游戏 AI 很早就有，最经典的游戏 AI 还属南梦宫的吃豆人(pacman)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（对于我来说一样属于游戏设计必修课，甚至机器学习也可以）。</p><blockquote><p>一共四个干扰怪物，逻辑都不相同</p><p>红色 blinky：追着豆子，通过寻路算法找距离最近的路线<br>粉色 pinky：追豆子前方第四个格子，通过寻路算法找距离最近的路线。如果向上移动，则是左上方四个格子<br>青色 lnky：blinky 与豆子各自前方射线的交点，并两倍延长的点<br>橙色 clyde：追豆子到方圆 8 格内就会散开（纯气氛组）</p><p>四个单个逻辑不复杂且工作量很小的 AI，组合成一个看似一直在围堵玩家的敌方小队。这就是最经典的地方</p></blockquote><p>这篇文章再开个坑：我要写一篇我对游戏 AI 的理解。例如游戏设计中，一些非常难的 gameplay 可能会设计出让 AI 「放水」，让玩家以为 AI 真的翻车了，以此来鼓励玩家</p><p>好了，这一部分的重点本应该是这个游戏的 AI，目前的设计是： <strong>在自己的 y 与球的 y 距离大于 25 时，追球。25 差不多是板子的 1/4。</strong> 逻辑就这，没了</p><p>但别小看这简单的逻辑，在目前没有什么骚东西的环境下，只要没有什么花里胡哨的操作（例如拿板边去敲球）几乎没有胜利的机会。而现在这个环境玩骚的只会把自己的分骚没（比如我）</p><h3 id="冷却与重置">冷却与重置</h3><p>当球落某方门后，球会重置到游戏中点，没有操作，直接关闭了惯性和直接 set position</p><p>不过有一个小设计：败方接球。如果某方上一回合输了，这一回合由该方接首发球</p><p>所以，虽然是可以玩了，但是还是缺东西，比如很多关于游戏规则的完善</p><h2 id="下一步">下一步</h2><ul><li>发球 y 随机：目前发球的 y 是固定的，直接去接球点等球多没意思啊</li><li>随机首发球：第一球现在都发给左方，或许应该随机</li><li>胜利规则：现在这游戏一开就没边了…</li><li>暂停与结束界面</li><li>声音</li></ul><p>游戏补完之后，往后的更新就越来越慢了，因为想法越骚，实现也会越来越难</p><h2 id="Link">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82567889">游戏AI入门及AI优化</a></li><li><a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html">AnimationPlayer</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27177424">现代游戏AI的鼻祖——聊聊你所不知道的《吃豆人》</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/04/game-pong-enhance-2/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 发布</title>
      <link>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</link>
      <guid>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/</guid>
      <pubDate>Thu, 02 Sep 2021 15:55:09 GMT</pubDate>
      
      <description>&lt;p&gt;其实游戏已经做很远了，为了真实性删了很多添加的东西…&lt;/p&gt;
&lt;p&gt;本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错&lt;/p&gt;
&lt;p&gt;项目 &lt;a href=&quot;https://colmugx.github.io/godot-pong&quot;&gt;体验地址&lt;/a&gt;，&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/godot-pong&quot;&gt;项目地址&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-3&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;完成基本的击打、胜利条件、球的恢复&lt;/li&gt;
&lt;li&gt;编译与发布&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>其实游戏已经做很远了，为了真实性删了很多添加的东西…</p><p>本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-3">TL;DR</h2><ul><li>完成基本的击打、胜利条件、球的恢复</li><li>编译与发布</li></ul><span id="more"></span><h2 id="完成情况">完成情况</h2><p>基本的 gameplay 已经完成 —— 两块板子一个球，板子的后面是各自的「门」。</p><p>门选择 <code>Area2D</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，原因是这个控件专门控制物理状态与检查物理状态；墙壁使用<code>StaticBody2D</code></p><p>板子和球目前均使用 <code>KinematicBody2D</code>，因为可以方便的模拟物理状态，反弹完全不需要代码描述。但板子可能应该换成<code>RigidBody2D</code>，这样可以模拟更多的真实物理，例如摩擦力，受力。不过目前需要求证：控制端使用 <code>RigidBody</code> 是否合理</p><p>完全没什么好讲的，非常简单的实现</p><h2 id="编译与发布">编译与发布</h2><p>由于 <code>native</code> 的关系，运行时会把 cpp 编译，并编译成动态链接库。例如 osx 使用 <code>.dylib</code>，那么 web 跟原生相关的肯定是 <code>.wasm</code> 。官方提供了原生端的案例<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，而开发时也只编译了 osx 版本。</p><p>直到要验证发布到 github pages 时，出大问题，浏览器只显示 <code>abort(undefined)</code></p><h3 id="目前不能使用最新的-emscripten-编译你的-wasm">目前不能使用最新的 emscripten 编译你的 wasm</h3><p>经历各种尝试，例如直接从源码编译新的 template，但编译时也频出问题，甚至 debug 无法成功编译，接着进入无尽改编译参数等各种操作……</p><p>直到看到这个 issue <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>因为之前一直使用的 <code>emscripten</code> 版本已经是 26，所以猜<strong>是不是跟版本有关系，于是换成 17，成了</strong></p><p>于是有另一个猜想：<strong>官方发布的模板是否因为也使用 17 的版本发布，会导致 dll 对应不上。业务代码必须同样使用 17 编译代码才可以使用？</strong></p><h3 id="交给-github-action">交给 github action</h3><p>因为刚刚的 issue，发现这个作者对 godot 发布已经了然于胸，最后发现他提供了一个 ci 配置<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，于是参考这个配置写了一个工作流，现在可以把整个发布路程交到 github 了</p><h3 id="记得提交-export-presets">记得提交 export_presets</h3><p>可能可以发现，前面大部分 action 都是失败的</p><p>如果选择了 github 的 .gitignore 模板，这个文件默认会被忽略。但缺少这个文件 ci 无法工作 —— 获取不到发布配置</p><p>so，记得提交，接着等待一切结束。顺带一提，github action 的配置应该不高，编译 godot-cpp 属实膀胱局</p><p>下一篇应该讲有完整 UI 的第一个版本，结束</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/physics/using_area_2d.html">使用 Area2D</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative C++示例</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-cpp/issues/554">Building for HTML5 stopped working for emsdk 2.0.18+</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/2shady4u/godot-cpp-ci">2shady4u/godot-cpp-ci </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/09/02/game-pong-enhance-1/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>从零开始的 Pong Game - 介绍</title>
      <link>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</link>
      <guid>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/</guid>
      <pubDate>Sun, 29 Aug 2021 14:10:49 GMT</pubDate>
      
      <description>&lt;p&gt;做一个简单的项目介绍：&lt;/p&gt;
&lt;p&gt;使用 &lt;code&gt;godot engine&lt;/code&gt; 从零开始的 &lt;code&gt;pong game&lt;/code&gt; 开发。开发会尽量保持简单，但希望不缺挑战&lt;/p&gt;
&lt;p&gt;实现 &lt;code&gt;pong&lt;/code&gt; 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：&lt;strong&gt;不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作&lt;/p&gt;
&lt;p&gt;所以项目将会使用：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;godot 3 (gdnative)&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;C++&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;photopea（用来弄点素材）&lt;/li&gt;
&lt;li&gt;garageband / logic（声音）&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>做一个简单的项目介绍：</p><p>使用 <code>godot engine</code> 从零开始的 <code>pong game</code> 开发。开发会尽量保持简单，但希望不缺挑战</p><p>实现 <code>pong</code> 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：<strong>不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去</strong></p><p>这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作</p><p>所以项目将会使用：</p><ul><li>godot 3 (gdnative)</li><li><strong>C++</strong></li><li>photopea（用来弄点素材）</li><li>garageband / logic（声音）</li></ul><span id="more"></span><h2 id="你-TM-怎么想的">你 TM 怎么想的</h2><p>「在岸上永远学不会游泳」，这是在当时听到的兄弟对我说的一句话。<s>希望他不是因为嫌我菜让我爬而说出来的话</s></p><p>也为了记录，「如果单就以 pong 作为母版，到底能做到什么样子」，所以本身也是一个兴趣导向产物</p><p>这个系列还是不定期更新，甚至可能随时流产。流产的原因只有一个：搞不出来了…</p><p>就这样。下一篇先写一切的基础：如何让 pong 运行起来</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/">游戏开发</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/godot/">godot</category>
      
      <category domain="https://colmugx.github.io/blog/tags/cpp/">cpp</category>
      
      <category domain="https://colmugx.github.io/blog/tags/pong/">pong</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/08/29/game-pong-enhance-0/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>flutter desktop 能不能跨平台多窗口</title>
      <link>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/</link>
      <guid>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/</guid>
      <pubDate>Thu, 17 Jun 2021 15:34:21 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这篇文章极其具有时效性，在目前，&lt;code&gt;flutter&lt;/code&gt; 不支持多窗口，但是已经有&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY&quot;&gt;这么一篇文档&lt;/a&gt;&lt;sup class=&quot;footnote-ref&quot;&gt;&lt;a href=&quot;#fn1&quot; id=&quot;fnref1&quot;&gt;[1]&lt;/a&gt;&lt;/sup&gt;。而且 flutter desktop 的多窗口可能已经计划中了。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：&lt;code&gt;flutter&lt;/code&gt;。而且：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;flutter 使用 &lt;code&gt;skia&lt;/code&gt; 绘图而不是调用原生组件，表现统一&lt;/li&gt;
&lt;li&gt;flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;flutter 本就是先给移动端设计，可以直接用 &lt;code&gt;dart&lt;/code&gt; 完成很多工作。但是在调研桌面时发现一个问题：&lt;strong&gt;找不到多窗口 API！&lt;/strong&gt; 这不行。虽然 flutter 是允许原生编程，那我能会 &lt;code&gt;windows&lt;/code&gt; 开发吗？！&lt;/p&gt;
&lt;p&gt;等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/blog/Image/flutter-tauri-0.jpg&quot; alt=&quot;flutter-tauri&quot;&gt;&lt;/p&gt;
&lt;p&gt;把 flutter 套进 &lt;code&gt;electron&lt;/code&gt; 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）&lt;/p&gt;
&lt;p&gt;但是桌面端不选择 &lt;code&gt;electron&lt;/code&gt;，咱用 &lt;code&gt;tauri&lt;/code&gt;！毕竟现在全平台都 &lt;code&gt;webkit(blink)&lt;/code&gt;，而且 &lt;code&gt;flutter&lt;/code&gt; 使用 &lt;code&gt;canvaskit&lt;/code&gt;，不需要担心表现…&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这篇文章极其具有时效性，在目前，<code>flutter</code> 不支持多窗口，但是已经有<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">这么一篇文档</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。而且 flutter desktop 的多窗口可能已经计划中了。</p></blockquote><p>SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：<code>flutter</code>。而且：</p><ul><li>flutter 使用 <code>skia</code> 绘图而不是调用原生组件，表现统一</li><li>flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）</li></ul><p>flutter 本就是先给移动端设计，可以直接用 <code>dart</code> 完成很多工作。但是在调研桌面时发现一个问题：<strong>找不到多窗口 API！</strong> 这不行。虽然 flutter 是允许原生编程，那我能会 <code>windows</code> 开发吗？！</p><p>等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？</p><p><img src="/blog/Image/flutter-tauri-0.jpg" alt="flutter-tauri"></p><p>把 flutter 套进 <code>electron</code> 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）</p><p>但是桌面端不选择 <code>electron</code>，咱用 <code>tauri</code>！毕竟现在全平台都 <code>webkit(blink)</code>，而且 <code>flutter</code> 使用 <code>canvaskit</code>，不需要担心表现…</p><span id="more"></span><h2 id="准备工作">准备工作</h2><h3 id="初始化">初始化</h3><p><code>tauri</code> 采用的是「集成到项目」的方式，所以先创建一个 flutter 项目（创建步骤省略）</p><p>接着，根据文档<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>集成 tauri：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yarn add -D @tauri-apps&#x2F;cli$ yarn tauri init</code></pre><p>需要配置一些步骤。其中，<code>distDir</code> 选择的是 flutter 创建的 <code>web/</code>。开发地址暂时空过</p><h3 id="flutter-以服务运行">flutter 以服务运行</h3><p>与 electron 一样，tarui 运行的还是前端应用，所以要不执行 <code>index.html</code>，要不有个开发服务</p><p>flutter 直接调试会直接打开 chrome，所以这次运行换种方式：仅运行开发服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如果不指定端口，flutter 会随机一个高位端口，但每次启动都会更换端口flutter run -d web-server --web-port 4396</code></pre><p>flutter 服务没有热更，要更新的时候按 R <s>换弹</s> 更新</p><h3 id="配置-tauri-启动">配置 tauri 启动</h3><p>还记得刚刚漏了的运行地址？<code>tauri</code> 的配置都在 <code>tauri.conf.json</code> 中，找到 <code>devPath</code> 并补上</p><p>接着直接运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn tauri dev</code></pre><p>顺利的话就能直接看到窗口了</p><p><img src="/blog/Image/flutter-tauri.jpg" alt="flutter-tauri"></p><h2 id="开整">开整</h2><p>虽然标题只提到了「多窗口」，但 realworld 肯定无法避开原生操作。而且不管是 tauri 还是 electron 都需要用 <code>JavaScript</code></p><p>tauri 前后端（rust）通讯采用命令（command）的方式，同样是通过 event bus 互相抛事件来做到。所以我们要让一切 JavaScript 的工作桥接到 dart 上</p><p>tauri 提供了两种向后端通信的方式：直接用挂载在 <code>window</code> 的对象或者使用提供的包：<code>tauri-app</code>。这里暂时先用 <code>window</code>，但后者也可以满足，后面写 dartjs 互操作篇再覆盖</p><p>接下来分成两部分：需要实例化调用 与 不需要实例化调用</p><h3 id="不需要实例化">不需要实例化</h3><p>其实意思就是可以直接访问直接调用，不用 <code>new</code>。而在 tauri 中，向后端发起命令的函数位于：<code>window.__TAURI__.invoke</code></p><p>按照我们使用 JavaScript 的思路，调用一个对象下面的方法，思路就是直接一直点（.）下去。那么这就是一个<strong>访问多层上下文</strong>的过程</p><p>可以了，换成 dart 写出来</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; flutter 肯定有 dart，那肯定有 dart:jsimport &#39;dart:js&#39; as js;&#x2F;&#x2F; 获得 tauri 挂载的对象final tauri &#x3D; js.context[&#39;__TAURI__&#39;];&#x2F;&#x2F; 调用这个对象里面的方法tauri.callMethod(&#39;invoke&#39;, [&#39;&#39;]);</code></pre><h3 id="需要实例化">需要实例化</h3><p>总有（一堆）东西需要 <code>new</code>，多窗口就是其中一个。（这就离谱，多窗口竟然不由 rust 发起创建）</p><p>负责创建窗口的 API 位于：<code>window.__TAURI__.window.WebviewWindow</code><br>（更 NM 离谱的是直接明牌告诉你再加一个 webview）</p><p>那么，JavaScript 需要实例化，意味着<strong>需要在 dart 也实现一遍实例化</strong>作为映射。等于我们要在 dart 有一个对应的 class，有 class 才能 new</p><p>dart 里边儿能有这玩意儿吗！那妹有怎么办啊？造啊！</p><p>这次不能用<code>dart:js</code>，得换一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">flutter pub add js</code></pre><p>然后是模拟一切。首先最好先创建一个新文件，这个文件会被声明为某个可以被 <code>JavaScript</code> “发现”的 library</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS()library tauri; &#x2F;&#x2F; 实际上在这篇文章这块没卵用import &#39;package:js&#x2F;js.dart&#39;;</code></pre><p>接着，这波我们要实例化的是 <code>WebviewWindow</code>，位于 <code>window.__TAURI__.window.WebviewWindow</code></p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;&#125;</code></pre><p>那 class 要能 new，得有一个 <code>constructor</code>，dart 和某些其他语言一样，再写一遍类名。其他方法该怎么写怎么写</p><p>再看一眼 tauri 文档，<code>WebviewWindow</code> 实例化带两个参：<code>label</code> 和 <code>options</code>，<code>options</code>是一个对象，关于新窗口的配置</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, Object options);&#125;</code></pre><p>再看一眼文档，<code>options</code> 的 type 是 <code>WindowOptions</code>，所以这里可以如法炮制，再造出一个结构</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title, &#x2F;&#x2F; 文章例子仅需要 title  &#125;);&#125;</code></pre><p>这样写的结构，仅支持 <code>getter</code>，所以如果需要 <code>setter</code>，可以按照 dart 的方式改写这个 class</p><p>接着把上面的改一下。完整的代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; tauri.dart@JS()library tauri;import &#39;package:js&#x2F;js.dart&#39;;@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, WindowOption options);&#125;@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title,  &#125;);&#125;</code></pre><p>在<code>main.dart</code>创建一个新的按钮用来测试</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">ElevatedButton(  onPressed: () &#123;    final window &#x3D; WebviewWindow(      &quot;new_window&quot;,      WindowOption(title: &quot;Second Window&quot;),    );  &#125;,  child: Text(&#39;click&#39;),)</code></pre><p>完结撒花，结果不给图</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">Desktop Multi-Window Support (PUBLICLY SHARED)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://tauri.studio/en/docs/usage/development/integration">Tauri Integration</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/flutter/">flutter</category>
      
      <category domain="https://colmugx.github.io/blog/tags/tauri/">tauri</category>
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/06/17/flutter-tauri/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>组件化与工程设计</title>
      <link>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</link>
      <guid>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/</guid>
      <pubDate>Tue, 16 Feb 2021 05:41:55 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;这是又一篇臆想文&lt;br&gt;
如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;TL-DR&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;组件化在做什么，组件是什么&lt;/li&gt;
&lt;li&gt;因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以是什么时候前端开发也发展成需要「软件工程」的时代了，&lt;s&gt;还不是现在用户的电脑越来越 nb 浏览器越来越 nb&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……&lt;/p&gt;
&lt;p&gt;演变到这就产生一个问题&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>这是又一篇臆想文<br>如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。</p></blockquote><h2 id="TL-DR">TL;DR</h2><ul><li>组件化在做什么，组件是什么</li><li>因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计</li></ul><p>所以是什么时候前端开发也发展成需要「软件工程」的时代了，<s>还不是现在用户的电脑越来越 nb 浏览器越来越 nb</s></p><p>工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……</p><p>演变到这就产生一个问题</p><span id="more"></span><h2 id="问题">问题</h2><p>印象中的 toC 应用，它对于「历史包袱」的处理可以非常简单粗暴：</p><blockquote><p>都拖油瓶了，这不重构？顺道抬 KPI<br>既然都重构了，那整点新家伙，干活不累顺道抬 KPI (x2)</p></blockquote><p>所以 toC 应用总是会用上最新的技术，而且 toC 应用毕竟是直接面向个体用户的应用，所以无时无刻都在优化体验也说不定</p><p>但 toB 或者内部平台可不能说整就整，至少会遇到这些问题：</p><ul><li>“能用就行”</li><li>使用时间非常长，甚至可能公司开多久软件用多久</li></ul><p>如果再遇上几个持有「Promise没用过，应该是 vue 新加的功能」<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>观点的优质前端，这个应用的代码最后只能是 shit 了</p><h2 id="组件化">组件化</h2><p>我的二面可能会问一个没有什么正确答案也没什么理由的烂问题：</p><blockquote><p>如何理解组件化？</p></blockquote><p>但总能得到典型回答：</p><blockquote><p>工作中经常重复出现的功能<strong>抽</strong>成组件</p></blockquote><p>甚至是非典型回答：</p><blockquote><p>因为现在都用 vue，每一个 .vue 都是组件，这是 vue 要求的</p></blockquote><p>其中最经常得到的答案中，有一个关键动作：抽。所以又是什么时候组件化的定义变成了“抽组件”</p><h3 id="何为组件">何为组件</h3><p>在「C4模型」的官网中，关于组件的第一句话：</p><blockquote><p>The word “component” is a <strong>hugely overloaded term</strong> in the software development industry,</p></blockquote><p>很多地方其实都有组件概念，包括不限于 <code>sketch</code> 等设计应用都有组件概念。但一切都有相似之处：它们都可以是一个原子，一个单位，一个定义了接口能优秀完成某一部分工作的单位或者说 group。同理也适用于 sketch component —— 你定义了一个组件应该是怎样的元素构成与可变</p><p>所以上面的那句话，有后半句的：</p><blockquote><p>but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface.</p><p>If you’re using a language like Java or C#, the simplest way to think of a component is that it’s a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p></blockquote><h3 id="为什么开始强调组件了">为什么开始强调组件了</h3><p>确实没错，当前流行三大视图框架中，都有组件概念，即一个 vue 文件之于 vue，一个函数之于 react，一个 component 之于 ng 都是各领域定义的“组件”，甚至是「一切都是组件」。但这仅是强调了这是某个框架的原子，而<strong>业务形态的组件是由业务的，而不是框架决定的</strong>。</p><p>所以一个组件，并不是把代码放在一个 vue 文件，这个就是组件。毕竟你这个时候你可以问：你的应用下是不是有一个 <code>pages</code> 目录？下面也有一堆 vue 文件，他们每一个都是组件？接着你就尽情围观前端圈内最大双标现场</p><h3 id="怎样就是一个组件">怎样就是一个组件</h3><p>我自己给定义了几点：</p><ul><li>输入输出是确定的（像函数）</li><li>可单元测试的</li><li>“高内聚，低耦合”（现在还写这句话都觉得有些羞耻）</li></ul><p>举个例子，拿我以前很喜欢的某公司的官网做栗子（我觉得还是憋猜是哪个公司了吧，我给🐴成这样还猜得到？）</p><p><img src="/blog/Image/component-1.png" alt=""></p><p>这张图，大多数前端会认为，红框可以是组件。<s>甚至认为绿框在某开源组件库能找到</s></p><p><img src="/blog/Image/component-2.png" alt=""></p><p>放心我没⭕️ 错，很多前端都会这么想的。全都 <code>margin-top</code> 给它安排得明明白白，这样最后一个就不用处理了</p><p>但总有一部分的前端会这么认为：</p><p><img src="/blog/Image/component-3.png" alt=""></p><p>这样做几个好处：</p><ul><li>因为可以让组件弹性方便布局。</li><li>那个小标题<strong>肯定复用很多，别的地方也会有类似设计</strong></li><li><s>上下边距啊，在 <strong>page</strong> map 组件的时候<strong>给套上不就好了</strong></s></li></ul><p>所以很少前端会想到以下甚至更多：</p><p><img src="/blog/Image/component-4.png" alt=""></p><p>所以先弄清楚：<strong>谁是原子</strong>？</p><p>也就是「哪些是组件？」<strong>这个问题在设计阶段就应该确定了，而不是“抽成组件”</strong></p><p>所以在软件开发上，本就没有所谓的前端后端啥端的区别，软件该怎么写就得怎么写。一个组件可以是一个对象</p><p>而这<strong>还只是布局而已</strong>，也就是所谓前端工程师的「核心工作」</p><h2 id="工程化">工程化</h2><p>说实话，当今被冠以「工程师」之名的前端开发，没有几个懂工程（包括写这篇文章的five）</p><p>问题在于越来越多的软件都希望以浏览器为容器运行。所以并不是前端需要工程化，而是软件形态在发生改变。而这也可以继续解释下来会发生的事情 —— JavaScript 会越来越不顶用，需要 WebAssembly 做更多事情；使用 Web Worker 做跟渲染无关的事情等等等等</p><p>再同理，并不是开始要求前端开发需要懂工程了，而是这是一个软件工程师要知道的东西</p><h3 id="什么时候前端也要工程设计了">什么时候前端也要工程设计了</h3><p>是个应用就需要设计，或者说<strong>前端一直需要工程设计</strong>，只不过长时间被认为不需要和不被理解</p><p>最近的「微前端」更多的适用场景也是建立于此 —— 太旧的应用你实在维护不动了，新增的东西就以「微前端」的形式加入，这样做不破坏原本的应用，同时可以用较新的技术维护新功能</p><p>toB 大应用，在「前端」内容中更多是表单表格，以及很多弱交互的东西，可能最重的交互也就可视化配置。其注定了不需要设计驱动，更多的都在数据处理上，也就是「弄清数据流」。并且这类应用只会越做越大 <s>（直到流产，或者换老板）</s>，而且它的直接用户是另一个企业，甚至可能是以「私有部署」的形式售卖。所以要做的是尽可能稳定与高效</p><p>所以为了运行稳定不背锅，不让数据水乱流，只能跟传统软件，甚至是最亲近的后端服务的做法一样，做架构设计</p><p>而那些认为「按照原型实现 page component」的前端们，看看你的应用，是不是正在 <strong>「同一个接口在同一时间请求了好几遍，甚至是开一个弹窗再把相同数据请求个几遍？」</strong>。就这还敢把 Angular 作为鄙视链底层，谁给的勇气？<s>所以胆小的已经在用 dva(umi) 了</s></p><p>我又突然想到一次经历，我问过一个问题：</p><blockquote><p>你这里写了期望是前端架构师，精通前端架构。那你觉得前端架构需要做到什么？</p></blockquote><p>然后我得到一个非 常 满 意的回答：</p><blockquote><p>前端架构就是制定目录结构，接着指定代码规范，用什么组件库 balabala…</p></blockquote><p>那行呗，你开心就好，现在连 webpack 都不兴提一嘴了</p><h3 id="那咋做嘛">那咋做嘛</h3><p>提前说明，前端工程逃不过使用很多工具，包括构建与编译等。这里不讨论以上问题，只有编程「思想」</p><p>扒拉一段软件工程的含义：</p><blockquote><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p></blockquote><p>另外，IBM 的大型机之父布鲁克斯发布了《没有银弹》：</p><blockquote><p>从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等</p></blockquote><p>这里提到了「结构化程序设计」：</p><blockquote><p>结构化编程，一种编程典范。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><p>其实说到底总会有几点：</p><ul><li>高性能</li><li>高可用</li><li>高稳定</li><li><strong>可维护</strong></li></ul><p>关于可维护，这个时候可以来几个经典问题，问问自己，我现在在写的这个应用：</p><ul><li>是否有自动测试：unit test, e2e test？</li><li>是否会出现：点一个地方，哪哪都在 loading？（排除你偷懒连 loading 都不给）</li><li>一样的模块，在不同地方显示是不一样的？</li><li>一旦有一个样式改动，需要改十几个文件？</li></ul><p>这个时候，「组件」思想又被抬上台面，毕竟 <strong>组件化即一种分治思想</strong>。如果逃离了这个，那么单元测试就无法实现，因为<strong>此刻不存在单元</strong>，第一个问题不攻自破</p><p>接着，因为在应用之初根本没对应用进行设计，每个人拿着原型就开始整，最后各自写各自的，数据流都在某个组件里维护。接着产品经理要求「各数据展示需要同步」的时候怎么办？还不是指着产品骂娘然后做了一手操作：在产生 update 的地方后再 fetch 一次数据。所以第二个问题接着不攻自破</p><p>那怎么做其实非常明了：</p><ol><li>应用设计：在应用之初规划数据流</li><li>interface：看起来像爽哥，声音像爽哥，那就是爽哥</li></ol><p>数据流在设计之初就很好办，遇事不决先抄一版 flux —— 用 store 管理各种列表的数据和状态；列表页可以 keep-alive，根据 route 流向决定 store 的更新；VM 做成订阅/发布模型，这样，数据发起更新后，正在订阅数据的 V 可以做出更新……</p><p><strong>别信某些平台的前端爽文。什么 vuex/redux 等被称为状态管理的 library，只能用来管理共享状态，不能用来存放业务数据。Angular 看到这场景不得当场笑裂开</strong></p><p>到这也会发现，各种「台」的大型应用，最后也都是面向对象的思想。应用一旦复杂起来就需要一个充血模型。<s>那就更好办了，前端也直接 DDD ！直接嫖了后端的架构设计图</s></p><p>（顺便非常推荐《人月神话》，即使土，但45年依然流行是有道理的，其对于软件工程和项目管理的经验还有参考价值）</p><h2 id="最后">最后</h2><p>本来写这个文章的时候是想把遇到的事情都嘴臭一遍的，最后还是把这部分都清干净了，作为一个可能有用的文字。在此特别感谢若干 toB 项目，这几年在 toB 的公司中摸爬滚打带给我的一些新（旧）灵感（都是嫖后端和 GUI 应用的），终于让我这种杂学玩家体现出一点点作用</p><p>同时践行「敏捷开发」也有一段时间了，足够扎实的设计才能敏捷，不然就变成永远在填坑，而不是敏捷</p><p>所以这篇文章也作为开始，现在正在实践把「领域驱动设计」和「C4 模型」带到前端开发中。没错，又想开一个博文坑…</p><p>越来越觉得，前端架构设计可以参考 <code>rust</code> 的 <code>trait</code>，或者 <code>swift</code> 的 <code>protocol</code>，以及他们的设计模式。主观上觉得他们在思想有点相似</p><p>（不知道下次轮到我去面试时，恰好我的面试官看了我的博客，拿这玩意儿狙我…）</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://c4model.com/">The C4 model for visualising software architecture</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">维基百科 - 软件工程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">维基百科 - 结构化编程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">维基百科 - 敏捷软件开发</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科 - 领域驱动设计</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>一次面试发生的真实案例。并提出了「async 要配合 axios 才能用；ajax 没人用了」等理论 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E6%80%9D%E8%80%83/">前端思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E7%BB%84%E4%BB%B6%E5%8C%96/">组件化</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</category>
      
      
      <comments>https://colmugx.github.io/blog/2021/02/16/component-and-engineering/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>再一次重新设计简历</title>
      <link>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</link>
      <guid>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/</guid>
      <pubDate>Wed, 11 Nov 2020 15:22:24 GMT</pubDate>
      
      <description>&lt;p&gt;最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，&lt;s&gt;不同的 HR&lt;/s&gt;&lt;br&gt;
于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。&lt;s&gt;（确认是追了个寂寞）&lt;/s&gt;&lt;/p&gt;
&lt;p&gt;但这不是本文重点，这里将要讲新的 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 一同带来的新简历模板的设计思路&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Resumer&lt;/code&gt; 正在用 &lt;code&gt;Angular 10&lt;/code&gt; 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…&lt;/p&gt;
&lt;p&gt;所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resume&quot;&gt;Resume&lt;/a&gt;、&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/resumer&quot;&gt;Resumer&lt;/a&gt; 和 Resumer(ng version)&lt;/p&gt;
&lt;h2 id=&quot;请停止使用这种模板&quot;&gt;请停止使用这种模板&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><span id="more"></span><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%80%83/">设计思考</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/%E8%AE%BE%E8%AE%A1/">设计</category>
      
      <category domain="https://colmugx.github.io/blog/tags/%E7%AE%80%E5%8E%86/">简历</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/11/11/why-redesign-cv/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我又不跨平台我为什么要 electron</title>
      <link>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</link>
      <guid>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/</guid>
      <pubDate>Sat, 08 Aug 2020 09:24:29 GMT</pubDate>
      
      <description>&lt;blockquote&gt;
&lt;p&gt;无图版，会更有图版&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2 id=&quot;背景&quot;&gt;背景&lt;/h2&gt;
&lt;p&gt;上篇文章（最近总是莫名联动）才写了 electron，主观感受，&lt;code&gt;electron&lt;/code&gt; 有这么些好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使得前端技术可以运用在本地桌面应用&lt;/li&gt;
&lt;li&gt;跨平台&lt;/li&gt;
&lt;li&gt;&lt;code&gt;Chromium&lt;/code&gt; 让兼容性不是首要考虑对象&lt;/li&gt;
&lt;li&gt;通过 &lt;code&gt;NodeJS&lt;/code&gt; 既可以操作系统，也能利用本身能力与生态&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;但是：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;我好像不需要跨平台&lt;/li&gt;
&lt;li&gt;原生开发更加能操作系统 API&lt;/li&gt;
&lt;li&gt;扯破大天不就是&lt;code&gt;webview&lt;/code&gt;嘛&lt;/li&gt;
&lt;li&gt;依然不需要考虑兼容性，并且体积会大幅减小&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;所以，electron 再见！&lt;/p&gt;
&lt;h2 id=&quot;思路&quot;&gt;思路&lt;/h2&gt;</description>
      
      
      
      <content:encoded><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><span id="more"></span><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let menubar &#x3D; NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)let popover &#x3D; NSPopover()</code></pre><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; if let 爽啊！if let menuBtn &#x3D; menubar.button &#123;   menuBtn.title &#x3D; &quot;click&quot;   menuBtn.action &#x3D; #selector(togglePopover)&#125;&#x2F;&#x2F; 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到let popoverController &#x3D; NSStoryboard(name: &quot;Main&quot;, bundle: nil)  .instantiateController(withIdentifier: &quot;PopoverViewController&quot;) as? PopoverViewControllerpopover.behavior &#x3D; .transientpopover.contentViewController &#x3D; popoverController</code></pre><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">@objc func togglePopover(_ sender: AnyObject) &#123;    if popover.isShown &#123;        closePopover(sender)    &#125; else &#123;        showPopover(sender)    &#125;&#125;</code></pre><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; 其实本文其实用不到，先写着extension PopoverViewController: WKNavigationDelegate &#123;&#125;</code></pre><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">webview.navigationDelegate &#x3D; self&#x2F;&#x2F; 通过 userContentController 获取 webview 中的事件let contentController &#x3D; webview.configuration.userContentController&#x2F;&#x2F; 定义与前端交互的方法名contentController.add(self, name: &quot;hello&quot;)</code></pre><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let pagePath &#x3D; Bundle.main.url(forResource: &quot;index&quot;, withExtension: &quot;html&quot;, subdirectory: &quot;build&quot;)&#x2F;&#x2F; let devUrl &#x3D; URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)&#x2F;&#x2F; load 方式也不同，一种是加载文件，一种直接加载 urlwebview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())&#x2F;&#x2F; webview.load(devUrl)</code></pre><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">extension PopoverViewController: WKScriptMessageHandler &#123;    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;        if message.name &#x3D;&#x3D; &quot;hello&quot; &#123;            &#x2F;&#x2F; 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转            let body &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)            &#x2F;&#x2F; 这里完全可以通过 switch 做模式匹配，不过这里没有            if (body[&quot;type&quot;] as! String) &#x3D;&#x3D; &quot;notify&quot; &#123;              let value: String &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)[&quot;value&quot;] as! String              showNotification(title: value)            &#125;        &#125;    &#125;    &#x2F;&#x2F; 调用通知 api，显示通知    func showNotification(title: String) &#123;        let notification &#x3D; NSUserNotification()        notification.deliveryDate &#x3D; Date(timeIntervalSinceNow: 1)        notification.title &#x3D; title        NSUserNotificationCenter.default.deliver(notification)    &#125;&#125;</code></pre><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 点击按钮弹出通知const handleClick &#x3D; () &#x3D;&gt; &#123;  window.webkit.messageHandlers.hello.postMessage(&#123;type: &#39;notify&#39;, value: &quot;Hello World&quot;&#125;)&#125;</code></pre><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结-2">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/swift/">swift</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/08/08/hi-swift-react/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 electron 爬图片</title>
      <link>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</link>
      <guid>https://colmugx.github.io/blog/2020/06/21/electron-crawler/</guid>
      <pubDate>Sun, 21 Jun 2020 03:51:10 GMT</pubDate>
      
      <description>&lt;p&gt;有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了&lt;br&gt;
&lt;strong&gt;（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;想了一下，切图仔唯一高效 GUI 的选型只有 &lt;code&gt;electron&lt;/code&gt; 了，没得选。但是这次有点特别，因为 &lt;code&gt;electron&lt;/code&gt; 的特殊性，我有了些想法&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这里用的模板是之前实验服务一体化的模板 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/colmugx/electron-react-koa-template&quot;&gt;electron-react-koa-template&lt;/a&gt;，然后删除了&lt;code&gt;server&lt;/code&gt;…&lt;/p&gt;
&lt;p&gt;删了&lt;code&gt;server&lt;/code&gt;……&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-2&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;webview&lt;/li&gt;
&lt;li&gt;获取资源&lt;/li&gt;
&lt;li&gt;提供下载&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR-2">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><span id="more"></span><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const webview &#x3D; document.createElement(&#39;webview&#39;)&#x2F;&#x2F; 当页面加载完成之后会触发这个事件，可以继续做接下来的事情webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)</code></pre><p>于是封装一下变成</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  const webview &#x3D; document.createElement(&#39;webview&#39;)  &#x2F;&#x2F; 保险起见  webview.useragent    &#x3D; &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) &#39;    + &#39;AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;    + &#39;Chrome&#x2F;81.0.4044.129 Safari&#x2F;537.36 Edg&#x2F;81.0.416.68&#39;  webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)  document.body.appendChild(webview)  this.webview &#x3D; webview&#125;search(url) &#123;  this.webview.src &#x3D; url&#125;</code></pre><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">mainWindow &#x3D; new BrowserWindow(&#123;  webPreferences: &#123;    &#x2F;&#x2F; 这里    webviewTag: true,    nodeIntegration: true,  &#125;,&#125;)</code></pre><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then((html) &#x3D;&gt; &#123;  &#125;);</code></pre><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;  webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then(html &#x3D;&gt; &#123;    ipcRenderer.send(&#39;ganhuo&#39;, html)  &#125;);&#125;)</code></pre><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ipcMain.on(&#39;ganhuo&#39;, (e, arg) &#x3D;&gt; &#123;  const $ &#x3D; cheerio.load(arg)  &#x2F;&#x2F; 各种教程都能看到的  &#x2F;&#x2F; 这里没多余操作，是个 img 就拿走  &#x2F;&#x2F; 接着 reply 回 renderer  const imgs &#x3D; $(&#39;body&#39;).find(&#39;img&#39;).map((idx, ele) &#x3D;&gt; $(ele).attr(&#39;src&#39;)).get()  e.reply(&#39;chuhuo&#39;, imgs)&#125;)</code></pre><p><code>renderer</code> 边准备一个接收，这波结束</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  ipcRenderer.on(&#39;chuhuo&#39;, (e, result) &#x3D;&gt; &#123;    this.setState(&#123;      imgs: result,    &#125;);  &#125;);&#125;</code></pre><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接-2">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/electron/">electron</category>
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/21/electron-crawler/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>整一个家庭服务器记录</title>
      <link>https://colmugx.github.io/blog/2020/06/07/home-server/</link>
      <guid>https://colmugx.github.io/blog/2020/06/07/home-server/</guid>
      <pubDate>Sun, 07 Jun 2020 05:57:46 GMT</pubDate>
      
      <description>&lt;h2 id=&quot;准备&quot;&gt;准备&lt;/h2&gt;
&lt;p&gt;我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！&lt;/p&gt;
&lt;h3 id=&quot;系统选择&quot;&gt;系统选择&lt;/h3&gt;
&lt;p&gt;推荐三个：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.raspberrypi.org/downloads/raspbian/&quot;&gt;raspbian&lt;/a&gt;（树莓派）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://clearlinux.org/&quot;&gt;clear linux&lt;/a&gt;（英特尔CPU）&lt;/li&gt;
&lt;li&gt;&lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://www.debian.org/index.zh-cn.html&quot;&gt;debian&lt;/a&gt;（传统服务器系统）&lt;/li&gt;
&lt;li&gt;……&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><span id="more"></span><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后-2">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/NAS/">NAS</category>
      
      <category domain="https://colmugx.github.io/blog/tags/linux/">linux</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/07/home-server/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</link>
      <guid>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/</guid>
      <pubDate>Thu, 04 Jun 2020 14:30:36 GMT</pubDate>
      
      <description>&lt;p&gt;这应该是连载得最近的一次，书接上回：&lt;a href=&quot;/blog/2020/06/02/hammerspoon-ts/&quot;&gt;《或许可以用 TypeScript 编写 hammerspoon》&lt;/a&gt;（也就是下面那篇）&lt;/p&gt;
&lt;p&gt;这里只会描述通过 &lt;code&gt;TypeScript&lt;/code&gt; 实现的过程&lt;/p&gt;
&lt;p&gt;以下内容可能产生不适（因为&lt;code&gt;hammerspoon&lt;/code&gt;的 &lt;code&gt;d.ts&lt;/code&gt; 全是 &lt;code&gt;interface&lt;/code&gt; 一把梭，编码不好看）&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-5&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;创建界面&lt;/li&gt;
&lt;li&gt;实现剪贴板读取&lt;/li&gt;
&lt;li&gt;存储数据&lt;/li&gt;
&lt;li&gt;绑定快捷键&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR-5">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><span id="more"></span><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容const completionFn &#x3D; choice &#x3D;&gt; &#123;  &#x2F;&#x2F; 一般来说这个判断不可省略，这样可以方便排除取消的情况  if (choice) &#123;&#125;&#125;const chooser &#x3D; hs.chooser.new(completionFn)</code></pre><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">chooser.show()chooser.hide()</code></pre><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.readString() &#x2F;&#x2F; 读取最后一次剪贴板的文本pasteboard.readImage() &#x2F;&#x2F; 读取最后一次剪贴板的图片数据</code></pre><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.changeCount()</code></pre><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const clipboard &#x3D; new Clipboard()&#x2F;&#x2F; 我选择 1s 检查一次export const clipWatcher &#x3D; hs.timer.new(1, () &#x3D;&gt; &#123;  const now &#x3D; hs.pasteboard.changeCount()  if (now !&#x3D;&#x3D; preCount) &#123;    pcall(clipboard.save.bind(clipboard))    preCount &#x3D; now  &#125;&#125;)clipWatcher.start()</code></pre><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">save() &#123;  const types &#x3D; hs.pasteboard.contentTypes&lt;ModelChoice[&#39;type&#39;]&gt;()  for (const type of types) &#123;    if (isImgType(type)) &#123;      this.saveImage(type)    &#125; else if (isTextType(type)) &#123;      this.saveText(type)    &#125;  &#125;&#125;</code></pre><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">hs.hotkey.bind(clipboardConf.hotkey[0], clipboardConf.hotkey[1], () &#x3D;&gt; &#123;  clipboard.show()&#125;)</code></pre><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">this.chooser!.choices(choices)this.chooser!.show()</code></pre><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/04/hammerspoon-clipboard/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</link>
      <guid>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/</guid>
      <pubDate>Tue, 02 Jun 2020 14:59:20 GMT</pubDate>
      
      <description>&lt;p&gt;&lt;code&gt;lua&lt;/code&gt; 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 &lt;code&gt;cocos2d&lt;/code&gt; 的时候，就接触了这个语言&lt;/p&gt;
&lt;p&gt;&lt;code&gt;hammerspoon&lt;/code&gt; 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整&lt;/p&gt;
&lt;p&gt;早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了&lt;/p&gt;
&lt;p&gt;当然还有其他方案，比如常见的用到了 &lt;code&gt;moonscript&lt;/code&gt;，这是一个类 &lt;code&gt;coffeescript&lt;/code&gt; 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境&lt;/p&gt;
&lt;p&gt;前些日子关注到有一个项目 &lt;a target=&quot;_blank&quot; rel=&quot;noopener&quot; href=&quot;https://github.com/TypeScriptToLua/TypeScriptToLua&quot;&gt;TypeScriptToLua / TypeScriptToLua&lt;/a&gt;，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><span id="more"></span><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><pre class="line-numbers language-none"><code class="language-none">npm inityarn add typescript-to-lua --dev</code></pre><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;dev&quot;: &quot;tstl --watch&quot;,&quot;build&quot;: &quot;tstl&quot;</code></pre><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/TypeScript/">TypeScript</category>
      
      <category domain="https://colmugx.github.io/blog/tags/hammerspoon/">hammerspoon</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/06/02/hammerspoon-ts/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>docker 容器内通信</title>
      <link>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</link>
      <guid>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/</guid>
      <pubDate>Sun, 29 Mar 2020 10:00:28 GMT</pubDate>
      
      <description>&lt;p&gt;除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud&lt;/p&gt;
&lt;p&gt;最后整了一个本地 webdav 😆&lt;/p&gt;
&lt;p&gt;当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云&lt;/p&gt;
&lt;p&gt;docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了&lt;/p&gt;
&lt;p&gt;**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的&lt;/p&gt;
&lt;p&gt;所以，水一篇文，单纯记录一下&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><span id="more"></span><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network create -d bridge my-bridge</code></pre><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --network my_bridge [...]</code></pre><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9B%B2%E8%8B%91%E6%9D%82%E5%9D%9B/">曲苑杂坛</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/docker/">docker</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/03/29/docker-container-bridge/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>利用 Context 传递多语言文本</title>
      <link>https://colmugx.github.io/blog/2020/01/31/react-translate/</link>
      <guid>https://colmugx.github.io/blog/2020/01/31/react-translate/</guid>
      <pubDate>Fri, 31 Jan 2020 06:38:39 GMT</pubDate>
      
      <description>&lt;p&gt;Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…&lt;/p&gt;
&lt;p&gt;找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上&lt;code&gt;react-intl&lt;/code&gt;，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个&lt;/p&gt;
&lt;p&gt;但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 &lt;code&gt;gatsby-plugin-i18n&lt;/code&gt; 或者 &lt;code&gt;react-intl&lt;/code&gt; 就可以了&lt;/p&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><span id="more"></span><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; createContext &#125; from &#39;react&#39;const langContext &#x3D; createContext(&#123;&#125; as ContextInterface)&#x2F;&#x2F; 创建上下文后输出 Provider 和 Consumer 还是要的export const Provider &#x3D; langContext.Providerexport const Consumer &#x3D; langContext.Consumer&#x2F;&#x2F; ps: 其实 Consumer 用不上...</code></pre><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const genTranslate &#x3D; (lang: string) &#x3D;&gt; &#123;  const _message &#x3D; require(&#96;@&#x2F;lang&#x2F;$&#123;lang&#125;.json&#96;)  if (!_message) &#123;    throw Error(&#96;$&#123;lang&#125; language json was not found.&#96;)  &#125;  const formatMessage &#x3D; (&#123; id, defaultMsg &#125;: FormatMessageType): string &#x3D;&gt;    &#x2F;&#x2F; _get 来自 lodash    _get(_message, id) || defaultMsg || &#39;&#39;  const formatter &#x3D; () &#x3D;&gt; (&#123; formatMessage, _message &#125;)  return formatter()&#125;</code></pre><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const useIntl &#x3D; (): ContextInterface &#x3D;&gt; useContext(langContext)</code></pre><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const &#123; formatMessage: t &#125; &#x3D; useIntl()</code></pre><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E5%89%8D%E7%AB%AF%E5%AE%9E%E8%B7%B5/">前端实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/react/">react</category>
      
      <category domain="https://colmugx.github.io/blog/tags/i18n/">i18n</category>
      
      
      <comments>https://colmugx.github.io/blog/2020/01/31/react-translate/#disqus_thread</comments>
      
    </item>
    
    <item>
      <title>创建一个 rust web server</title>
      <link>https://colmugx.github.io/blog/2019/12/29/try-actix/</link>
      <guid>https://colmugx.github.io/blog/2019/12/29/try-actix/</guid>
      <pubDate>Sun, 29 Dec 2019 04:29:34 GMT</pubDate>
      
      <description>&lt;p&gt;玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 &lt;code&gt;perfect&lt;/code&gt; 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。&lt;br&gt;
rust 社区中关注了 &lt;code&gt;rocket&lt;/code&gt; 一段时间，后面发现 &lt;code&gt;actix-web&lt;/code&gt; 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。&lt;/p&gt;
&lt;p&gt;这里会以重构我的闹钟后端作为蓝本，逐步做个记录。&lt;/p&gt;
&lt;h2 id=&quot;TL-DR-7&quot;&gt;TL;DR&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;直接用 &lt;code&gt;cargo&lt;/code&gt; 创建应用&lt;/li&gt;
&lt;li&gt;装载 &lt;code&gt;actix-web&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;写一个 api&lt;/li&gt;
&lt;/ul&gt;</description>
      
      
      
      <content:encoded><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR-7">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><span id="more"></span><h2 id="创建应用-2">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]actix-web &#x3D; &quot;2.0&quot;actix-rt &#x3D; &quot;1.0&quot;# envdotenv &#x3D; &quot;0.15.0&quot;log &#x3D; &quot;0.4.8&quot;env_logger &#x3D; &quot;0.7.1&quot;</code></pre><p>然后在<code>main.rs</code>创建启动函数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use actix_web::&#123;App, HttpServer, get&#125;;#[get(&quot;&#x2F;&quot;)]fn index() -&gt; HttpResponse &#123;    HttpResponse::Ok().body(&quot;Hello World&quot;)&#125;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new().service(index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await&#125;</code></pre><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+-- src| +-- controller| | +-- mod.rs| +-- services| | +-- mod.rs| +-- models| | +-- mod.rs| +-- middleware| | +-- mod.rs</code></pre><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]# serdeserde &#x3D; &quot;1.0.104&quot;serde_derive &#x3D; &quot;1.0.104&quot;serde_json &#x3D; &quot;1.0.44&quot;json &#x3D; &quot;0.12.0&quot;</code></pre><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use serde_derive::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Clone)]pub struct Payload&lt;T&gt; &#123;    pub code: isize,    pub message: String,    #[serde(skip_serializing_if &#x3D; &quot;Option::is_none&quot;, default)]    pub payload: Option&lt;T&gt;,&#125;</code></pre><p>接着，从<code>controller/index</code>开始</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[derive(Deserialize)]struct Info &#123;    message: String&#125;#[get(&quot;&#x2F;&quot;)]pub async fn index(query: web::Query&lt;Info&gt;) -&gt; Result&lt;HttpResponse, Error&gt; &#123;    &#x2F;&#x2F; 在Query拿到与 Info 结构一样的参数    &#x2F;&#x2F; 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理    &#x2F;&#x2F; rust 真严格..    let result &#x3D; crate::services::index::get_helloworld(query.message.clone());    Ok(HttpResponse::Ok().json(result))&#125;</code></pre><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use crate::models::payload::Payload;&#x2F;&#x2F; 简单写一个服务pub fn get_helloworld(msg: String) -&gt; Payload&lt;()&gt; &#123;    Payload &#123;        code: 0,        message: msg.to_string(),        payload: None    &#125;&#125;</code></pre><p>最后改一下<code>main.rs</code></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">+mod controllers;+mod models;+mod services;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new()-        .service(index);+        .service(controllers::index::index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await</code></pre><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;code&quot;: 0,    &quot;message&quot;: &quot;helloworld&quot;&#125;</code></pre><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content:encoded>
      
      
      <category domain="https://colmugx.github.io/blog/categories/%E6%9C%8D%E5%8A%A1%E5%AE%9E%E8%B7%B5/">服务实践</category>
      
      
      <category domain="https://colmugx.github.io/blog/tags/rust/">rust</category>
      
      <category domain="https://colmugx.github.io/blog/tags/actix/">actix</category>
      
      
      <comments>https://colmugx.github.io/blog/2019/12/29/try-actix/#disqus_thread</comments>
      
    </item>
    
  </channel>
</rss>
