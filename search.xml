<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>我早就想拿 QuickJS 做 SSR 了</title>
      <link href="/blog/2022/12/12/quickjs-ssr/"/>
      <url>/blog/2022/12/12/quickjs-ssr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鸽了一年，不重要，下一篇解释</p></blockquote><p>现在几乎现代框架 SSR 默认都是用 <code>node</code>，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 <code>React</code> 举例子，SSR 分两个步骤：</p><ol><li>静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 <code>renderToString</code></li><li>运行时水合，也就是不用 <code>render</code> 而是 <code>hydrate</code>，因为已经不需要在运行时创建节点，只需要绑定</li></ol><p>所以问题就很清晰：默认或者常规手段的 <code>hydrate</code> 和 <code>renderToString</code> 都是 JS 函数</p><p>当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：<strong>这 B 是不是可以直接拿来做 SSR ？</strong></p><span id="more"></span><h2 id="Why-QuickJS">Why QuickJS</h2><p>毕竟 rust 早就有 v8 绑定，<code>deno</code> 用的就是</p><p>你说得对，但是 QuickJS 是由著名神仙 Fabrice Bellard 所打造的一个小型并且可嵌入的 Javascript 引擎，它支持ES2020规范，包括模块，异步生成器和代理器。在这里，你可以用任何现代的 JavaScript 语言片段在几乎任何语言环境中运行，在自由的环境中邂逅不同的语言和技术栈，同时它还支持 Decimal 提案和运算符重载提案……</p><p>其实就是不挑</p><h2 id="前端">前端</h2><p>流水账，主要是踩坑流程</p><p>前端部分自不必多说，玩了两年半的 <code>solidjs</code>，现在只要不是上班都是用这款（其实上班能夹带私货的时候也用）</p><p><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a> 提供 SSR 各种形态的 demo，但他们都有一个特点：使用非常原生的 <code>rollup</code> 插件作为演示<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，那我正经用也不用这个啊，那不行，就得按 vite 工作流来。</p><p>so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm dlx degit solidjs&#x2F;templates&#x2F;ts</code></pre><p>首先 <code>vite.config.ts</code> 有两处调整：</p><ul><li>solid 插件激活 ssr，这在处理 ssr 输出时有用</li><li><code>noExternal</code>，后面讲为什么</li></ul><p>改完之后大概是这样</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default defineConfig(&#123;  plugins: [solidPlugin(&#123; ssr: true &#125;)],  build: &#123;    target: &quot;esnext&quot;,  &#125;,  ssr: &#123;    noExternal: true,  &#125;,&#125;);</code></pre><p><code>package.json</code> 新增一个 <code>script</code>，不加也行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;vite build --outDir .&#x2F;dist&#x2F;client&quot;,    &quot;build:server&quot;: &quot;vite build --ssr .&#x2F;src&#x2F;entry-server.tsx --outDir .&#x2F;dist&#x2F;server&quot;,  &#125;&#125;</code></pre><p>这里把输出路径都有点调整，目的是把客户端产物和服务端产物分开，不这么做也行。<strong>但入口是肯定分开的</strong>，即使这很基操不需要写下来</p><p>按照 vite 建议的做法，客户端入口从 <code>index.tsx</code> 改为 <code>entry-client.tsx</code>，则服务端入口为 <code>entry-server.tsx</code>，内容每个框架都差不多，按照前端框架的建议做即可</p><p><strong>记得客户端真实入口 <code>index.html</code> 里的 script 路径也要改！</strong></p><p>过一下 build，能看到 dist 下两组目录，下一步</p><h2 id="服务端">服务端</h2><p>Web Framework 不用挑，用的最多的（可能也是两年半），可能也是目前来说依然最虎的 <code>actix-web</code>，需要花心思的是找 binding</p><p>首先用的是 <a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a>，在品鉴这个项目的时候还顺便搜到另一个项目 <a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a>，这是一个类似的操作：通过 QuickJS SSR Vue，可以读读看</p><blockquote><p>Node outperforms QuickJS by a wide margin. Especially with enough cores and memory. However, QuickJS is very small and has very low memory consumption, so running it threaded in a Rust shell makes it possible to have very high throughput using very few resources in comparison.</p></blockquote><p>顺便品鉴完这个项目之后，开始缝合。不出意外的话马上要出意外了</p><h3 id="坑1：">坑1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unsupported keyword: export</code></pre><p>这里可以讲讲为什么上面要 <code>noExternal</code> ，原因很简答，vite 默认你是会用 node 的，加上 type 是 <code>module</code>，结果就是编译后的服务端入口依然有 <code>import</code> 和 <code>export</code></p><p>所以目的很简单：把所有用到的 js 都打成一个文件。并且这里还需要一个操作：去掉最后一行，也就是 <code>export</code> 部分</p><p>默认情况下是在 QuickJS global 环境下 eval 程序，直接当成 <code>REPL</code> 来用就完事了</p><h3 id="坑2：">坑2：</h3><blockquote><p>找不到 setTimeout</p></blockquote><p>一番查找，<code>setTimeout</code> 由 QuickJS 内置 module: os 提供，按道理来说 <code>setTimeout</code> 应该能在 globalThis 直接调用</p><p>没关系，直接 eval 进去吧</p><h3 id="坑3：">坑3：</h3><blockquote><p>不存在 os</p></blockquote><p><strong>这你妈你说你妈呢？</strong> 这怎么可能啊</p><p>只见 Issue 区赫然有这么一行</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs/issues/123">Is there any way to use std, os, and global?</a></li></ul><p>Ok，寄</p><h3 id="Finish">Finish</h3><p>本来看着是 star 最多的库</p><p>算了，还得是直接绑定来得稳定，虽然比较麻烦，相当于换个语言直接使用框架。但高级封装至少比低级封装容易使用</p><p>于是改用这个高级封装：<a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a>，这个就非常纯，需要直接生吃 Document</p><p>简单验证</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let test &#x3D; ctx.eval(&quot;let a &#x3D; 1; let b &#x3D; 2; a + b&quot;).unwrap();assert!(3, test);</code></pre><p>发现没问题，直接搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let result &#x3D; context.with(|ctx| &#123;    let _a: String &#x3D; ctx.eval_file(&quot;ssr&#x2F;dist&#x2F;server&#x2F;entry-server.js&quot;).unwrap();    let result: Object &#x3D; ctx.eval(r#&quot;render()&quot;#).unwrap();    let head: String &#x3D; result.get(&quot;head&quot;).unwrap();    let body: String &#x3D; result.get(&quot;body&quot;).unwrap();    let mut map &#x3D; HashMap::&lt;String, String&gt;::new();    map.insert(&quot;body&quot;.to_string(), body);    map.insert(&quot;head&quot;.to_string(), head);    map&#125;);</code></pre><p>这里转一次 <code>HashMap</code> 的原因是：<code>Object</code> 的类型没有声明，直接 return 出去有静态检查问题，rust 不允许</p><p>但因为是概念验证，先转成已知类型出去顶着用</p><p>编译没问题，继续搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let template &#x3D; read_to_string(&quot;ssr&#x2F;dist&#x2F;client&#x2F;index.html&quot;).unwrap();let html &#x3D; template    .replace(&quot;&lt;!--app-head--&gt;&quot;, result.get(&quot;head&quot;).unwrap())    .replace(&quot;&lt;!--app-body--&gt;&quot;, result.get(&quot;body&quot;).unwrap());</code></pre><p>打印 html，确认内容就是一个完整的 html 文件。<strong>成了！</strong></p><p>那直接上 server-side，简简单单写个 get</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[get(&quot;&#x2F;&quot;)]async fn hello() -&gt; impl Responder &#123;    let html &#x3D; make_html();    HttpResponse::Ok()        .status(StatusCode::OK)        .content_type(&quot;text&#x2F;html&quot;)        .body(html)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123;    HttpServer::new(|| &#123;        App::new()            &#x2F;&#x2F; 静态文件映射            .service(Files::new(&quot;&#x2F;assets&quot;, &quot;ssr&#x2F;dist&#x2F;client&#x2F;assets&quot;))            .service(hello)    &#125;)    .bind((&quot;127.0.0.1&quot;, 8080))?    .run()    .await&#125;</code></pre><p>浏览器输入一个令人熟悉的 <code>localhost:8080</code>，正常运行，JS 绑定也一切正常</p><p>代码会发布在 <a target="_blank" rel="noopener" href="https://github.com/colmugx/quickjs-ssr">colmugx/quickjs-ssr</a></p><h2 id="最后-3">最后</h2><p>这里只是一个简单验证，SSR 的 real world 肯定不是这么两步就能完成，否则就不需要像 <code>next.js</code> 和 <code>SolidStart</code> 这样的上层框架</p><p>并且，除了服务端需要考虑线程池等等这些问题之外，拥有 JIT 的 v8 可能性能上会更优</p><p>但我的目的也很简单，我要的不是 SSR，而是两个需求</p><ul><li>给 <code>ayaka</code> 提供一个静态页面生成的方式，但默认还是像 <code>saika</code> 那样的运行时 fetch</li><li>给 <code>kazusa</code> 提供脚本执行环境，不过这是个 optional，主要维护还是 lua 执行环境，这与既定用户群有关</li></ul><p>别问为什么又来一个 <code>ayaka</code>，问就是灵感来源 <a target="_blank" rel="noopener" href="https://github.com/2nthony/saika">2nthony/saika</a>，而不叫<code>sakuya</code>的原因仅是因为那会在玩原神银趴</p><p>最后，这可能是第一篇来自于这个主题 3.5 版本的文章，想给用 hexo 的这段时间一个完美的休止符，然后去开发有新设计风格的 nlvi 4</p><p>但是重构一半，交互上还是有缺陷，只不过说不影响阅读</p><h2 id="Links">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>solidjs 的 vite 插件来源于 rollup 插件的上层封装 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> quickjs </tag>
            
            <tag> vite </tag>
            
            <tag> solid </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为玩家 成为玩家</title>
      <link href="/blog/2022/01/07/to-be-a-gamer/"/>
      <url>/blog/2022/01/07/to-be-a-gamer/</url>
      
        <content type="html"><![CDATA[<p>实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：</p><ul><li>那是一篇极其消极的文章</li><li>本文是一次自我救赎</li></ul><p>so，这也许是更合适的“年终总结”</p><h2 id="TL-DR-6">TL;DR</h2><ul><li>虽然还是前端，但身处游戏</li><li>对于以上，为什么</li></ul><span id="more"></span><h2 id="因为热爱">因为热爱</h2><blockquote><p>从主观感受聊到游戏设计，这大概就是热爱吧 —— 2021.4.30</p></blockquote><p>我觉得故事不用从盘古开天辟地开始讲起</p><p>非常幸运的是，当时的工作环境中，团队所有人都玩游戏，大部分都玩高品质单机游戏，所以我们业余茶歇都会聊游戏。甚至分享可以讨论游戏，甚至在会议室玩《决斗链接》，两人duel，其他人通过电视观战。而那会面试的时候，我们经常问的“你业余时间一般会做什么”，在得到瞬间的回答“我平时不玩游戏”反而会感到诧异</p><p>在当时，除了会讨论游戏好不好玩之外，我经常又会往下继续讨论。跟另外一位同事经常讨论现在的热点，以及游戏细节，和“我为什么喜欢xx游戏”。那个时候根本没想过会到游戏公司服务，大家只是玩家</p><p>后来遇到一些朋友，无一例外都来自于游戏公司。于是在氛围煽动下，我离开了所处不久的新环境。这里只能说：感谢 VP 的理解和支持，同时我没办法回应你的欣赏，实属抱歉</p><h2 id="“黑暗降临”">“黑暗降临”</h2><blockquote><p>永远不要忘记第一次听《疾如猛火》后潸然泪下的那个中午</p></blockquote><p>作为一个营销碰瓷游戏，在此之前我从来没有关心过，黑暗降临也指的是第一次的营销碰瓷。但在一次内部分享之前，一切都改变了</p><p>分享的大概主题是“原神的音乐设计”，发生在分享之前，游戏新闻也多多少少提到：</p><blockquote><p>《崩坏3》和《原神》的音乐火到出圈</p></blockquote><p>于是，这是我与原神的第一次接触 —— 我打开了原神的主主题（Main Theme）。那个层次的细腻和画面感一下子涌入脑中，光听音乐已经能大概能看到这是一片幻想大陆</p><p>紧接着，我听了一些场景音乐。有个熟悉的特点，场景音乐都分为日间和夜间，这个设计在这之前仅有《异度之刃》系列对我印象深刻</p><p>当天中午，引用的故事发生了。在五声宫调跳进中古调，加上民乐领跑，饱满的感情直接轰入灵魂。因为原神的早期世界观架在欧洲，主题也就偏中古调式。《疾如猛火》就是一首同时具有璃月主题与原神主题的战斗音乐，也就是就东方体裁碰撞西方体裁，民乐器碰撞管弦乐，毫不突兀，又交相辉映……就这样一下子崩不住了。落泪原因简单：在我们生活的这片土地上，真的诞生了品质如此优秀的游戏</p><p>其实很长一段时间我都没有打开过原神，下载过原神。但城邦、人物性格、人际特点几乎都靠音乐云了个七七八八。蒙德有大大小小的西欧建筑，遍地风车，人们过着惬意的生活；繁荣的璃月港口络绎不绝，不仅存在丰富的中华文化，更是做到最大的文化包容；像是一个存在于战争或荒乱的稻妻，人民憧憬和平，满怀希望。在绀田村的表达中更为明显，仿佛妻离子散，每天都盼望家人回家……而每个元素也有独特的风格，雷元素会有重金属或者电子音乐，火元素有急躁的风格或者摇滚，水元素总会用带有故事感的钢琴带情绪……</p><p>且不谈游戏质量，这已经能证明这是成功的游戏音乐了</p><p>这是一个即使现在想起来还是会鼻尖一酸的回忆，<strong>所以我不断提醒自己，不要忘记这个感觉。</strong>《鬼谷八荒》、《风来之国》、《戴森球计划》等等证明了我们是可以做出优秀的游戏，《原神》向我们展示了我们也能做出贴近日系上游品质的游戏。但是 <strong>这个日系游戏并没有屈服于这个 title —— 璃月的刻画告诉了全世界什么是中华文化。</strong> 原本我没有喜欢过任何一个角色，现在有了：<strong>红毹婵娟 —— 云堇</strong></p><p>与其说是爱上了 miHoYo，不如说只是喜欢 HoYo-MiX。我还是不会主动向人推荐《原神》</p><h2 id="“未成年保护”">“未成年保护”</h2><blockquote><p>周五、周六、周日和法定节假日<br>20:00 ~ 21:00</p></blockquote><p>两个朋友同一时间离职，相继去了三个不同的行业：游戏、教育、房地产。于是后面发生了什么已经不用讲了（笑</p><p>虽然 ban 的是网络游戏。但难免有些感慨。国内的游戏环境还是太糟糕了，被各种数值网游污染，导致人们根本没办法理解什么是游戏，怎么对待游戏。现在还有绝大多数人认为游戏 = 打怪升级刷刷刷，他们不懂《双人成行》为什么必须两个人玩；《风之旅人》为什么不告诉玩家 NPC 的由来；《传说之下》为什么不能打怪升级；《我的世界》为什么能成为电子工程摇篮（x</p><p>针对游戏问题，更重要的是成长期的陪伴。任天堂在 2000 年的时候就推出了“防沉迷机制”<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但人家是如何理解防沉迷的？</p><blockquote><p>Wii的“家长监控”模式，最终选择了记录孩子的游戏时间，让他们和家长自行沟通决定游戏时间，用主机里的“游戏履历”督促孩子遵守约定，达到和“断电”同样的目的。</p><p>总之，大部分限制都能调整，只要家长和孩子商量好就行。这是任天堂“家长监控”系统的最大亮点。</p></blockquote><p>任天堂在本来是提供给监护人的信《致监护人》预判了“孩子可能正在寻找解除限制的方式”，并留下了一段话告诉小朋友：</p><blockquote><p>不守诺言，整天玩游戏肯定是不行的<br>但如果是“我才玩了一会……”就被爸爸妈妈说了<br>那或许就是没有好好决定游戏时间的缘故了！</p><p>确定一个规则，然后让爸爸妈妈通过这个软件监督自己，这样就能开开心心玩游戏了</p></blockquote><p>我是相信人在思维最发散的时候是应该接触电子游戏或者沙盘游戏的，而且应该培养一个健康的游戏价值观。<strong>至于那些什么“电子海洛因”的家长，反正每一代都有上瘾的东西。</strong> 尝试反问你的家长，上学的时候有没有沉迷过武侠小说，有没有沉迷过滚铁环，至少我屡试不爽。什么时候为人父母才能懂得：<strong>家庭才是第一教育场所，陪伴才是第一教育资源。</strong> 怪电视，怪游戏，怪玩具，怪邻居都是不可能解决问题的</p><p>你觉得你很忙，没时间陪孩子，把手机一丢让孩子自己玩。即使你手机没有王者荣耀，你的孩子也会因为抖音上瘾。到时候你敢举报抖音吗？你不敢！因为你也正上瘾着呢！</p><h2 id="主程摆烂">主程摆烂</h2><blockquote><ul><li>这个实现不了</li><li>我们最近太忙了，有空看一下</li></ul></blockquote><p>这来自于真实情况，但我只能轻描淡写</p><p>作为发行，确实有很多运营工作是需要我们做的，其中就有游戏中的社区入口。我们对接的两个游戏，一个 webview 不撑满，一个 webview 保留默认工具栏，更甚的是 android 与 iOS 的工具栏位置不同，但它们都会挤压视图空间。而这两个问题本不是问题，对于 unity editor 来说仅仅是一个开关而已。而当我们提出了问题时，对方回复了引用1；而当我们提出解决方式：仅加一条声明，对方回复了引用2</p><p>并且在合作过程中，游戏方经常爱理不理，甚至出现内存泄露时还直接推锅是社区造成的，<strong>并转发崩溃堆栈给我们排查问题，你他妈是认真的吗？</strong></p><p>这让我感受到了，“带着热爱工作”只是我的一厢情愿而已，无论到哪都是如此。我不再出声，用 unity 模拟了我们需要的调试环境（只用了一个 webview，并对 webview 定制），并加入他们不愿意做的退出功能（不愿意取消工具栏的原因是没有工具栏退出不了场景）。以此来解决我们的调试工作经常受阻导致我们自己的开发周期被压缩，最后再进游戏运行一遍确认效果即可</p><p>彼时彼刻我真的很敬仰腾讯游戏，在《腾讯游戏开发精粹2》里他们描述到了，他们在三个游戏引擎都开发了渲染后端，让社区和活动页面都能直接渲染在游戏引擎中。这种做法无论什么角度都是完美的，而我们却还在这种狗屁事情纠缠不清</p><h2 id="浅墨离世">浅墨离世</h2><blockquote><p>愿这本书，能帮助那些热爱游戏编程、怀揣游戏开发梦想，却苦于难以入门的人们，让他们少走弯路。</p><p>愿这本书，能为国产游戏、国产游戏引擎的崛起，开启一扇门，迎接新的黎明。</p><p>我们都还年轻，该做的梦及时去做，该追寻的梦想用力去追寻。</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><blockquote><p>我有一个梦想，将来的某一天，大家都能玩到拥有自己本土文化的优质游戏。</p><p>我有一个梦想，有一天，西游记能出ACT，让老外去体会中国文化西游记中“斗战胜佛”的打击快感，那一定比西方的动作巅峰之作《战神》、《鬼泣》更加深邃。</p><p>我有一个梦想，有一天，上海滩能出沙盒游戏，而不是玩《GTA》感受美国梦，亦或是玩着《热血无赖》体验国外公司强行塞给我们的“中国文化”。</p><p>我有一个梦想，有一天，不少3A大作不需要汉化，因为是我们自己的游戏，配音是中国的，文化也是中国的。</p><p>我有一个梦想，将来的某一天，国产游戏能像中国的其他产业一样，以一个领跑者的姿态，面对全世界，面对全宇宙，器宇轩昂，扬眉吐气。</p><p>这会是由我们一起去完成的梦想。</p><p>等着我们的好消息！</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><p>我不会揣摩已故之人，但能写下如此文字的人最后的结果竟然如此令人遗憾，想必在那瞬间肯定是无比绝望吧</p><p>我对浅墨并不熟悉，在这之前仅通过 opencv 了解过。在这之前因为方向不同，所以对 shader 等等也不关心。在某个周六，兄弟加班出门吃饭时，看到了某座楼下面围起来了，还在叹息：</p><blockquote><p>XX游戏怎么又……（为什么加又）</p></blockquote><p>当知道当事人是如此追梦人时，没有人不是心酸的。但凡在知乎看过那两则招聘文章，即使评论区各种冷嘲热讽，也能感受到作者对这件事抱足了信心。</p><p>也许世界就是这么现实吧。有人正在坚持“技术宅改变世界”，有人在摆烂，有人因为可能过高投入导致评估收益不清晰而在投入之前终止了投入</p><h2 id="最后-4">最后</h2><blockquote><p>在我的名片上，我是一个公司总裁；<br>在我自己来看，我是一名游戏开发者；<br>而在内心深处，我是一名玩家。</p><p>—— 岩田聪 -《玩者之心》- GDC2005</p></blockquote><p>故事是经过排列的，每发生一个事件，这种无助又坚定的心情就加深一层</p><p>《原神》向我们和世界展示了国产优秀的架空世界观和国产游戏音乐，我们再也不用羡慕史克威尔的音乐；《黑神话：悟空》向我们和世界展示了各个角度的正版“斗战胜佛”，我们再也不用羡慕拥有《战神》的圣莫妮卡。未来还有更多可能</p><p>但我们的环境还是很糟糕。所以，我能不能也做点什么，能不能不再是少数人的世界，能不能让更多人理解，即使这对我来说完全陌生。打嘴炮是最简单的，但这件事可能真的入脑了 —— 我开始怀疑我的选择和自己：我真的可以做到吗？我可什么都不会啊！</p><p>就像 2022 年潘通流行色<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>想要表达的那样（老样子，博客换颜色了），也刚好贴近自己和博客一直的追求：<strong>让一切充满想象力</strong>，希望可以继续坚持下去。毕竟，整个评论区可都是“你可以！！”啊</p><p>其实 <code>godot-pong</code> 是有在做的，现在是填充基本规则和做了音效音乐（音乐觉得做废了打算重做所以迟迟没上传）</p><p>希望 2021 年留下来的这篇文章，在未来不会被自己删除，并时刻提醒自己</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/461405.html">https://www.huxiu.com/article/461405.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2022">PANTONE COLOR OF THE YEAR 2022</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我没想过 EventBus</title>
      <link href="/blog/2021/11/24/why-not-eventbus/"/>
      <url>/blog/2021/11/24/why-not-eventbus/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下全是暴论</p></blockquote><p>这是一个发生在今年的对话：</p><blockquote><p>Q：组件通信有几种方式？<br>A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children<br>Q：还有吗？<br>A：postmessage 可以算吗<br>Q：也行，还有吗？<br>A：localStorage/sessionStorage 可以算吗？<br>Q：算半个，还有吗？</p><p>这 TM 不就这些方式还有吗？</p></blockquote><p>回来一拉清单，各家文章盘点确实还多了一个：<code>EventBus</code></p><span id="more"></span><h2 id="什么是-eventbus">什么是 eventbus</h2><p>简单理解：事件总线，一种订阅/发布模型，即是在希望发生事件处理的地方创造一个监听器(listener)，接着在希望影响到监听器所在位置变化或更新的地方加上发射器(emitter)</p><p>这样的好处是，任何位置都可以透传。因为事件总线（可以）是全局的</p><p>从名字上看，它应该是属于事件驱动设计的产物。这没问题，GUI 一直都跟事件驱动有关，浏览器在交互部分也是这么做的</p><p>那，这么多前端框架有没有使用事件驱动的？有，御三家里的 <code>Angular</code>。除了御三家那更多了，反而数据驱动才是新品种</p><p>OK 目的达成，我就是要绕到这个点上：为什么面试上问 Vue，甚至是 React，我就没想过 EventBus。<strong>因为这本来就跟数据驱动没关系</strong></p><h2 id="为什么我不用-eventbus">为什么我不用 eventbus</h2><p>不带 Vue 玩了这领域有争议。就一个问题：什么时候 React 会触发更新？</p><p>这个时候就应该有个经典公式：view = f(props, state)。也就是当 <code>props</code> 或者 <code>state</code> 发生更新了，<code>view</code> 会更新。或者换句话说，<strong>数据更新了视图会更新</strong></p><p>那这里就有一个问题：如果触发了某个事件，视图会更新吗？<strong>会更个几把！</strong> 要会更新你还需要 <code>setState</code> 吗？这也是为什么 <code>rxjs</code> 在 <code>React</code> 用起来就是没有 <code>Angular</code> 来得无尿点，最核心的一点就是你想通过 <code>rxjs</code> 通知视图更新就肯定需要在订阅做一次 <code>setState</code>，不管你封装了还是在 business code 里订阅一次写一次</p><p>而且我不用还有另一个原因：这东西在我的理解中，就是一个 <code>goto</code> —— 它会把代码弄得非常糟。本来是单向的数据流向，现在会完全不知道某个组件会因为什么而产生更新，流向变得不可观察</p><p>你可能会说，那 context 也是这么传的啊！可 eventbus 可不禁止子组件 call 父组件，不约定好就造成逆数据流</p><p>除此之外，事件名称是一个字符串（暂且只能是字符串），那么这个时候需要保证事件名不要重复。为了解决这个问题可能就会引入一个叫事件表的东西 —— 但你想用到某一个事件时，import 这个常量，毕竟常量背后什么静态值对于事件来说无所谓，对得上就行。这会发生什么问题？在生产过程中这问题发生得不要太多，最经典的就是忘记更新事件表，或者嫌麻烦摆烂直接写，最后发现因为一个大小写导致事件对不上……</p><p>除此之外还有！毕竟是一个订阅发布模型，你订阅了是不是得取消订阅。事件的东西你一旦开了他就会一直留存在内存中，处理不当的话可能会出现两个一模一样的 listener，而这个原因仅是因为上一个没有销毁……当然了最轻的问题就是你的某一个事件处理会响应 n 次，是的这只是最轻的</p><p>总之这非常反思维，在一个数据驱动的环境中，为了一点点 buff 而引入大量 debuff 是否得不偿失。经过一轮网上冲浪后发现，相关讨论不少（指两个）</p><ul><li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/t/event-bus-is-it-a-good-idea/49853">Event bus - is it a good idea?</a></li><li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/androiddev/comments/eksepr/why_some_people_dislike_eventbus/">Why some people dislike EventBus?</a></li><li><a target="_blank" rel="noopener" href="https://tkacz.pro/vue-js-why-event-bus-is-bad-idea/">Vue.js: why event bus is bad idea</a></li></ul><h2 id="你真的需要-eventbus？你用来做什么？">你真的需要 eventbus？你用来做什么？</h2><p>Vue 有 provider/inject，React 有 Context API，这应该够用了</p><p>跟数据有关的 API，Vue 有 Vuex，React 有 React / Recoil。他们本身也会遵循单向数据流</p><p>所以，到底是哪里需要在 React 环境中引入一个不属于数据驱动的东西。或者换个思路（挖个坑）：</p><p><strong>我们是否正在被框架绑定？一个本只是视图层框架，现在还包含了逻辑层？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 架构思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 一起玩吧</title>
      <link href="/blog/2021/09/04/game-pong-enhance-2/"/>
      <url>/blog/2021/09/04/game-pong-enhance-2/</url>
      
        <content type="html"><![CDATA[<p>稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-4">TL;DR</h2><ul><li>启动页面、得分牌</li><li>加入简单的 AI</li></ul><span id="more"></span><h2 id="完成情况-2">完成情况</h2><p>这把已经像一个游戏了。所以，可以一起玩吧</p><p>以下是记录本次更新一部分内容</p><h3 id="UI">UI</h3><p>目前是加了一个标题场景，但是过于没东西讲。老前端熟悉的 <code>flex</code> 布局思路一通搞完事</p><h4 id="切换场景">切换场景</h4><p>游戏是按场景(scene)来区分页面(非常前端的描述)，比如关卡类游戏一般会做很多 level 的场景。不同的是这可没有所谓的路由，而是直接切换(change)</p><p>这里使用的是：获取场景树，得到实例，切换场景(change_scene)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get_tree()-&gt;change_scene(path);</code></pre><p>这个项目里的实现是：把这种按钮直接做成「组件」，暴露场景接口。在标题场景 <code>connect</code> 所有这个类型的事件，用统一事件处理跳转。这样就封装了跳转场景，方便以后处理设置界面啥的</p><h4 id="记分牌动画">记分牌动画</h4><p>有一个控件 <code>AnimationPlayer</code> ，用来控制能访问到的节点的动画，例如运动、变形。如果使用过 <code>flash</code> 那是相当熟悉 —— 关键帧打起来</p><h3 id="加入-AI">加入 AI</h3><p>周伯通虽然也行，但是自己玩还是得有个「对手」</p><p>现在看到 AI 人就不知觉紧张起来，感觉是个非常难的东西。其实 AI 就只是「人工智能」，其目的就是「假装是个人」，那游戏 AI 就是「假装有个陪你打游戏的人」。只不过现在的「机器学习」确实给游戏 AI 也带来了不少想象力 —— 他们的操作越来越像人的思维方式了</p><p>多智能还得看开发者。例如中小学机器人编程比赛中的经典项目足球项目和灭火项目，</p><blockquote><p>足球项目：最简单的逻辑就是通过传感器（指南针）判断两边方向，超声波测距，忘记什么传感器用来找球。摸到球之后直接把球往对方门里「撞」，完事。</p></blockquote><blockquote><p>灭火项目：都带着指南针和热力传感，主要还是看谁的寻路比较nb</p></blockquote><p>游戏 AI 很早就有，最经典的游戏 AI 还属南梦宫的吃豆人(pacman)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（对于我来说一样属于游戏设计必修课，甚至机器学习也可以）。</p><blockquote><p>一共四个干扰怪物，逻辑都不相同</p><p>红色 blinky：追着豆子，通过寻路算法找距离最近的路线<br>粉色 pinky：追豆子前方第四个格子，通过寻路算法找距离最近的路线。如果向上移动，则是左上方四个格子<br>青色 lnky：blinky 与豆子各自前方射线的交点，并两倍延长的点<br>橙色 clyde：追豆子到方圆 8 格内就会散开（纯气氛组）</p><p>四个单个逻辑不复杂且工作量很小的 AI，组合成一个看似一直在围堵玩家的敌方小队。这就是最经典的地方</p></blockquote><p>这篇文章再开个坑：我要写一篇我对游戏 AI 的理解。例如游戏设计中，一些非常难的 gameplay 可能会设计出让 AI 「放水」，让玩家以为 AI 真的翻车了，以此来鼓励玩家</p><p>好了，这一部分的重点本应该是这个游戏的 AI，目前的设计是： <strong>在自己的 y 与球的 y 距离大于 25 时，追球。25 差不多是板子的 1/4。</strong> 逻辑就这，没了</p><p>但别小看这简单的逻辑，在目前没有什么骚东西的环境下，只要没有什么花里胡哨的操作（例如拿板边去敲球）几乎没有胜利的机会。而现在这个环境玩骚的只会把自己的分骚没（比如我）</p><h3 id="冷却与重置">冷却与重置</h3><p>当球落某方门后，球会重置到游戏中点，没有操作，直接关闭了惯性和直接 set position</p><p>不过有一个小设计：败方接球。如果某方上一回合输了，这一回合由该方接首发球</p><p>所以，虽然是可以玩了，但是还是缺东西，比如很多关于游戏规则的完善</p><h2 id="下一步">下一步</h2><ul><li>发球 y 随机：目前发球的 y 是固定的，直接去接球点等球多没意思啊</li><li>随机首发球：第一球现在都发给左方，或许应该随机</li><li>胜利规则：现在这游戏一开就没边了…</li><li>暂停与结束界面</li><li>声音</li></ul><p>游戏补完之后，往后的更新就越来越慢了，因为想法越骚，实现也会越来越难</p><h2 id="Link">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82567889">游戏AI入门及AI优化</a></li><li><a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html">AnimationPlayer</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27177424">现代游戏AI的鼻祖——聊聊你所不知道的《吃豆人》</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 发布</title>
      <link href="/blog/2021/09/02/game-pong-enhance-1/"/>
      <url>/blog/2021/09/02/game-pong-enhance-1/</url>
      
        <content type="html"><![CDATA[<p>其实游戏已经做很远了，为了真实性删了很多添加的东西…</p><p>本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-3">TL;DR</h2><ul><li>完成基本的击打、胜利条件、球的恢复</li><li>编译与发布</li></ul><span id="more"></span><h2 id="完成情况">完成情况</h2><p>基本的 gameplay 已经完成 —— 两块板子一个球，板子的后面是各自的「门」。</p><p>门选择 <code>Area2D</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，原因是这个控件专门控制物理状态与检查物理状态；墙壁使用<code>StaticBody2D</code></p><p>板子和球目前均使用 <code>KinematicBody2D</code>，因为可以方便的模拟物理状态，反弹完全不需要代码描述。但板子可能应该换成<code>RigidBody2D</code>，这样可以模拟更多的真实物理，例如摩擦力，受力。不过目前需要求证：控制端使用 <code>RigidBody</code> 是否合理</p><p>完全没什么好讲的，非常简单的实现</p><h2 id="编译与发布">编译与发布</h2><p>由于 <code>native</code> 的关系，运行时会把 cpp 编译，并编译成动态链接库。例如 osx 使用 <code>.dylib</code>，那么 web 跟原生相关的肯定是 <code>.wasm</code> 。官方提供了原生端的案例<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，而开发时也只编译了 osx 版本。</p><p>直到要验证发布到 github pages 时，出大问题，浏览器只显示 <code>abort(undefined)</code></p><h3 id="目前不能使用最新的-emscripten-编译你的-wasm">目前不能使用最新的 emscripten 编译你的 wasm</h3><p>经历各种尝试，例如直接从源码编译新的 template，但编译时也频出问题，甚至 debug 无法成功编译，接着进入无尽改编译参数等各种操作……</p><p>直到看到这个 issue <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>因为之前一直使用的 <code>emscripten</code> 版本已经是 26，所以猜<strong>是不是跟版本有关系，于是换成 17，成了</strong></p><p>于是有另一个猜想：<strong>官方发布的模板是否因为也使用 17 的版本发布，会导致 dll 对应不上。业务代码必须同样使用 17 编译代码才可以使用？</strong></p><h3 id="交给-github-action">交给 github action</h3><p>因为刚刚的 issue，发现这个作者对 godot 发布已经了然于胸，最后发现他提供了一个 ci 配置<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，于是参考这个配置写了一个工作流，现在可以把整个发布路程交到 github 了</p><h3 id="记得提交-export-presets">记得提交 export_presets</h3><p>可能可以发现，前面大部分 action 都是失败的</p><p>如果选择了 github 的 .gitignore 模板，这个文件默认会被忽略。但缺少这个文件 ci 无法工作 —— 获取不到发布配置</p><p>so，记得提交，接着等待一切结束。顺带一提，github action 的配置应该不高，编译 godot-cpp 属实膀胱局</p><p>下一篇应该讲有完整 UI 的第一个版本，结束</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/physics/using_area_2d.html">使用 Area2D</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative C++示例</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-cpp/issues/554">Building for HTML5 stopped working for emsdk 2.0.18+</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/2shady4u/godot-cpp-ci">2shady4u/godot-cpp-ci </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 介绍</title>
      <link href="/blog/2021/08/29/game-pong-enhance-0/"/>
      <url>/blog/2021/08/29/game-pong-enhance-0/</url>
      
        <content type="html"><![CDATA[<p>做一个简单的项目介绍：</p><p>使用 <code>godot engine</code> 从零开始的 <code>pong game</code> 开发。开发会尽量保持简单，但希望不缺挑战</p><p>实现 <code>pong</code> 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：<strong>不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去</strong></p><p>这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作</p><p>所以项目将会使用：</p><ul><li>godot 3 (gdnative)</li><li><strong>C++</strong></li><li>photopea（用来弄点素材）</li><li>garageband / logic（声音）</li></ul><span id="more"></span><h2 id="你-TM-怎么想的">你 TM 怎么想的</h2><p>「在岸上永远学不会游泳」，这是在当时听到的兄弟对我说的一句话。<s>希望他不是因为嫌我菜让我爬而说出来的话</s></p><p>也为了记录，「如果单就以 pong 作为母版，到底能做到什么样子」，所以本身也是一个兴趣导向产物</p><p>这个系列还是不定期更新，甚至可能随时流产。流产的原因只有一个：搞不出来了…</p><p>就这样。下一篇先写一切的基础：如何让 pong 运行起来</p>]]></content>
      
      
      <categories>
          
          <category> 游戏开发 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter desktop 能不能跨平台多窗口</title>
      <link href="/blog/2021/06/17/flutter-tauri/"/>
      <url>/blog/2021/06/17/flutter-tauri/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章极其具有时效性，在目前，<code>flutter</code> 不支持多窗口，但是已经有<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">这么一篇文档</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。而且 flutter desktop 的多窗口可能已经计划中了。</p></blockquote><p>SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：<code>flutter</code>。而且：</p><ul><li>flutter 使用 <code>skia</code> 绘图而不是调用原生组件，表现统一</li><li>flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）</li></ul><p>flutter 本就是先给移动端设计，可以直接用 <code>dart</code> 完成很多工作。但是在调研桌面时发现一个问题：<strong>找不到多窗口 API！</strong> 这不行。虽然 flutter 是允许原生编程，那我能会 <code>windows</code> 开发吗？！</p><p>等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？</p><p><img src="/blog/Image/flutter-tauri-0.jpg" alt="flutter-tauri"></p><p>把 flutter 套进 <code>electron</code> 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）</p><p>但是桌面端不选择 <code>electron</code>，咱用 <code>tauri</code>！毕竟现在全平台都 <code>webkit(blink)</code>，而且 <code>flutter</code> 使用 <code>canvaskit</code>，不需要担心表现…</p><span id="more"></span><h2 id="准备工作">准备工作</h2><h3 id="初始化">初始化</h3><p><code>tauri</code> 采用的是「集成到项目」的方式，所以先创建一个 flutter 项目（创建步骤省略）</p><p>接着，根据文档<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>集成 tauri：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yarn add -D @tauri-apps&#x2F;cli$ yarn tauri init</code></pre><p>需要配置一些步骤。其中，<code>distDir</code> 选择的是 flutter 创建的 <code>web/</code>。开发地址暂时空过</p><h3 id="flutter-以服务运行">flutter 以服务运行</h3><p>与 electron 一样，tarui 运行的还是前端应用，所以要不执行 <code>index.html</code>，要不有个开发服务</p><p>flutter 直接调试会直接打开 chrome，所以这次运行换种方式：仅运行开发服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如果不指定端口，flutter 会随机一个高位端口，但每次启动都会更换端口flutter run -d web-server --web-port 4396</code></pre><p>flutter 服务没有热更，要更新的时候按 R <s>换弹</s> 更新</p><h3 id="配置-tauri-启动">配置 tauri 启动</h3><p>还记得刚刚漏了的运行地址？<code>tauri</code> 的配置都在 <code>tauri.conf.json</code> 中，找到 <code>devPath</code> 并补上</p><p>接着直接运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn tauri dev</code></pre><p>顺利的话就能直接看到窗口了</p><p><img src="/blog/Image/flutter-tauri.jpg" alt="flutter-tauri"></p><h2 id="开整">开整</h2><p>虽然标题只提到了「多窗口」，但 realworld 肯定无法避开原生操作。而且不管是 tauri 还是 electron 都需要用 <code>JavaScript</code></p><p>tauri 前后端（rust）通讯采用命令（command）的方式，同样是通过 event bus 互相抛事件来做到。所以我们要让一切 JavaScript 的工作桥接到 dart 上</p><p>tauri 提供了两种向后端通信的方式：直接用挂载在 <code>window</code> 的对象或者使用提供的包：<code>tauri-app</code>。这里暂时先用 <code>window</code>，但后者也可以满足，后面写 dartjs 互操作篇再覆盖</p><p>接下来分成两部分：需要实例化调用 与 不需要实例化调用</p><h3 id="不需要实例化">不需要实例化</h3><p>其实意思就是可以直接访问直接调用，不用 <code>new</code>。而在 tauri 中，向后端发起命令的函数位于：<code>window.__TAURI__.invoke</code></p><p>按照我们使用 JavaScript 的思路，调用一个对象下面的方法，思路就是直接一直点（.）下去。那么这就是一个<strong>访问多层上下文</strong>的过程</p><p>可以了，换成 dart 写出来</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; flutter 肯定有 dart，那肯定有 dart:jsimport &#39;dart:js&#39; as js;&#x2F;&#x2F; 获得 tauri 挂载的对象final tauri &#x3D; js.context[&#39;__TAURI__&#39;];&#x2F;&#x2F; 调用这个对象里面的方法tauri.callMethod(&#39;invoke&#39;, [&#39;&#39;]);</code></pre><h3 id="需要实例化">需要实例化</h3><p>总有（一堆）东西需要 <code>new</code>，多窗口就是其中一个。（这就离谱，多窗口竟然不由 rust 发起创建）</p><p>负责创建窗口的 API 位于：<code>window.__TAURI__.window.WebviewWindow</code><br>（更 NM 离谱的是直接明牌告诉你再加一个 webview）</p><p>那么，JavaScript 需要实例化，意味着<strong>需要在 dart 也实现一遍实例化</strong>作为映射。等于我们要在 dart 有一个对应的 class，有 class 才能 new</p><p>dart 里边儿能有这玩意儿吗！那妹有怎么办啊？造啊！</p><p>这次不能用<code>dart:js</code>，得换一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">flutter pub add js</code></pre><p>然后是模拟一切。首先最好先创建一个新文件，这个文件会被声明为某个可以被 <code>JavaScript</code> “发现”的 library</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS()library tauri; &#x2F;&#x2F; 实际上在这篇文章这块没卵用import &#39;package:js&#x2F;js.dart&#39;;</code></pre><p>接着，这波我们要实例化的是 <code>WebviewWindow</code>，位于 <code>window.__TAURI__.window.WebviewWindow</code></p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;&#125;</code></pre><p>那 class 要能 new，得有一个 <code>constructor</code>，dart 和某些其他语言一样，再写一遍类名。其他方法该怎么写怎么写</p><p>再看一眼 tauri 文档，<code>WebviewWindow</code> 实例化带两个参：<code>label</code> 和 <code>options</code>，<code>options</code>是一个对象，关于新窗口的配置</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, Object options);&#125;</code></pre><p>再看一眼文档，<code>options</code> 的 type 是 <code>WindowOptions</code>，所以这里可以如法炮制，再造出一个结构</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title, &#x2F;&#x2F; 文章例子仅需要 title  &#125;);&#125;</code></pre><p>这样写的结构，仅支持 <code>getter</code>，所以如果需要 <code>setter</code>，可以按照 dart 的方式改写这个 class</p><p>接着把上面的改一下。完整的代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; tauri.dart@JS()library tauri;import &#39;package:js&#x2F;js.dart&#39;;@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, WindowOption options);&#125;@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title,  &#125;);&#125;</code></pre><p>在<code>main.dart</code>创建一个新的按钮用来测试</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">ElevatedButton(  onPressed: () &#123;    final window &#x3D; WebviewWindow(      &quot;new_window&quot;,      WindowOption(title: &quot;Second Window&quot;),    );  &#125;,  child: Text(&#39;click&#39;),)</code></pre><p>完结撒花，结果不给图</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">Desktop Multi-Window Support (PUBLICLY SHARED)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://tauri.studio/en/docs/usage/development/integration">Tauri Integration</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> flutter </tag>
            
            <tag> tauri </tag>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化与工程设计</title>
      <link href="/blog/2021/02/16/component-and-engineering/"/>
      <url>/blog/2021/02/16/component-and-engineering/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是又一篇臆想文<br>如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。</p></blockquote><h2 id="TL-DR">TL;DR</h2><ul><li>组件化在做什么，组件是什么</li><li>因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计</li></ul><p>所以是什么时候前端开发也发展成需要「软件工程」的时代了，<s>还不是现在用户的电脑越来越 nb 浏览器越来越 nb</s></p><p>工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……</p><p>演变到这就产生一个问题</p><span id="more"></span><h2 id="问题">问题</h2><p>印象中的 toC 应用，它对于「历史包袱」的处理可以非常简单粗暴：</p><blockquote><p>都拖油瓶了，这不重构？顺道抬 KPI<br>既然都重构了，那整点新家伙，干活不累顺道抬 KPI (x2)</p></blockquote><p>所以 toC 应用总是会用上最新的技术，而且 toC 应用毕竟是直接面向个体用户的应用，所以无时无刻都在优化体验也说不定</p><p>但 toB 或者内部平台可不能说整就整，至少会遇到这些问题：</p><ul><li>“能用就行”</li><li>使用时间非常长，甚至可能公司开多久软件用多久</li></ul><p>如果再遇上几个持有「Promise没用过，应该是 vue 新加的功能」<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>观点的优质前端，这个应用的代码最后只能是 shit 了</p><h2 id="组件化">组件化</h2><p>我的二面可能会问一个没有什么正确答案也没什么理由的烂问题：</p><blockquote><p>如何理解组件化？</p></blockquote><p>但总能得到典型回答：</p><blockquote><p>工作中经常重复出现的功能<strong>抽</strong>成组件</p></blockquote><p>甚至是非典型回答：</p><blockquote><p>因为现在都用 vue，每一个 .vue 都是组件，这是 vue 要求的</p></blockquote><p>其中最经常得到的答案中，有一个关键动作：抽。所以又是什么时候组件化的定义变成了“抽组件”</p><h3 id="何为组件">何为组件</h3><p>在「C4模型」的官网中，关于组件的第一句话：</p><blockquote><p>The word “component” is a <strong>hugely overloaded term</strong> in the software development industry,</p></blockquote><p>很多地方其实都有组件概念，包括不限于 <code>sketch</code> 等设计应用都有组件概念。但一切都有相似之处：它们都可以是一个原子，一个单位，一个定义了接口能优秀完成某一部分工作的单位或者说 group。同理也适用于 sketch component —— 你定义了一个组件应该是怎样的元素构成与可变</p><p>所以上面的那句话，有后半句的：</p><blockquote><p>but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface.</p><p>If you’re using a language like Java or C#, the simplest way to think of a component is that it’s a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p></blockquote><h3 id="为什么开始强调组件了">为什么开始强调组件了</h3><p>确实没错，当前流行三大视图框架中，都有组件概念，即一个 vue 文件之于 vue，一个函数之于 react，一个 component 之于 ng 都是各领域定义的“组件”，甚至是「一切都是组件」。但这仅是强调了这是某个框架的原子，而<strong>业务形态的组件是由业务的，而不是框架决定的</strong>。</p><p>所以一个组件，并不是把代码放在一个 vue 文件，这个就是组件。毕竟你这个时候你可以问：你的应用下是不是有一个 <code>pages</code> 目录？下面也有一堆 vue 文件，他们每一个都是组件？接着你就尽情围观前端圈内最大双标现场</p><h3 id="怎样就是一个组件">怎样就是一个组件</h3><p>我自己给定义了几点：</p><ul><li>输入输出是确定的（像函数）</li><li>可单元测试的</li><li>“高内聚，低耦合”（现在还写这句话都觉得有些羞耻）</li></ul><p>举个例子，拿我以前很喜欢的某公司的官网做栗子（我觉得还是憋猜是哪个公司了吧，我给🐴成这样还猜得到？）</p><p><img src="/blog/Image/component-1.png" alt=""></p><p>这张图，大多数前端会认为，红框可以是组件。<s>甚至认为绿框在某开源组件库能找到</s></p><p><img src="/blog/Image/component-2.png" alt=""></p><p>放心我没⭕️ 错，很多前端都会这么想的。全都 <code>margin-top</code> 给它安排得明明白白，这样最后一个就不用处理了</p><p>但总有一部分的前端会这么认为：</p><p><img src="/blog/Image/component-3.png" alt=""></p><p>这样做几个好处：</p><ul><li>因为可以让组件弹性方便布局。</li><li>那个小标题<strong>肯定复用很多，别的地方也会有类似设计</strong></li><li><s>上下边距啊，在 <strong>page</strong> map 组件的时候<strong>给套上不就好了</strong></s></li></ul><p>所以很少前端会想到以下甚至更多：</p><p><img src="/blog/Image/component-4.png" alt=""></p><p>所以先弄清楚：<strong>谁是原子</strong>？</p><p>也就是「哪些是组件？」<strong>这个问题在设计阶段就应该确定了，而不是“抽成组件”</strong></p><p>所以在软件开发上，本就没有所谓的前端后端啥端的区别，软件该怎么写就得怎么写。一个组件可以是一个对象</p><p>而这<strong>还只是布局而已</strong>，也就是所谓前端工程师的「核心工作」</p><h2 id="工程化">工程化</h2><p>说实话，当今被冠以「工程师」之名的前端开发，没有几个懂工程（包括写这篇文章的five）</p><p>问题在于越来越多的软件都希望以浏览器为容器运行。所以并不是前端需要工程化，而是软件形态在发生改变。而这也可以继续解释下来会发生的事情 —— JavaScript 会越来越不顶用，需要 WebAssembly 做更多事情；使用 Web Worker 做跟渲染无关的事情等等等等</p><p>再同理，并不是开始要求前端开发需要懂工程了，而是这是一个软件工程师要知道的东西</p><h3 id="什么时候前端也要工程设计了">什么时候前端也要工程设计了</h3><p>是个应用就需要设计，或者说<strong>前端一直需要工程设计</strong>，只不过长时间被认为不需要和不被理解</p><p>最近的「微前端」更多的适用场景也是建立于此 —— 太旧的应用你实在维护不动了，新增的东西就以「微前端」的形式加入，这样做不破坏原本的应用，同时可以用较新的技术维护新功能</p><p>toB 大应用，在「前端」内容中更多是表单表格，以及很多弱交互的东西，可能最重的交互也就可视化配置。其注定了不需要设计驱动，更多的都在数据处理上，也就是「弄清数据流」。并且这类应用只会越做越大 <s>（直到流产，或者换老板）</s>，而且它的直接用户是另一个企业，甚至可能是以「私有部署」的形式售卖。所以要做的是尽可能稳定与高效</p><p>所以为了运行稳定不背锅，不让数据水乱流，只能跟传统软件，甚至是最亲近的后端服务的做法一样，做架构设计</p><p>而那些认为「按照原型实现 page component」的前端们，看看你的应用，是不是正在 <strong>「同一个接口在同一时间请求了好几遍，甚至是开一个弹窗再把相同数据请求个几遍？」</strong>。就这还敢把 Angular 作为鄙视链底层，谁给的勇气？<s>所以胆小的已经在用 dva(umi) 了</s></p><p>我又突然想到一次经历，我问过一个问题：</p><blockquote><p>你这里写了期望是前端架构师，精通前端架构。那你觉得前端架构需要做到什么？</p></blockquote><p>然后我得到一个非 常 满 意的回答：</p><blockquote><p>前端架构就是制定目录结构，接着指定代码规范，用什么组件库 balabala…</p></blockquote><p>那行呗，你开心就好，现在连 webpack 都不兴提一嘴了</p><h3 id="那咋做嘛">那咋做嘛</h3><p>提前说明，前端工程逃不过使用很多工具，包括构建与编译等。这里不讨论以上问题，只有编程「思想」</p><p>扒拉一段软件工程的含义：</p><blockquote><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p></blockquote><p>另外，IBM 的大型机之父布鲁克斯发布了《没有银弹》：</p><blockquote><p>从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等</p></blockquote><p>这里提到了「结构化程序设计」：</p><blockquote><p>结构化编程，一种编程典范。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><p>其实说到底总会有几点：</p><ul><li>高性能</li><li>高可用</li><li>高稳定</li><li><strong>可维护</strong></li></ul><p>关于可维护，这个时候可以来几个经典问题，问问自己，我现在在写的这个应用：</p><ul><li>是否有自动测试：unit test, e2e test？</li><li>是否会出现：点一个地方，哪哪都在 loading？（排除你偷懒连 loading 都不给）</li><li>一样的模块，在不同地方显示是不一样的？</li><li>一旦有一个样式改动，需要改十几个文件？</li></ul><p>这个时候，「组件」思想又被抬上台面，毕竟 <strong>组件化即一种分治思想</strong>。如果逃离了这个，那么单元测试就无法实现，因为<strong>此刻不存在单元</strong>，第一个问题不攻自破</p><p>接着，因为在应用之初根本没对应用进行设计，每个人拿着原型就开始整，最后各自写各自的，数据流都在某个组件里维护。接着产品经理要求「各数据展示需要同步」的时候怎么办？还不是指着产品骂娘然后做了一手操作：在产生 update 的地方后再 fetch 一次数据。所以第二个问题接着不攻自破</p><p>那怎么做其实非常明了：</p><ol><li>应用设计：在应用之初规划数据流</li><li>interface：看起来像爽哥，声音像爽哥，那就是爽哥</li></ol><p>数据流在设计之初就很好办，遇事不决先抄一版 flux —— 用 store 管理各种列表的数据和状态；列表页可以 keep-alive，根据 route 流向决定 store 的更新；VM 做成订阅/发布模型，这样，数据发起更新后，正在订阅数据的 V 可以做出更新……</p><p><strong>别信某些平台的前端爽文。什么 vuex/redux 等被称为状态管理的 library，只能用来管理共享状态，不能用来存放业务数据。Angular 看到这场景不得当场笑裂开</strong></p><p>到这也会发现，各种「台」的大型应用，最后也都是面向对象的思想。应用一旦复杂起来就需要一个充血模型。<s>那就更好办了，前端也直接 DDD ！直接嫖了后端的架构设计图</s></p><p>（顺便非常推荐《人月神话》，即使土，但45年依然流行是有道理的，其对于软件工程和项目管理的经验还有参考价值）</p><h2 id="最后">最后</h2><p>本来写这个文章的时候是想把遇到的事情都嘴臭一遍的，最后还是把这部分都清干净了，作为一个可能有用的文字。在此特别感谢若干 toB 项目，这几年在 toB 的公司中摸爬滚打带给我的一些新（旧）灵感（都是嫖后端和 GUI 应用的），终于让我这种杂学玩家体现出一点点作用</p><p>同时践行「敏捷开发」也有一段时间了，足够扎实的设计才能敏捷，不然就变成永远在填坑，而不是敏捷</p><p>所以这篇文章也作为开始，现在正在实践把「领域驱动设计」和「C4 模型」带到前端开发中。没错，又想开一个博文坑…</p><p>越来越觉得，前端架构设计可以参考 <code>rust</code> 的 <code>trait</code>，或者 <code>swift</code> 的 <code>protocol</code>，以及他们的设计模式。主观上觉得他们在思想有点相似</p><p>（不知道下次轮到我去面试时，恰好我的面试官看了我的博客，拿这玩意儿狙我…）</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://c4model.com/">The C4 model for visualising software architecture</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">维基百科 - 软件工程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">维基百科 - 结构化编程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">维基百科 - 敏捷软件开发</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科 - 领域驱动设计</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>一次面试发生的真实案例。并提出了「async 要配合 axios 才能用；ajax 没人用了」等理论 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次重新设计简历</title>
      <link href="/blog/2020/11/11/why-redesign-cv/"/>
      <url>/blog/2020/11/11/why-redesign-cv/</url>
      
        <content type="html"><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><span id="more"></span><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我又不跨平台我为什么要 electron</title>
      <link href="/blog/2020/08/08/hi-swift-react/"/>
      <url>/blog/2020/08/08/hi-swift-react/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><span id="more"></span><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let menubar &#x3D; NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)let popover &#x3D; NSPopover()</code></pre><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; if let 爽啊！if let menuBtn &#x3D; menubar.button &#123;   menuBtn.title &#x3D; &quot;click&quot;   menuBtn.action &#x3D; #selector(togglePopover)&#125;&#x2F;&#x2F; 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到let popoverController &#x3D; NSStoryboard(name: &quot;Main&quot;, bundle: nil)  .instantiateController(withIdentifier: &quot;PopoverViewController&quot;) as? PopoverViewControllerpopover.behavior &#x3D; .transientpopover.contentViewController &#x3D; popoverController</code></pre><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">@objc func togglePopover(_ sender: AnyObject) &#123;    if popover.isShown &#123;        closePopover(sender)    &#125; else &#123;        showPopover(sender)    &#125;&#125;</code></pre><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; 其实本文其实用不到，先写着extension PopoverViewController: WKNavigationDelegate &#123;&#125;</code></pre><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">webview.navigationDelegate &#x3D; self&#x2F;&#x2F; 通过 userContentController 获取 webview 中的事件let contentController &#x3D; webview.configuration.userContentController&#x2F;&#x2F; 定义与前端交互的方法名contentController.add(self, name: &quot;hello&quot;)</code></pre><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let pagePath &#x3D; Bundle.main.url(forResource: &quot;index&quot;, withExtension: &quot;html&quot;, subdirectory: &quot;build&quot;)&#x2F;&#x2F; let devUrl &#x3D; URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)&#x2F;&#x2F; load 方式也不同，一种是加载文件，一种直接加载 urlwebview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())&#x2F;&#x2F; webview.load(devUrl)</code></pre><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">extension PopoverViewController: WKScriptMessageHandler &#123;    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;        if message.name &#x3D;&#x3D; &quot;hello&quot; &#123;            &#x2F;&#x2F; 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转            let body &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)            &#x2F;&#x2F; 这里完全可以通过 switch 做模式匹配，不过这里没有            if (body[&quot;type&quot;] as! String) &#x3D;&#x3D; &quot;notify&quot; &#123;              let value: String &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)[&quot;value&quot;] as! String              showNotification(title: value)            &#125;        &#125;    &#125;    &#x2F;&#x2F; 调用通知 api，显示通知    func showNotification(title: String) &#123;        let notification &#x3D; NSUserNotification()        notification.deliveryDate &#x3D; Date(timeIntervalSinceNow: 1)        notification.title &#x3D; title        NSUserNotificationCenter.default.deliver(notification)    &#125;&#125;</code></pre><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 点击按钮弹出通知const handleClick &#x3D; () &#x3D;&gt; &#123;  window.webkit.messageHandlers.hello.postMessage(&#123;type: &#39;notify&#39;, value: &quot;Hello World&quot;&#125;)&#125;</code></pre><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结-2">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 electron 爬图片</title>
      <link href="/blog/2020/06/21/electron-crawler/"/>
      <url>/blog/2020/06/21/electron-crawler/</url>
      
        <content type="html"><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR-2">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><span id="more"></span><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const webview &#x3D; document.createElement(&#39;webview&#39;)&#x2F;&#x2F; 当页面加载完成之后会触发这个事件，可以继续做接下来的事情webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)</code></pre><p>于是封装一下变成</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  const webview &#x3D; document.createElement(&#39;webview&#39;)  &#x2F;&#x2F; 保险起见  webview.useragent    &#x3D; &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) &#39;    + &#39;AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;    + &#39;Chrome&#x2F;81.0.4044.129 Safari&#x2F;537.36 Edg&#x2F;81.0.416.68&#39;  webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)  document.body.appendChild(webview)  this.webview &#x3D; webview&#125;search(url) &#123;  this.webview.src &#x3D; url&#125;</code></pre><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">mainWindow &#x3D; new BrowserWindow(&#123;  webPreferences: &#123;    &#x2F;&#x2F; 这里    webviewTag: true,    nodeIntegration: true,  &#125;,&#125;)</code></pre><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then((html) &#x3D;&gt; &#123;  &#125;);</code></pre><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;  webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then(html &#x3D;&gt; &#123;    ipcRenderer.send(&#39;ganhuo&#39;, html)  &#125;);&#125;)</code></pre><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ipcMain.on(&#39;ganhuo&#39;, (e, arg) &#x3D;&gt; &#123;  const $ &#x3D; cheerio.load(arg)  &#x2F;&#x2F; 各种教程都能看到的  &#x2F;&#x2F; 这里没多余操作，是个 img 就拿走  &#x2F;&#x2F; 接着 reply 回 renderer  const imgs &#x3D; $(&#39;body&#39;).find(&#39;img&#39;).map((idx, ele) &#x3D;&gt; $(ele).attr(&#39;src&#39;)).get()  e.reply(&#39;chuhuo&#39;, imgs)&#125;)</code></pre><p><code>renderer</code> 边准备一个接收，这波结束</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  ipcRenderer.on(&#39;chuhuo&#39;, (e, result) &#x3D;&gt; &#123;    this.setState(&#123;      imgs: result,    &#125;);  &#125;);&#125;</code></pre><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接-2">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整一个家庭服务器记录</title>
      <link href="/blog/2020/06/07/home-server/"/>
      <url>/blog/2020/06/07/home-server/</url>
      
        <content type="html"><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><span id="more"></span><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后-2">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content>
      
      
      <categories>
          
          <category> 整点花活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link href="/blog/2020/06/04/hammerspoon-clipboard/"/>
      <url>/blog/2020/06/04/hammerspoon-clipboard/</url>
      
        <content type="html"><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR-5">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><span id="more"></span><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容const completionFn &#x3D; choice &#x3D;&gt; &#123;  &#x2F;&#x2F; 一般来说这个判断不可省略，这样可以方便排除取消的情况  if (choice) &#123;&#125;&#125;const chooser &#x3D; hs.chooser.new(completionFn)</code></pre><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">chooser.show()chooser.hide()</code></pre><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.readString() &#x2F;&#x2F; 读取最后一次剪贴板的文本pasteboard.readImage() &#x2F;&#x2F; 读取最后一次剪贴板的图片数据</code></pre><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.changeCount()</code></pre><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const clipboard &#x3D; new Clipboard()&#x2F;&#x2F; 我选择 1s 检查一次export const clipWatcher &#x3D; hs.timer.new(1, () &#x3D;&gt; &#123;  const now &#x3D; hs.pasteboard.changeCount()  if (now !&#x3D;&#x3D; preCount) &#123;    pcall(clipboard.save.bind(clipboard))    preCount &#x3D; now  &#125;&#125;)clipWatcher.start()</code></pre><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">save() &#123;  const types &#x3D; hs.pasteboard.contentTypes&lt;ModelChoice[&#39;type&#39;]&gt;()  for (const type of types) &#123;    if (isImgType(type)) &#123;      this.saveImage(type)    &#125; else if (isTextType(type)) &#123;      this.saveText(type)    &#125;  &#125;&#125;</code></pre><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">hs.hotkey.bind(clipboardConf.hotkey[0], clipboardConf.hotkey[1], () &#x3D;&gt; &#123;  clipboard.show()&#125;)</code></pre><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">this.chooser!.choices(choices)this.chooser!.show()</code></pre><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> hammerspoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link href="/blog/2020/06/02/hammerspoon-ts/"/>
      <url>/blog/2020/06/02/hammerspoon-ts/</url>
      
        <content type="html"><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><span id="more"></span><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><pre class="line-numbers language-none"><code class="language-none">npm inityarn add typescript-to-lua --dev</code></pre><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;dev&quot;: &quot;tstl --watch&quot;,&quot;build&quot;: &quot;tstl&quot;</code></pre><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> hammerspoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 容器内通信</title>
      <link href="/blog/2020/03/29/docker-container-bridge/"/>
      <url>/blog/2020/03/29/docker-container-bridge/</url>
      
        <content type="html"><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><span id="more"></span><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network create -d bridge my-bridge</code></pre><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --network my_bridge [...]</code></pre><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Context 传递多语言文本</title>
      <link href="/blog/2020/01/31/react-translate/"/>
      <url>/blog/2020/01/31/react-translate/</url>
      
        <content type="html"><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><span id="more"></span><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; createContext &#125; from &#39;react&#39;const langContext &#x3D; createContext(&#123;&#125; as ContextInterface)&#x2F;&#x2F; 创建上下文后输出 Provider 和 Consumer 还是要的export const Provider &#x3D; langContext.Providerexport const Consumer &#x3D; langContext.Consumer&#x2F;&#x2F; ps: 其实 Consumer 用不上...</code></pre><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const genTranslate &#x3D; (lang: string) &#x3D;&gt; &#123;  const _message &#x3D; require(&#96;@&#x2F;lang&#x2F;$&#123;lang&#125;.json&#96;)  if (!_message) &#123;    throw Error(&#96;$&#123;lang&#125; language json was not found.&#96;)  &#125;  const formatMessage &#x3D; (&#123; id, defaultMsg &#125;: FormatMessageType): string &#x3D;&gt;    &#x2F;&#x2F; _get 来自 lodash    _get(_message, id) || defaultMsg || &#39;&#39;  const formatter &#x3D; () &#x3D;&gt; (&#123; formatMessage, _message &#125;)  return formatter()&#125;</code></pre><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const useIntl &#x3D; (): ContextInterface &#x3D;&gt; useContext(langContext)</code></pre><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const &#123; formatMessage: t &#125; &#x3D; useIntl()</code></pre><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个 rust web server</title>
      <link href="/blog/2019/12/29/try-actix/"/>
      <url>/blog/2019/12/29/try-actix/</url>
      
        <content type="html"><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR-7">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><span id="more"></span><h2 id="创建应用-2">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]actix-web &#x3D; &quot;2.0&quot;actix-rt &#x3D; &quot;1.0&quot;# envdotenv &#x3D; &quot;0.15.0&quot;log &#x3D; &quot;0.4.8&quot;env_logger &#x3D; &quot;0.7.1&quot;</code></pre><p>然后在<code>main.rs</code>创建启动函数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use actix_web::&#123;App, HttpServer, get&#125;;#[get(&quot;&#x2F;&quot;)]fn index() -&gt; HttpResponse &#123;    HttpResponse::Ok().body(&quot;Hello World&quot;)&#125;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new().service(index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await&#125;</code></pre><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+-- src| +-- controller| | +-- mod.rs| +-- services| | +-- mod.rs| +-- models| | +-- mod.rs| +-- middleware| | +-- mod.rs</code></pre><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]# serdeserde &#x3D; &quot;1.0.104&quot;serde_derive &#x3D; &quot;1.0.104&quot;serde_json &#x3D; &quot;1.0.44&quot;json &#x3D; &quot;0.12.0&quot;</code></pre><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use serde_derive::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Clone)]pub struct Payload&lt;T&gt; &#123;    pub code: isize,    pub message: String,    #[serde(skip_serializing_if &#x3D; &quot;Option::is_none&quot;, default)]    pub payload: Option&lt;T&gt;,&#125;</code></pre><p>接着，从<code>controller/index</code>开始</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[derive(Deserialize)]struct Info &#123;    message: String&#125;#[get(&quot;&#x2F;&quot;)]pub async fn index(query: web::Query&lt;Info&gt;) -&gt; Result&lt;HttpResponse, Error&gt; &#123;    &#x2F;&#x2F; 在Query拿到与 Info 结构一样的参数    &#x2F;&#x2F; 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理    &#x2F;&#x2F; rust 真严格..    let result &#x3D; crate::services::index::get_helloworld(query.message.clone());    Ok(HttpResponse::Ok().json(result))&#125;</code></pre><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use crate::models::payload::Payload;&#x2F;&#x2F; 简单写一个服务pub fn get_helloworld(msg: String) -&gt; Payload&lt;()&gt; &#123;    Payload &#123;        code: 0,        message: msg.to_string(),        payload: None    &#125;&#125;</code></pre><p>最后改一下<code>main.rs</code></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">+mod controllers;+mod models;+mod services;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new()-        .service(index);+        .service(controllers::index::index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await</code></pre><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;code&quot;: 0,    &quot;message&quot;: &quot;helloworld&quot;&#125;</code></pre><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content>
      
      
      <categories>
          
          <category> 服务实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> actix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果我把 Rust 用在网页呢</title>
      <link href="/blog/2019/10/13/try-wasm/"/>
      <url>/blog/2019/10/13/try-wasm/</url>
      
        <content type="html"><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了</p><span id="more"></span><h2 id="题干？">题干？</h2><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h2 id="板条箱？">板条箱？</h2><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/DaGenix/rust-crypto">DaGenix/rust-crypto</a></li><li><a target="_blank" rel="noopener" href="https://github.com/RustCrypto">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buttercup/rust-crypto-wasm">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h2 id="创建？">创建？</h2><blockquote><p>&gt; cargo generate --git <a target="_blank" rel="noopener" href="https://github.com/rustwasm/wasm-pack-template">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]wasm-bindgen &#x3D; &quot;0.2&quot; # 核心rand &#x3D; &quot;0.7.2&quot; # 但接下来用不上aes &#x3D; &quot;0.3.2&quot; # 添加这个只是为了分组依赖与类型cfb-mode &#x3D; &quot;0.3.2&quot; # 这个才是加密核心</code></pre><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h2 id="食用？">食用？</h2><h3 id="编译源码">编译源码</h3><ol><li>加载 crate（上板条！）</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate aes;extern crate cfb_mode;</code></pre><ol start="2"><li>声明依赖，或者说<code>import</code></li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use aes::Aes256; &#x2F;&#x2F; 使用 256use cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; &#x2F;&#x2F; cfb是基于流加密其中一种use cfb_mode::Cfb; &#x2F;&#x2F; 需要用这个结构体</code></pre><ol start="3"><li>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F; 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度type AesCfb &#x3D; Cfb&lt;Aes256&gt;;</code></pre><ol start="4"><li>随便写个加密</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[wasm_bindgen]pub fn test() -&gt; Vec&lt;u8&gt; &#123;  let key: &amp;[u8; 32] &#x3D; b&quot;nashizhendeniup,,nashizhendeniup&quot;;  let iv: &amp;[u8; 16]  &#x3D; b&quot;unique,un,unique&quot;;  let msg &#x3D; &quot;那你是真的牛皮&quot;;  let mut buffer &#x3D; msg.as_bytes().to_vec();  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;mut buffer);  buffer&#125;</code></pre><h3 id="到前端使用">到前端使用</h3><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx&gt;.wasm</li><li>&lt;xxx&gt;.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>&gt; npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123;test&#125; from &#39;crypto-test&#39;console.log(test())</code></pre><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西</p><pre class="line-numbers language-none"><code class="language-none">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</code></pre><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下</p><pre class="line-numbers language-none"><code class="language-none">  get_local $p0  i32.load  get_local $p1  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)  get_local $p0  i32.load  get_local $p1  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)  i32.const 1056732  get_local $p0</code></pre><p>看得我都有女装的冲动了（大雾</p><h2 id="结束？">结束？</h2><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h2 id="（附加资料）加密？">（附加资料）加密？</h2><h3 id="分组密码">分组密码</h3><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h3 id="AES">AES</h3><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h4 id="iv">iv?</h4><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h4 id="key">key?</h4><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h4 id="padding">padding?</h4><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h3 id="AES256-128">AES256? 128?</h3><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h3 id="AES256CFB">AES256CFB?</h3><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自 swift 的跨界执法（一） —— Vapor</title>
      <link href="/blog/2019/06/23/try-vapor-0/"/>
      <url>/blog/2019/06/23/try-vapor-0/</url>
      
        <content type="html"><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧</p><span id="more"></span><h2 id="安装-3">安装</h2><p>直接装个工具集吧</p><pre class="line-numbers language-none"><code class="language-none">brew tap vapor&#x2F;tapbrew install vapor&#x2F;tap&#x2F;vapor</code></pre><h2 id="生成应用">生成应用</h2><pre class="line-numbers language-none"><code class="language-none">vapor new Hello</code></pre><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;Hellovapor xcode</code></pre><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h2 id="编写体验-2">编写体验</h2><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; DirectoryConfig.detect().workDir 项目绝对路径let storePath &#x3D; DirectoryConfig.detect().workDir + &quot;Db&#x2F;store.db&quot;let sqlite &#x3D; try SQLiteDatabase(storage: .file(path: storePath))</code></pre><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h2 id="相关信息">相关信息</h2><p>Vapor 自己提供一个<a target="_blank" rel="noopener" href="http://vapor.university/">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content>
      
      
      <categories>
          
          <category> 服务实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> vapor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自 swift 的跨界执法（零） —— Perfect</title>
      <link href="/blog/2019/06/07/try-swift-perfect/"/>
      <url>/blog/2019/06/07/try-swift-perfect/</url>
      
        <content type="html"><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h2 id="安装-2">安装</h2><p>安装还是相当容易，官方编译器起一个可执行类型项目</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift package init --type&#x3D;executable</code></pre><span id="more"></span><p>其次，在<code>Package.swift</code>中添加依赖</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">dependencies: [    .package(url: &quot;https:&#x2F;&#x2F;github.com&#x2F;PerfectlySoft&#x2F;Perfect-HTTPServer.git&quot;, from: &quot;3.0.0&quot;)],</code></pre><p>接着，编译即安装依赖（熟悉啊！）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift build</code></pre><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift package generate-xcodeproj</code></pre><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h2 id="编写体验">编写体验</h2><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><s>后来发现，我好像用不上</s></p><p>按照习惯创建了一个结构体用来存放配置内容</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">struct GlobalConfig &#123;    let baseRoute &#x3D; &quot;&#x2F;api&#x2F;v1&quot;    let httpPort &#x3D; 8081&#125;</code></pre><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">import PerfectHTTPimport PerfectHTTPServer&#x2F;&#x2F; 字典不是JSON，使用库中方法得以把字典转为JSONimport PerfectLiblet config &#x3D; GlobalConfig()let server &#x3D; HTTPServer()var routes &#x3D; Routes(baseUri: config.baseRoute)</code></pre><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let list: [[String: Any]] &#x3D; [    [&quot;name&quot;: &quot;index&quot;, &quot;url&quot;: &quot;&#x2F;home&quot;, &quot;method&quot;: HTTPMethod.get],    [&quot;name&quot;: &quot;show&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.get],    [&quot;name&quot;: &quot;create&quot;, &quot;url&quot;: &quot;&#x2F;home&quot;, &quot;method&quot;: HTTPMethod.post],    [&quot;name&quot;: &quot;update&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.put],    [&quot;name&quot;: &quot;delete&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.delete]]</code></pre><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">RoutesConfig().list.map &#123;    routes.add(method: $0[&quot;method&quot;] as! HTTPMethod, uri: $0[&quot;url&quot;] as! String, handler: &#123; (request, response) in        let json: [String: Any] &#x3D; [&quot;code&quot;: 0, &quot;message&quot;: &quot;success&quot;]        let variables &#x3D; request.urlVariables        var newJson &#x3D; json        if (!variables.isEmpty) &#123;            for e in variables &#123;                newJson[e.key] &#x3D; variables[e.key]            &#125;        &#125;        let output &#x3D; try! newJson   &#x2F;&#x2F; 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）            .jsonEncodedString()        response            .setHeader(.contentType, value: &quot;application&#x2F;json&quot;)            .appendBody(string: output)            .completed()    &#125;)&#125;</code></pre><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">server.addRoutes(routes)server.serverPort &#x3D; UInt16(config.httpPort)</code></pre><p>最后（简单）执行</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">do &#123;    try server.start()&#125; catch &#123;    fatalError(&quot;\(error)&quot;)&#125;</code></pre><h2 id="原因">原因</h2><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content>
      
      
      <categories>
          
          <category> 服务实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> perfect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react函数级写法和继承写法有什么区别？</title>
      <link href="/blog/2019/05/28/react-component-method/"/>
      <url>/blog/2019/05/28/react-component-method/</url>
      
        <content type="html"><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思</p><span id="more"></span><h2 id="编写风格">编写风格</h2><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h2 id="default-props">default props</h2><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h2 id="this">this</h2><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h2 id="mixin">mixin</h2><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<s>与复读</s>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defineProperty? Proxy?</title>
      <link href="/blog/2019/04/20/why-vue-proxy/"/>
      <url>/blog/2019/04/20/why-vue-proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<s>我真的应该学会怎么清楚表达观点…</s></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h2 id="defineProperty">defineProperty</h2><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code></p><span id="more"></span><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123;&#125;Object.defineProperty(obj, &#39;name&#39;, &#123;  value: &#39;colmugx&#39;,&#125;);</code></pre><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h2 id="Proxy">Proxy</h2><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;&#125;, &#123;  get(target, name) &#123;    return name in target ? target[name] : target  &#125;&#125;)</code></pre><h2 id="？">？</h2><h3 id="数据拦截">数据拦截</h3><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123;&#125;let value &#x3D; undefinedObject.defineProperty(obj, &#39;key&#39;, &#123;  get() &#123;    return value  &#125;  set(val) &#123;    value &#x3D; val  &#125;&#125;)</code></pre><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;key: undefined&#125;, &#123;  get(target, prop) &#123;    &#x2F;&#x2F; 由于代理了所有操作，那么返回 404 纯属意愿    return prop in target ? target[prop] : &#39;404 Not Found&#39;  &#125;  set(val) &#123;    target[prop] &#x3D; val  &#125;&#125;)</code></pre><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h3 id="只需要-defineProperty？怎么可能？">只需要 defineProperty？怎么可能？</h3><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h3 id="为什么-Proxy？">为什么 Proxy？</h3><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">这个问题</a>，解决这个问题的方法有点骚，<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123; a: &#123; b: &#123; c: &#123; d: &#123; e: &#39;???&#39; &#125;&#125;&#125;&#125;&#125;  &#x2F;&#x2F; ???</code></pre><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;&#125;, &#123;  apply(target, context, args) &#123;&#125;&#125;)</code></pre><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h3 id="补充">补充</h3><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h2 id="为什么-Vue2-不直接用-Proxy">为什么 Vue2 不直接用 Proxy</h2><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h2 id="Vue-React">Vue &amp; React</h2><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Nlvi 「添加到桌面」</title>
      <link href="/blog/2019/04/17/about-nlvi-pwa/"/>
      <url>/blog/2019/04/17/about-nlvi-pwa/</url>
      
        <content type="html"><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<s>好想换 iPad Mini (new)</s></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。</p><span id="more"></span><h2 id="meta">meta</h2><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name&#x3D;&quot;apple-touch-fullscreen&quot; content&#x3D;&quot;yes&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-title&quot; content&#x3D;&quot;Colmugx&#39;s Blog&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;default&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-icon&quot;  sizes&#x3D;&quot;72x72&quot;  href&#x3D;&quot;icon.ico&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot;  sizes&#x3D;&quot;72x72&quot;  href&#x3D;&quot;icon.ico&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; media&#x3D;&quot;(device-width: 375px)&quot; href&#x3D;&quot;apple-launch-1125x2436.png&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; media&#x3D;&quot;(orientation: landscape)&quot; href&#x3D;&quot;apple-touch-startup-image-2048x1496.png&quot;&gt;</code></pre><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h2 id="apple-touch-startup-image">apple-touch-startup-image</h2><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a target="_blank" rel="noopener" href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nlvi </tag>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我今天给 let 安排了</title>
      <link href="/blog/2019/03/27/you-dont-know-let/"/>
      <url>/blog/2019/03/27/you-dont-know-let/</url>
      
        <content type="html"><![CDATA[<h3 id="Round-1">Round 1</h3><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h3 id="Round-2">Round 2</h3><blockquote><p>- 如果改成这样呢<br>function a() {<br>function inner() {}<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？</p><span id="more"></span><h2 id="Why">Why?</h2><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function () &#123;  a &#x3D; &#39;caonima&#39; &#x2F;&#x2F; 下面有 let，a 直接被该块锁定，这里报错  let a &#x2F;&#x2F; 到这里才完成初始化，变量开始正常使用，但变量早已提升  console.log(a) &#x2F;&#x2F; 这里不是 caonima 而是 undefined  a &#x3D; &#39;woshinidie&#39;  console.log(a) &#x2F;&#x2F; woshinidie&#125;</code></pre><p><a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/issues/767">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28140450">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zhihusucks">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后的 Nlvi</title>
      <link href="/blog/2019/03/25/bye-nlvi/"/>
      <url>/blog/2019/03/25/bye-nlvi/</url>
      
        <content type="html"><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！</p><span id="more"></span><p>所以 3.0 到 4.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常吐槽 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nlvi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做不完的题目</title>
      <link href="/blog/2019/03/23/last-test-questions/"/>
      <url>/blog/2019/03/23/last-test-questions/</url>
      
        <content type="html"><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。</p><span id="more"></span><h2 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟">1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const requests: Promise&lt;string&gt;[]  &#x3D; [&#39;&#x2F;a&#39;, &#39;&#x2F;b&#39;, &#39;&#x2F;c&#39;, &#39;&#x2F;d&#39;]  .map(v &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;    const time &#x3D; Math.floor(Math.random()*1000)    setTimeout(() &#x3D;&gt; &#123;      resolve(&#96;$&#123;v&#125; spent $&#123;time&#125;&#96;)    &#125;, time);  &#125;))Promise.race(requests).then(console.log)</code></pre><h2 id="2-使用你擅长的方式实现-Dialog">2. 使用你擅长的方式实现 Dialog</h2><p>这个一直在暗示可以使用 <code>vue</code> 或者 <code>react</code>，但是我有些紧张，一时半会只能想到只能用原生的方式</p><p>最后只能说是搬石头砸自己的脚，没写过一时没思路，导致写不完</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;body&gt;  &lt;div&gt;    &lt;button id&#x3D;&quot;dialog&quot;&gt;直视我！栽种！&lt;&#x2F;button&gt;  &lt;&#x2F;div&gt;  &lt;style&gt;    .dialog &#123;      display: none;      position: fixed;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);      background: #fff;      box-shadow: 1px 2px 8px 0 #c0c0c0;      color: #666;    &#125;    .mask &#123;      z-index: 1;      position: fixed;      top: 0;      left: 0;      background: rgba(0, 0, 0, 0.65);      filter: blur(80%);    &#125;    .dialog-header &#123;      width: 100%;      height: 45px;      margin: 8px 16px;    &#125;    .isShow &#123;      display: block;    &#125;    .footer &#123;      position: absolute;      bottom: 0;      left: 0;      right: 0;      height: 50px;      display: flex;      flex-flow: row nowrap;      justify-content: flex-end;      align-items: center;      margin: 0 16px;    &#125;    .cancel-btn &#123;      outline: 0;      border: 2px solid #ccc;      color: #999;      display: flex;      justify-content: center;      align-items: center;      padding: 8px;      border-radius: 8px;    &#125;  &lt;&#x2F;style&gt;  &lt;script&gt;    class TheDialog &#123;      constructor(id) &#123;        this.btn &#x3D; document.querySelector(&#39;#dialog&#39;)        this.width &#x3D; 500        this.height &#x3D; 300        this.template()        this.listener()        document.body.appendChild(this.container)      &#125;      template() &#123;        const container &#x3D; document.createElement(&#39;div&#39;)        container.style.width &#x3D; this.width + &#39;px&#39;        container.style.height &#x3D; this.height + &#39;px&#39;        container.classList.add(&#39;dialog&#39;)        container.appendChild(this.headerTem())        container.appendChild(this.bodyTem())        container.appendChild(this.footerTem())        this.container &#x3D; container      &#125;      bodyTem() &#123;        const body &#x3D; document.createElement(&#39;div&#39;)        body.innerHTML &#x3D; &#39;Hello World&#39;        body.style.margin &#x3D; &#39;16px&#39;        body.style.color &#x3D; &#39;#333&#39;        body.style.fontSize &#x3D; &#39;24px&#39;        return body      &#125;      headerTem() &#123;        const header &#x3D; document.createElement(&#39;div&#39;)        header.classList.add(&#39;dialog-header&#39;)        const title &#x3D; document.createElement(&#39;div&#39;)        title.innerHTML &#x3D; &#39;Dialog&#39;        header.appendChild(title)        return header      &#125;      footerTem() &#123;        const footer &#x3D; document.createElement(&#39;div&#39;)        const btn &#x3D; document.createElement(&#39;button&#39;)        footer.classList.add(&#39;footer&#39;)        btn.classList.add(&#39;cancel-btn&#39;)        btn.innerHTML &#x3D; &#39;CANCEL&#39;        btn.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;          e.stopPropagation()          this.close()        &#125;)        footer.appendChild(btn)        return footer      &#125;      listener() &#123;        this.btn.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;          e.stopPropagation()          this.toggle()        &#125;)      &#125;      toggle() &#123;        const isShow &#x3D; this.container.classList.contains(&#39;isShow&#39;)        if (isShow) &#123;          this.close()        &#125; else &#123;          this.container.classList.add(&#39;isShow&#39;)          document.body.classList.add(&#39;mask&#39;)        &#125;      &#125;      close() &#123;        this.container.classList.remove(&#39;isShow&#39;)        document.body.classList.remove(&#39;mask&#39;)      &#125;    &#125;    (() &#x3D;&gt; &#123;      const theDialog &#x3D; new TheDialog()      window.dialog &#x3D; theDialog    &#125;)()  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre><p>这样凑合能用</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux —— combineReducers</title>
      <link href="/blog/2019/03/08/redux-combinereducers/"/>
      <url>/blog/2019/03/08/redux-combinereducers/</url>
      
        <content type="html"><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<s>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</s></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code></p><span id="more"></span><p><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h2 id="getUndefinedStateErrorMessage">getUndefinedStateErrorMessage</h2><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h2 id="assertReducerShape">assertReducerShape</h2><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h2 id="combineReducers">combineReducers</h2><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 提取对象中所有字段名，一个 key 对应一个 reducer 方法const reducerKeys &#x3D; Object.keys(reducers)&#x2F;&#x2F; 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。const finalReducers &#x3D; &#123;&#125;&#x2F;&#x2F;...if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;  finalReducers[key] &#x3D; reducers[key]&#125;&#x2F;&#x2F; 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试&#x2F;&#x2F; 再把初步验证过的 reducer 取出const finalReducerKeys &#x3D; Object.keys(finalReducers)&#x2F;&#x2F;...let shapeAssertionError&#x2F;&#x2F; 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理try &#123;  assertReducerShape(finalReducers)&#125; catch (e) &#123;  shapeAssertionError &#x3D; e&#125;</code></pre><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建一个对比记录变量以及新 statelet hasChanged &#x3D; falseconst nextState &#x3D; &#123;&#125;&#x2F;&#x2F; 遍历刚刚验证完的 reducer key 数组for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;  const key &#x3D; finalReducerKeys[i]  const reducer &#x3D; finalReducers[key]  &#x2F;&#x2F; 获取当前 state  const previousStateForKey &#x3D; state[key]  &#x2F;&#x2F; 通过执行 reducer 得到新的 state  const nextStateForKey &#x3D; reducer(previousStateForKey, action)  if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    const errorMessage &#x3D; getUndefinedStateErrorMessage(key, action)    throw new Error(errorMessage)  &#125;  &#x2F;&#x2F; 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）  nextState[key] &#x3D; nextStateForKey  &#x2F;&#x2F; 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证  hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey&#125;&#x2F;&#x2F; 返回：有改变的返回新的，无改变返回原 state。return hasChanged ? nextState : state</code></pre><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
      <link href="/blog/2019/03/02/about-redux/"/>
      <url>/blog/2019/03/02/about-redux/</url>
      
        <content type="html"><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h2 id="createStore">createStore</h2><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法</li></ul><span id="more"></span><p>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</p><h2 id="copy">copy</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function store(state) &#123;  let currentState &#x3D; state || &#123;&#125;  let listeners &#x3D; []  return &#123; getState, dispatch, subscribe &#125;  function getState() &#123;    return currentState  &#125;  function subscribe(listener) &#123;    listeners.push(listener)  &#125;  function dispatch(action) &#123;    action.call(this, currentState)    listeners.forEach(f &#x3D;&gt; f.call(null))    return currentState  &#125;&#125;</code></pre><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位赌狗前端的自我修养</title>
      <link href="/blog/2018/11/19/gamble-fn/"/>
      <url>/blog/2018/11/19/gamble-fn/</url>
      
        <content type="html"><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p><p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p><p>为了方便以后支持更多的彩票，直接搞个类</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Gamble &#123;    static dualColor(red: number &#x3D; 6, blue: number &#x3D; 1) &#123;        const reds: [number, number] &#x3D; [1, 33];        const blues: [number, number] &#x3D; [1, 16];        return [this.randomVal(reds, red), this.randomVal(blues, blue)];    &#125;    private static randomVal(        fromto: number[],        total: number,        temp: number[] &#x3D; [],    ): number[] &#123;        const [head, ...body] &#x3D; (!temp.length            ? [...Array(fromto[1]).keys()]                  .map(item &#x3D;&gt; item + 1)                  .splice(fromto[0] - 1)            : fromto        ).sort(() &#x3D;&gt; Math.random() - 0.5);        return !total            ? temp            : this.randomVal(body, total - 1, temp.concat(head));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记在NPM抢空包名的经历</title>
      <link href="/blog/2018/07/12/kill-orphan-on-npm/"/>
      <url>/blog/2018/07/12/kill-orphan-on-npm/</url>
      
        <content type="html"><![CDATA[<p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p><p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p><p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p><span id="more"></span><h2 id="寻找入口">寻找入口</h2><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p><p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p><p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p><p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p><h2 id="采取行动">采取行动</h2><p>操起我400分的4级水平英语，就开始写。</p><blockquote><p>hi,<br>here a profile page: xxxxxx.</p><p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p><p>I NEED HELP! THANK YOU!</p></blockquote><p>过了一会收到回信：</p><blockquote><p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p><p>Your request is being reviewed by our support staff and we’ll be responding soon.</p><p>To add additional comments, reply to this email.</p></blockquote><p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p><blockquote><p>Hey there,</p><p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p><p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p><p>Thanks for your patience.</p></blockquote><p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p><p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p><p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p><blockquote><p>Thanks for reaching out.</p><p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p><p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p></blockquote><p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p><p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p><blockquote><p>Thanks for getting back to me with that information.</p><p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p></blockquote><p>我上了我的 npm 看了一眼，惊了…这就拿到了…</p><p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我就写个方法，这么麻烦？</title>
      <link href="/blog/2018/07/04/different-function/"/>
      <url>/blog/2018/07/04/different-function/</url>
      
        <content type="html"><![CDATA[<p>最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。</p><p>JavaScript中定义一个方法主要可以分成两种形式：</p><ul><li>函数声明</li><li>函数表达式</li></ul><span id="more"></span><h2 id="函数声明">函数声明</h2><p>声明体是最普通的，其他语言也相近的一种方式。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a, b) &#123;  return a + b&#125;func(1, 2) &#x2F;&#x2F; 3</code></pre><p>不过，毕竟是「函数就是爸爸」的JavaScript！它有一个特性：函数提升。</p><blockquote><p>函数提升：把所有函数提升到当前作用域上，从而做到了可以“未声明先调用”。</p></blockquote><h2 id="函数表达式">函数表达式</h2><p>这可能是目前用的最多的声明方式，因为可以搭配箭头函数假装自己用的是函数式编程。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function(a, b) &#123;  return a + b&#125;&#x2F;&#x2F; 箭头函数版本const funcA &#x3D; (a, b) &#x3D;&gt; a + bfunc(1,2) &#x2F;&#x2F; 3</code></pre><p>但变量受作用域影响，所以<code>const</code>和<code>let</code>并没有变量提升的能力。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">funcA(1) &#x2F;&#x2F; ReferenceError: funcA is not definedconst funcA &#x3D; a &#x3D;&gt; a</code></pre><p>燃鹅，这才刚刚开始……</p><h2 id="匿名-具名">匿名 &amp; 具名</h2><p>匿名就是上面那种，具名就是给函数本体再起一个名字。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function funcName() &#123;&#125;</code></pre><p>这样有什么区别？后面那个名字又不能用！答案还是有区别的。</p><p>首先有一个函数名推断，比如上面这个函数，那么<code>func.name</code>会返回<code>funcName</code>。如果匿名函数的话<code>[fn].name</code>会返回<code>''</code>。其次这个名字可以在函数内部使用。当然了指代的就是自己了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function funcName(a, b) &#123;  return a &lt; 0 ? b : funcName(a+1-b, a)&#125;func(431, 151) &#x2F;&#x2F; 281funcName(431, 151) &#x2F;&#x2F; ReferenceError: funcName is not definedconsole.log(func.name) &#x2F;&#x2F; funcNametypeof funcName &#x3D;&#x3D;&#x3D; &#39;function&#39; &#x2F;&#x2F; false</code></pre><p>所以这种方式最适合递归函数了。</p><h2 id="函数表达式依然是个常-变量">函数表达式依然是个常/变量</h2><p>把它当做一个“方程”来看吧，关键词已经决定了这个“量”会以什么形式存在，比如<code>var</code>和<code>let</code>是变量，<code>const</code>是常量，并且<code>let</code>还有作用域范围。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const funcA &#x3D; () &#x3D;&gt; console.log(&#39;A&#39;)funcA() &#x2F;&#x2F; AfuncA &#x3D; () &#x3D;&gt; console.log(&#39;AA&#39;) &#x2F;&#x2F; TypeError: Assignment to constant variable.var funcB &#x3D; () &#x3D;&gt; console.log(&#39;B&#39;)funcB() &#x2F;&#x2F; BfuncB &#x3D; () &#x3D;&gt; console.log(&#39;BB&#39;)funcB() &#x2F;&#x2F; BB</code></pre><p>题外话：那么就有个老生常谈的问题了，函数表达式按道理来讲是“灵活的”，那么下面这个函数会是什么结果？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function funcB() &#123;  console.log(&#39;B&#39;)&#125;funcB() &#x2F;&#x2F; BBfunction funcB() &#123;  console.log(&#39;BB&#39;)&#125;funcB() &#x2F;&#x2F; BB</code></pre><p>为什么？还是那句话：JavaScript世界中，函数是你爹！</p><h2 id="箭头函数">箭头函数</h2><p>又到了大家最最喜欢的箭头函数环节，现在还有谁是不愿意写箭头函数的？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; a &#x3D;&gt; b &#x3D;&gt; a + bfunc(1)(2) &#x2F;&#x2F; 3</code></pre><p>在这篇文章：<a href="/blog/2017/03/03/js-this/">《关于JavaScript的this》</a>已经被安排的明明白白了。</p><p>实际上现在看这篇文章也有点问题，年轻的时候牛批吹多了。总结箭头函数两个特点就是：</p><ul><li>不会创造上下文（自身无this）</li><li>必然是个匿名函数</li><li>没有 <code>arguments</code></li></ul><p>不是两个吗？怎么变成三个了？此时你可能会回去检查刚刚那句话，然后我现在悄悄告诉你，（第三点是送的）。</p><h2 id="计算属性函数名">计算属性函数名</h2><p>这个应该是在“对象”的环境中存在，毕竟对象可以指代很多种只要是对象的情况。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const object &#x3D; &#123;  [&#39;a&#39; + &#39;b&#39;](a, b) &#123;    return a + b  &#125;&#125;object.ab(1, 3) &#x2F;&#x2F; 3</code></pre><p>这就实现了“函数名可以暂时不知道是什么”的情况，通过计算来得到这个函数。</p><h2 id="Other">Other</h2><h2 id="new-Function">new Function</h2><p>这是一个不知道哪里可以用得上但是就是可以用的方式：通过对象创建</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;)func(1, 2) &#x2F;&#x2F; 3</code></pre><h2 id="函数参数初始值">函数参数初始值</h2><p>可能有一定需求，但可能没有</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a &#x3D; 1, b &#x3D; 2) &#123;  return a + b&#125;func() &#x2F;&#x2F; 3</code></pre><p>可能我们更常用的有这些</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const funcA &#x3D; (obj &#x3D; &#123;&#125;) &#x3D;&gt; objconst funcB &#x3D; (arr &#x3D; []) &#x3D;&gt; arr</code></pre><p>但JavaScript毕竟是「函数是第一公民」的语言，有机会会写到很多高阶函数。所以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; (fn &#x3D; () &#x3D;&gt; &#39;💉💧🐮🍺&#39;) &#x3D;&gt; fn.call(null)</code></pre><p>凭什么函数作为参数就不能有初始值呢？当然是可以的呀！</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于四轴的踩坑指南</title>
      <link href="/blog/2018/03/12/dji-interview/"/>
      <url>/blog/2018/03/12/dji-interview/</url>
      
        <content type="html"><![CDATA[<p>怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了<code>mavic air</code>（所以dji还是赚了？）</p><p>怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。</p><p>总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就<code>vue</code>和<code>react</code>之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……</p><span id="more"></span><h2 id="html5-css3">html5 css3</h2><p>css3：圆角，变形，线性渐变，阴影。后两个没答，另外阴影我一直以为是<code>css2</code>的。</p><p>html5: 算了挺多的…基本上用过的都说了一遍… 下次记得背一下（真的需要用到那么多？</p><h2 id="Vue">Vue</h2><h2 id="created-和-mounted-区别，ajax会在哪里操作">created 和 mounted 区别，ajax会在哪里操作</h2><blockquote><p>放在 created，因为 mounted 的时候还没有渲染节点。</p></blockquote><p>虽然这个问题也有一些讨论，有些会在<code>created</code>就做了，有些是在<code>mounted</code>做。</p><p>有问题吗？还真有。因为我想到的是：在<code>created</code>过程把数据获取之后，从虚拟dom转为真实dom的时候可以顺便把数据带进去。而不需要一整个组件都创建完整之后再去加载数据。毕竟到<code>mounted</code>的时候实例都建立完了，这个时候再刷新数据不是会引起刷新/重绘？不过这个问题不应该是我没看源码的问题，而是有些问题没了解透彻，或者说，文章看太少。</p><p>恰好就坑这了，要的就是在<code>mounted</code>，因为这个时候已经有组件实例了，也就是<code>this.$el</code>已经有树了，如果<code>ajax</code>过来的内容是需要依赖<code>el</code>的话，那在<code>created</code>的时候还没有东西呢。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期图示"></p><h2 id="深度-watcher">深度 watcher</h2><p>去翻了一下文档，我发现翻车的是自己吧！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">c: &#123;  handler: function (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,  deep: true&#125;,</code></pre><p>只需要给对象加个<code>deep</code>就行了,而<code>a.b</code>这种情况应不属于深度watch，这只是需要监听的数据在比较深处而已…</p><h2 id="vue-函数式组件">vue 函数式组件</h2><p>这是一个补充问题，关于 什么时候可以使用函数式组件，我觉得确实没什么可以说的啊…</p><p>如果只是充当渲染任务，不需要持久化不需要状态，采用函数式组件可以减少开销。</p><p>总的来说，比较严重的问题还是出现在：表达能力有问题 + 理解框架不够深刻（但远不及原理） + 狗娘的英语表达。还有<code>css</code>过于依赖补全导致想口头表述语句的时候，单词中间那段想不起来所以说不出口导致的丢分。所以打算CSS部分关闭补全一段时间。</p><p>这属于机会完全被自己毁了（还不是技术层面问题），所以烦躁和不甘又有什么用呢…</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise链式调用</title>
      <link href="/blog/2018/02/28/promise-chaining/"/>
      <url>/blog/2018/02/28/promise-chaining/</url>
      
        <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p><p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p><p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p><p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p><blockquote><p>只要函数返回值是一个函数，就可以连着调用</p></blockquote><p>So,</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p1.then((&#123; p2 &#125;) &#x3D;&gt; &#123;  return p2&#125;).then(&#123; p3 &#125; &#x3D;&gt; &#123;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抛下不成熟，开始nvim</title>
      <link href="/blog/2018/02/13/new-life-nvim/"/>
      <url>/blog/2018/02/13/new-life-nvim/</url>
      
        <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p><p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p><p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p><h2 id="iterm2">iterm2</h2><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。</p><span id="more"></span><p>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p><h2 id="zsh">zsh</h2><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p><h2 id="vim">vim</h2><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p><p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p><p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p><p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p><p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p><h2 id="tmux">tmux</h2><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p><p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p><p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>]]></content>
      
      
      <categories>
          
          <category> 整点花活 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> editor </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex源码理解（二）</title>
      <link href="/blog/2018/01/30/vuex-study-2/"/>
      <url>/blog/2018/01/30/vuex-study-2/</url>
      
        <content type="html"><![CDATA[<p>继续，这次尝试逐行理解Store类的东西</p><p>然后关于这次，一些“工具函数”都集中在<code>util.js</code>的这种做法，已经够我学的了。这是个很受用的做法。</p><h2 id="一些简单的东西">一些简单的东西</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;  assert(Vue, &#96;must call Vue.use(Vuex) before creating a store instance.&#96;)  assert(typeof Promise !&#x3D;&#x3D; &#39;undefined&#39;, &#96;vuex requires a Promise polyfill in this browser.&#96;)  assert(this instanceof Store, &#96;Store must be called with the new operator.&#96;)&#125; &#x2F;&#x2F; 断言函数在util，如果不满足前面的情况，后面以error 排出来&#x2F;&#x2F; （实际上就是想看有没有在vue环境中和有没有正确安装）</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123;  plugins &#x3D; [],  strict &#x3D; false&#125; &#x3D; options &#x2F;&#x2F; 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思</code></pre><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这里可能是会把整个vuex所有的内容都会规整到这些中&#x2F;&#x2F; store internal statethis._committing &#x3D; false  &#x2F;&#x2F; commit switch（ -&gt; mutations）this._actions &#x3D; Object.create(null) &#x2F;&#x2F; actionsthis._actionSubscribers &#x3D; [] &#x2F;&#x2F; 应该像在dva中看到的订阅，没用过也没弄清楚应该怎么用this._mutations &#x3D; Object.create(null) &#x2F;&#x2F; mutationsthis._wrappedGetters &#x3D; Object.create(null) &#x2F;&#x2F; gettersthis._modules &#x3D; new ModuleCollection(options) &#x2F;&#x2F; 分模块得到一个类this._modulesNamespaceMap &#x3D; Object.create(null)  &#x2F;&#x2F; 命名空间，上一次有讲到this._subscribers &#x3D; [] &#x2F;&#x2F; 所有订阅者this._watcherVM &#x3D; new Vue() &#x2F;&#x2F;watcher??应该跟vue的watcher有关？</code></pre><h2 id="开始跳着理解">开始跳着理解</h2><h2 id="store-与-操作绑定">store 与 操作绑定</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; bind commit and dispatch to selfconst store &#x3D; this &#x2F;&#x2F; 把store 是指向 this 的const &#123; dispatch, commit &#125; &#x3D; this &#x2F;&#x2F; 所以 &#123; dispatch, commit &#125; &#x3D; store ?this.dispatch &#x3D; function boundDispatch (type, payload) &#123;  return dispatch.call(store, type, payload)&#125;this.commit &#x3D; function boundCommit (type, payload, options) &#123;  return commit.call(store, type, payload, options)&#125;</code></pre><p>虽然有注释，就是把 commit, dispatch 和store绑定到<code>this</code>上，然后<code>&#123; dispatch, commit &#125; = store</code>了。接着class中的<code>dispatch</code>指向刚刚对象中<code>dispatch</code>的方法，通过<code>call</code>用法改变作用域调用。我们用到的<code>this.$store.dispatch</code>应该来源这里，下面同理</p><h2 id="ModuleCollection">ModuleCollection</h2><p>这里感觉很有意思，因为我这是第一次关注vuex的代码，我也不清楚命名空间等这些东西是什么时候加进去的，但我猜测应该是vue2.5之后的内容因为之前没在文档里见过这些东西。</p><p>字面意思，模块收集器。由于现在复杂度的关系，这部分应该先处理一下。把从vue的vuex得到的options，直接传入这个类，然后再进入<code>register</code>方法，接下来的工作就是不断的尾递归（？）得到整棵树。因为现在还有命名空间什么的，所以还有关于命名空间的判断和结合。</p><p>然后还有一些其他方法，比如热更什么的。</p><h2 id="installModule">installModule</h2><p>使用到的位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">installModule(this, state, [], this._modules.root)</code></pre><p>Store开始初始化的其中第一个方法。</p><p>这个方法，字面含义就是安装模块，猜测应该是把store相关的东西先配置下来。</p><p>这里有一个点（函数太长了不浪费篇幅了）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const isRoot &#x3D; !path.length</code></pre><p>判断是否是根是通过<code>path</code>的长度来做的，如果没长度就是<code>/</code>了，很有意思，对于还没什么经验的我受益匪浅。</p><p>这个函数，需要5个参数，<code>store</code>, <code>rootState</code>, <code>path</code>, <code>module</code>, <code>hot</code>。最后一个应该也跟更新有关系吧？</p><p><code>this</code>在<code>class</code>中，所以指向是<code>class Store</code>的；<code>state</code>是<code>const state = this._modules.root.state</code>得到，而<code>_modules</code>就上面提到的定义了；因为还在根所以没有<code>path</code>，最后传入刚刚各种尾递归得到的树。</p><p>接下来注册命名空间，也就是判断这次的store有没有用到命名空间，有就分成一张张网，摊开处理。</p><p>接下来会遇到一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function getNestedState (state, path) &#123;  return path.length    ? path.reduce((state, key) &#x3D;&gt; state[key], state)    : state&#125; &#x2F;&#x2F; 如果不是根的话会被分配到这里，看需不需要拼凑state，就“三光属性”</code></pre><p>非根注册应该是文档的<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh-cn/modules.html">这里</a>吧，这里提到了模块可以只是局部注册，我们一般都直接在<code>main.js</code>完事儿了。</p><p>然后就是三种操作的模块遍历注册，用到的方法存在<code>module.js</code>，实则还是用到了<code>util.js</code>的遍历方法（通过回调函数返回回去，再次赞叹）</p><p>而注册的方法<code>registerMutation</code> &amp;&amp; <code>registerAction</code> &amp;&amp; <code>registerGetter</code> 就是我们用到的那些例如<code>store.commit(type, payload)</code>的方法。</p><p>然<code>registerAction</code>的方法比其他的复杂得多，它要求<code>handler</code>传入<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code>等。显然他命中注定要干一些“脏乱差”的工作。由此也可以得到为什么<code>actions</code>的方法，第一个参数(type)可以传入<code>&#123;dispatch, commit, state&#125;</code>…的东西了。</p><p>题外话：之前在某个论坛看到一个问题，问在vuex中的actions为什么可以取到state，不会造成什么乱七八糟的问题么？我也不知道，问题的答案先留着。不过因为可以得到state，所以我们可以通过现有的state来判断或者操作，这不是更方便了么？</p><h2 id="resetStoreVM">resetStoreVM</h2><p>当一切都准备好了之后，怼进实例。</p><p>实际上前面也有提到，vuex是被vue当做专属插件进行安装的，在Vue实例环境中就可以通过<code>this.$store</code>摸到vuex。然后vuex就可以通过数据的改变来重新得到新的组件或者新的去促进生成得到新的dom。然后在上一篇有讲到那一堆辅助函数，实际上就是控制或者约束操作，但实质就是<code>Vue.$store.dispatch</code>等等等。</p><p>先是从store拿到vm作为旧的vm以作备份（当然如果不存在就不存在备份了），然后让<code>Vue</code>把这段操作定义为静默操作。</p><p>接着生成通过<code>new Vue</code>生成新的vm（假如有旧的也备份了，不会影响），恢复取消静默操作。（意思就是偷偷替换了vm）</p><p>至此新的视图已经更新完成，没有出意外的话，存在的刚刚备份过的旧vm就可以干掉的，执行销毁</p><h2 id="withCommit">_withCommit()</h2><p>通篇是没有提到这个函数的，到这里提一下是因为，至此这个函数用了两次，最后一次是发生在刚刚<code>resetStoreVM</code>的最后，如果存在热更的情况下那里。篇幅不长，拿出来看一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_withCommit (fn) &#123;  const committing &#x3D; this._committing  this._committing &#x3D; true  fn()  this._committing &#x3D; committing&#125;</code></pre><p>毕竟状态管理，如果谁都能理这个状态，还需要管理干什么。这里的理解可以套入<code>reducer</code>协助理解，<code>state</code>有且仅有<code>reducer</code>可以修改，而vuex的<code>mutations</code>也就是做这份工作的地方。然后<code>_withCommit</code>的话，是个代理来的。</p><p>还是刚刚备份旧vm那个样子，先备份当前状态，然后把该状态转为<code>true</code>，据说是如果不暂时改变状态，严格<code>vuex</code>会认为这是非法操作，是禁止的。</p><p>封印解除之后，执行一下回调（各种需要破例更新的数据），然后再固着。</p><p>为什么这里需要备份状态换回去，而且这里是<code>boolean</code>，非黑即白的。实际上如果这个所谓的开关，在执行这里之前就是关闭的，那道理通过。如果在这之前，开关本来开着，这样你执行一次这里，就又把开关关回去的话，会影响到其他地方的正常工作，这不是一个“合格的秘书”。</p><p>刚刚最后那里的操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">store._withCommit(() &#x3D;&gt; &#123;  oldVm._data.$$state &#x3D; null&#125;)</code></pre><p>就是假如这里是<code>hot</code>的话，就把旧vm的状态改成<code>null</code>，然后跟这个vm有关的watcher和计算都会被强行触发更新。通过这样让页面不刷新然后刷新dom。</p><p>最后一个问题：为什么明明<code>this</code>指向的是本体(Store)，初始化的时候需要<code>const store = this</code></p><p>回答：JavaScript那么牛逼的<code>this</code>，墙头草属性的，不找个需要固定的位置固定下来肯定会有机会被带偏的。</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex源码理解（一）</title>
      <link href="/blog/2018/01/25/vuex-study-1/"/>
      <url>/blog/2018/01/25/vuex-study-1/</url>
      
        <content type="html"><![CDATA[<p>看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）</p><p>vuex和dva的源码都想看，不然没办法知道相性在哪。</p><h2 id="由口而入">由口而入</h2><p>这都暴露干净了…</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  Store,  install,  version: &#39;__VERSION__&#39;,  mapState,  mapMutations,  mapGetters,  mapActions,  createNamespacedHelpers&#125;</code></pre><p><code>install</code>肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！</p><p>这次就先读暴露出来的四个方法吧</p><span id="more"></span><h2 id="辅助函数">辅助函数</h2><h2 id="normalizeNamespace">normalizeNamespace</h2><p>这个东西可能要先讲，因为你看到<code>mapState</code>的第一眼你就会看到他，虽然不重要。</p><p>这应该是一个初始化或者标准化命名空间的方法，之前&quot;尝试用dva的理解对处理数据&quot;有遇到使用命名空间的情况。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#39;spacename&#39;, &#123;    count: state &#x3D;&gt; state.count  &#125;)&#125;</code></pre><p>看一下实现方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function normalizeNamespace (fn) &#123;  return (namespace, map) &#x3D;&gt; &#123;    if (typeof namespace !&#x3D;&#x3D; &#39;string&#39;) &#123;      map &#x3D; namespace      namespace &#x3D; &#39;&#39;    &#125; else if (namespace.charAt(namespace.length - 1) !&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;      namespace +&#x3D; &#39;&#x2F;&#39;    &#125;    return fn(namespace, map)  &#125;&#125;</code></pre><p>映入眼帘就是一个柯里了，大致意思就是命名空间需要处理，如果进来的函数第一个不是空间名称那么肯定直接是对象了，因为我们也不是必须使用命名空间，比如最普通的这样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#123;    count: state &#x3D;&gt; state.count  &#125;)&#125;</code></pre><p>如果有命名空间的话，就根据层数用<code>/</code>分开，比如<code>app/save</code></p><h2 id="normalizeMap">normalizeMap</h2><p>对不起还是不能讲到<code>mapState</code>，毕竟通用的函数理解完了之后，游戏也就结束了。（要不怎么说是辅助函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * Normalize the map * normalizeMap([1, 2, 3]) &#x3D;&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ] * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) &#x3D;&gt; [ &#123; key: &#39;a&#39;, val: 1 &#125;, &#123; key: &#39;b&#39;, val: 2 &#125;, &#123; key: &#39;c&#39;, val: 3 &#125; ] * @param &#123;Array|Object&#125; map * @return &#123;Object&#125; *&#x2F;function normalizeMap (map) &#123;  return Array.isArray(map)    ? map.map(key &#x3D;&gt; (&#123; key, val: key &#125;))    : Object.keys(map).map(key &#x3D;&gt; (&#123; key, val: map[key] &#125;))&#125;</code></pre><p>注释都直接告诉你了！对的实际上组件对<code>vuex</code>的访问可以有两种，对象或者数组。对象的情况上面已经有了，还有一种数组。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#39;spacename&#39;, [    &#39;count&#39;  ])&#125;</code></pre><p>这种是，如果组件的参数跟vuex设定一样，那么就直接传入数组匹配，相当于<code>this.count</code>指向<code>this.$store.state.count</code></p><h2 id="mapState-mapMutations-mapGetters-mapActions">mapState, mapMutations, mapGetters, mapActions</h2><p>剩下的就真的是“拼装术”的事情了，通过暴露出去的辅助函数所接收到的数据进行转换并连接<code>vuex</code>。</p><p>相当于<code>redux</code>本身只提供了状态管理，便捷操作需要接触各类型插件。而<code>vuex</code>作为<code>vue</code>专属状态管理，已经提供了最适合<code>vue</code>的操作。</p><h2 id="问题-2">问题</h2><p>由于辅助函数做的工作就是提供在组件中对<code>vuex</code>连接操作的工作，而函数中的转换结果都会是<code>this.$store</code>。在注入<code>vue</code>的环境中，<code>this</code>不出意外的话是指向<code>vue</code>原型上的，这也就意味着，<code>vuex</code>实际上也是作为插件附着在<code>vue</code>原型中。</p><p>不过关于这一点，在一开始就有提到，<code>vuex</code>是通过暴露自己的安装函数让<code>vue</code>可以直接<code>use()</code>。而且我们在<code>main.js</code>绑定时也默认使用<code>store</code>这个key。</p><p>这样的话，只要是能访问到<code>vue</code>的地方就可以访问到<code>$store</code>了，包括组件。**从而可以做到不需要什么辅助函数也不需要<code>actions</code>直接对状态管理动手动脚。**这不仅是react的使用者感觉到的诧异或者反感了吧。</p><p>不过团队是知道这种情况的存在的，所以他们是<strong>推荐在组件中使用辅助函数，请不要直接操作</strong>。</p><p>（不过这个注释最多也就说说而已，懂道理的人都会这么做；不懂道理的，只存留“我只要解决问题就行了”的某些人是不会这么做的。）</p>]]></content>
      
      
      <categories>
          
          <category> 源码阅读 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过dva得到的思考 —— “滥用”VUEX</title>
      <link href="/blog/2018/01/22/vuex-dva/"/>
      <url>/blog/2018/01/22/vuex-dva/</url>
      
        <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p><p>直接上正题吧不磨磨唧唧的了！</p><h2 id="dva是什么">dva是什么</h2><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p><p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p><span id="more"></span><p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p><h2 id="从dva得到了启示">从dva得到了启示</h2><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p><p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p><p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p><h2 id="对启示更清晰的思考">对启示更清晰的思考</h2><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p><p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p><p>那么为什么说vuex有先天优势？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; dva modelexport default &#123;  namespace: &quot;users&quot;,  state: &#123;&#125;,  reducers: &#123;&#125;,  effects: &#123;&#125;,  subscriptions: &#123;&#125;&#125;&#x2F;&#x2F; vuexexport default new Vuex.Store(&#123;  modules: &#123;    users: &#123;      namespaced: true,      state: &#123;&#125;,      mutations: &#123;&#125;,      actions: &#123;&#125;    &#125;  &#125;&#125;)</code></pre><p>如果你要无限逼近dva是什么感觉？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; users.jsexport default &#123;  namespaced: true,  state: &#123;&#125;,  mutations: &#123;&#125;,  actions: &#123;&#125;&#125;&#x2F;&#x2F;store.jsexport default new Vuex.Store(&#123;  modules: &#123;    users  &#125;&#125;)</code></pre><p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p><pre class="line-numbers language-none"><code class="language-none">state &lt;&#x3D;&gt; statemutation &lt;&#x3D;&gt; reduceraction &lt;&#x3D;&gt; effect_ &lt;&#x3D;&gt; subscription</code></pre><p>对没错，订阅怎么办？</p><p>在dva的例子中，看一下示例的订阅是做了什么工作？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">subscriptions: &#123;  setup(&#123; dispatch, history &#125;) &#123;    return history.listen((&#123; pathname, query &#125;) &#x3D;&gt; &#123;      if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;        dispatch(&#123; type: &#39;fetch&#39;, payload: query &#125;)      &#125;    &#125;)  &#125;,&#125;</code></pre><p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p><h2 id="针对vue的操作">针对vue的操作</h2><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>跟vuex的定义是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p><p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p><p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p><p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p><p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  functional: true， &#x2F;&#x2F; 你只不过是通过这个开关来切换组件状态  methods: &#123;    ...mapActions(&#39;spacename&#39;, &#123;      add: &#39;create&#39;    &#125;)  &#125;  render() &#123;    return &lt;h1&gt;&#123;props.msg&#125;&lt;&#x2F;h1&gt;  &#125;&#125;</code></pre><p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p><p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
            <tag> dva </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer —— 替换空格</title>
      <link href="/blog/2018/01/04/replace-space/"/>
      <url>/blog/2018/01/04/replace-space/</url>
      
        <content type="html"><![CDATA[<p>以后博客专职曲苑杂坛算了…</p><p>刚刚看到一题</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>我想这什么腿？然后什么都没想，直接就</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">return str.replace(&#x2F;\ &#x2F;g, &#39;%20&#39;)</code></pre><p>然后过了……虽然100多毫秒</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的monad记录</title>
      <link href="/blog/2017/12/27/funny-monad/"/>
      <url>/blog/2017/12/27/funny-monad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看到monad我的第一反应竟然是莫纳德…</p></blockquote><p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p><p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p><p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p><p>后来偶然找到一篇文章：<a target="_blank" rel="noopener" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures - adit.io</a></p><p>当然有中文版：<a target="_blank" rel="noopener" href="http://jiyinyiyong.github.io/monads-in-pictures/">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/monad.html">图解 Monad - 阮一峰的网络日志</a></p><p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p><p>关于理解的话，挖个坑以后总结~</p><p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript链式方法</title>
      <link href="/blog/2017/12/23/js-method-chaining/"/>
      <url>/blog/2017/12/23/js-method-chaining/</url>
      
        <content type="html"><![CDATA[<blockquote><p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p></blockquote><p>之前在知乎回答过一个问题：2018的前端应该学什么。</p><p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p><p>这答案怎么样呢？废话！肯定没人点赞了！</p><p>人性就是如此！一旦接受了更<s>装逼</s>新的思路，就会觉得以前见过的东西都太弱了！</p><p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p><p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p><span id="more"></span><h2 id="怎么来的链式操作">怎么来的链式操作</h2><blockquote><p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p></blockquote><p>鲁迅：我不是！我没有！别乱说啊！</p><p>我记得有人测试过，<code>$('#ele')</code>会比<code>document.getElementById('ele')</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p><p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p><p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p><h2 id="我用过的JavaScript">我用过的JavaScript</h2><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p><p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function test() &#123;  console.log(&#39;Hello World&#39;);  return this&#125;</code></pre><p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p><h2 id="简单链式操作">简单链式操作</h2><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 雷军（人为对象，构造成立）var LeiJun &#x3D; &#123;  hello: function() &#123;    console.log(&#39;hello, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;,  thank: function() &#123;    console.log(&#39;thank you, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;,  thanks: function() &#123;    console.log(&#39;thank you very much, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;&#125;&#x2F;&#x2F; 驱使对象雷军唱出《Are you ok》前三句leijun  .hello()  .thank()  .thanks()</code></pre><p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p><h2 id="为什么用链式操作">为什么用链式操作</h2><blockquote><p>新手村的Monad？</p></blockquote><p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p><p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p><p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p><p>链式操作相对于柯里化来说，起码它做到了：</p><ul><li>可阅读</li><li>少占用</li><li>减少代码重复性（都有）</li><li>代码简洁（都有）</li></ul><p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">leijun()()()</code></pre><p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p><p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p><p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p><h2 id="不止JavaScript能用">不止JavaScript能用</h2><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p><p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p><p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p><p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序的骚思路</title>
      <link href="/blog/2017/12/20/exchange-number/"/>
      <url>/blog/2017/12/20/exchange-number/</url>
      
        <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p><blockquote><p>如何把两个数值进行交换？</p></blockquote><p>教科书式的编程怎么做？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i &#x3D; 1;int j &#x3D; 2;int k &#x3D; i;i &#x3D; j;j &#x3D; k;&#x2F;&#x2F; 两个数值，把其中一个寄存起来，然后再两次赋值。</code></pre><p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p><p>我：什么跟什么交换？</p><p>师兄：随便你。</p><p>于是我打开了<code>sublime text</code>写下这么些东西</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var i &#x3D; 1;var j &#x3D; 2;i +&#x3D; j;j &#x3D; i - j;i -&#x3D; j;</code></pre><p>然后师兄就懵了，你这个B不按套路出牌？</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JSX的VUE应用开发体验</title>
      <link href="/blog/2017/12/11/vue-jsx/"/>
      <url>/blog/2017/12/11/vue-jsx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p></blockquote><p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p><span id="more"></span><h2 id="开局搭环境">开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p><h2 id="装插件">装插件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install\  babel-plugin-syntax-jsx\  babel-plugin-transform-vue-jsx\  babel-helper-vue-jsx-merge-props\  babel-preset-env\  --save-dev</code></pre><p><code>.babelrc</code>主要是这个</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]&#125;</code></pre><p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p><h2 id="正文">正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p><h2 id="渲染元素">渲染元素</h2><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p><ol><li>它并不是哪个位置的方法都会有createElement函数的。</li><li>classes形式的组件找不到render函数！</li></ol><p>其实关于vue与jsx，tsx我是做了很多次尝试</p><p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  render(&#x2F;* h &#x2F; createElement *&#x2F;) &#123;    return &lt;h1&gt; Hello World &lt;&#x2F;h1&gt;  &#125;&#125;</code></pre><p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p><p>优点：</p><ol><li>顺手，完全单文件中的<code>script</code>标签</li><li>没了</li></ol><p>缺点：</p><ol><li>这么搞肯定容易眼花啊！</li><li>不好维护，不直观</li></ol><p>第二种，如果是这种结构的tsx的话，与jsx同理。</p><p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;  @Component  export default class MainClass extends Vue &#123;  &#125;&lt;&#x2F;script&gt;</code></pre><p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p><p>好了关键的来了…</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">@Componentexport default class MainClass extends Vue &#123;  get render() &#123;    return &lt;h1&gt; Hello World &lt;&#x2F;h1&gt;  &#125;&#125;&#x2F;&#x2F; render or template not defind.</code></pre><p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p><p>官方在自动注入这方面有一个栗子的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue.component(&#39;jsx-example&#39;, &#123;  render () &#123; &#x2F;&#x2F; h will be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;,  myMethod: function () &#123; &#x2F;&#x2F; h will not be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;,  someOtherMethod: () &#x3D;&gt; &#123; &#x2F;&#x2F; h will not be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;&#125;)@Componentclass App extends Vue &#123;  get computed () &#123; &#x2F;&#x2F; h will be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;&#125;</code></pre><p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p><p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p><p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function example(h, args) &#123;&#125;</code></pre><p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p><h2 id="函数式组件">函数式组件</h2><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  functional: true,  render() &#123;&#125;&#125;</code></pre><p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p><p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p><p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p><blockquote><ul><li><code>props</code>：提供 props 的对象</li><li><code>children</code>: VNode 子节点的数组</li><li><code>slots</code>: slots 对象</li><li><code>data</code>：传递给组件的 data 对象</li><li><code>parent</code>：对父组件的引用</li><li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li><li><code>injections</code>: (2.3.0+) 如果使用了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#provide-inject"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li></ul></blockquote><h2 id="JSX的一些小区别">JSX的一些小区别</h2><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p><p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p><p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p><p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扯扯柯里化</title>
      <link href="/blog/2017/12/07/about-currying/"/>
      <url>/blog/2017/12/07/about-currying/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p></blockquote><p>开个玩笑，我自己也不知道这算不算柯里化（逃</p><p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p><p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const menuItem &#x3D; (list) &#x3D;&gt;      list.map((&#123;title, color, icon, descs&#125;) &#x3D;&gt;        &lt;menu-item title&#x3D;&#123;title&#125; color&#x3D;&#123;color&#125; icon&#x3D;&#123;icon&#125;&gt;&#123;          descs.map(v &#x3D;&gt; &lt;span&gt;&#123;v&#125;&lt;&#x2F;span&gt;)&#125;&lt;&#x2F;menu-item&gt;)</code></pre><span id="more"></span><h2 id="柯里化是什么？">柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p><p>在这里有一个<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tools.scroll &#x3D; function (win) &#123;  return function(fn) &#123;    $(win).scroll(function() &#123;      var sct &#x3D; $(win).scrollTop();      fn &amp;&amp; fn(sct);    &#125;);  &#125;;&#125;;&#x2F;&#x2F; 实际上如果不作的话，这样就结束了tools.scroll &#x3D; function(win, fn) &#123;  return $(win).scroll(function() &#123;    var sct &#x3D; $(win).scrollTop();    fn&amp;&amp;fn(sct)  &#125;)&#125;</code></pre><p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var scrollTop &#x3D; Nlvi.tools.scroll(window);scrollTop(function(sct) &#123;&#125;);</code></pre><p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p><p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p><p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p><p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p><p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p><p>第三点就是延时</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var total &#x3D; 0&#x2F;&#x2F; normalvar nSum &#x3D; (num) &#x3D;&gt; &#123;  total +&#x3D; num&#125;&#x2F;&#x2F;curryingvar cSum &#x3D; (fn) &#x3D;&gt; &#123;  var nums &#x3D; []  return function() &#123;    if (!arguments.length) &#123;      return fn.apply(null, nums)    &#125;    Array.prototype.push.apply(nums, arguments)    return this  &#125;&#125;var sum &#x3D; cSum((x) &#x3D;&gt; total +&#x3D; x)</code></pre><p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p><h2 id="柯里化误区">柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/pengchen/p/5434705.html">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 拿下来继续学习一下var scrollTop &#x3D; Nlvi.tools.scroll(window);scrollTop(function(sct) &#123;&#125;);</code></pre><p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tools.scroll &#x3D; function(win, fn) &#123;  return $(win).scroll(function() &#123;    var sct &#x3D; $(win).scrollTop();    fn&amp;&amp;fn(sct)  &#125;)&#125;&#x2F;&#x2F; and sotools.scroll(window, function() &#123;&#125;)</code></pre><p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p><p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p><h2 id="柯里化-闭包函数？">柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 经典面试题for(var i&#x3D;0;i&lt;2;i++)&#123;      (function(i)&#123;             setTimeout(function()&#123;              console.log(i);        &#125;,0)    &#125;)(i);&#125;</code></pre><p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p><p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我还在用Console.log()？</title>
      <link href="/blog/2017/11/20/js-console/"/>
      <url>/blog/2017/11/20/js-console/</url>
      
        <content type="html"><![CDATA[<blockquote><p>也许主题应该改为：你只会使用Console.log()？</p></blockquote><p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p><p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。</p><span id="more"></span><h2 id="log-info-error-warn">log(), info(), error(), warn()</h2><p>这几个放在一起讲</p><blockquote><p>log() 普通输出</p></blockquote><p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p><blockquote><p>info() 提醒输出</p></blockquote><p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p><blockquote><p>error() 错误输出</p></blockquote><p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p><blockquote><p>warn() 警告输出</p></blockquote><p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p><blockquote><p>debug() 调试输出</p></blockquote><p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p><h2 id="exception-debug">_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p><blockquote><p>_exception() 例外输出</p></blockquote><p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p><blockquote><p>debug() 调试输出</p></blockquote><p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p><h2 id="assert-…-clear-count">assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p><blockquote><p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p></blockquote><p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.assert(1&gt;2, &quot;你这么骚的？&quot;)Assertion failed: 你这么骚的？ &#x2F;&#x2F; 假装这里是红字红色背景</code></pre><blockquote><p>clear() 清空控制台</p></blockquote><p>就是把控制台全清空，terminal里面的<code>clear</code></p><blockquote><p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p></blockquote><p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p><h2 id="dir-dirxml">dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p><blockquote><p>dir() 对象结构输出</p></blockquote><blockquote><p>dirxml() 节点结构输出</p></blockquote><p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p><h2 id="group-groupCollapsed-groupEnd">group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p><p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p><p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p><h2 id="table-…">table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p><blockquote><p>table() 表格输出</p></blockquote><p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p><p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p><h2 id="另外的技巧就是可以用占位符了">另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(&quot;%d年%d月%d日&quot;,2017,11,20)</code></pre><p>最后感谢MDN，也感谢AlphaGo！</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用等于指针吗？</title>
      <link href="/blog/2017/10/17/reference-equal-pointer/"/>
      <url>/blog/2017/10/17/reference-equal-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p></blockquote><p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p><p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p><p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p><p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）</p><span id="more"></span><h2 id="Reference-Pointer">Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p><p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = &#123;&#125;;  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p><p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d">JavaScript 的<em>指针</em>是什么? - 知乎</a></p><blockquote><p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/sansmana">陈木野</a></p></blockquote><p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p><p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p><blockquote><p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p></blockquote><p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p><h2 id="Point-Reference">Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p><p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p><p>Java，他也有reference，但是在<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p><blockquote><p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p></blockquote><p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p><p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p><p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p><p>可是在JS中，引用也不能修改和做任何运算吗？</p><h2 id="Reference-Pointer-2">Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p><p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p><p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p><p>不过现在可以知道的是：</p><p>​在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p><p>​在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p><p>那我现在可不可以有一种新的理解：</p><p>​比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p><p>​而JS语言这种，我想用一个代码框来写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 还是根据红宝书的例子var a &#x3D; 5;var b &#x3D; a;&#x2F;&#x2F; 一种复制，相互独立var x &#x3D; &#123;a: 5&#125;var y &#x3D; x&#x2F;&#x2F; 一种引用，实际上操作y的时候还是在操作x&#x2F;&#x2F;现在暂时借用一下以 _ 代替*var o &#x3D; &#123; a: 5 &#125;var _b &#x3D; o.a&#x2F;&#x2F; 达到继承的目的？&#x2F;&#x2F; var _b &#x3D; int *b   在某种意义上？</code></pre><p>在红宝书接下来有一句：</p><blockquote><p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p></blockquote><p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p><p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p><p>哼，计算机真是有趣。</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用桌面应用写hexo博客是什么体验？</title>
      <link href="/blog/2017/09/19/what-the-feeling-about-hyper/"/>
      <url>/blog/2017/09/19/what-the-feeling-about-hyper/</url>
      
        <content type="html"><![CDATA[<blockquote><p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer.</p></blockquote><p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p><p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a target="_blank" rel="noopener" href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p><p>但是现在，可能生活会更好了…</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p><span id="more"></span><h2 id="为什么？">为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p><p>为什么想起写这个，原因就两点</p><ul><li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li><li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li></ul><p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p><p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p><p>这次实现这个东西的时候，巧了，跟<a target="_blank" rel="noopener" href="http://www.ahonn.me">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p><p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p><p>Ahonn的项目地址是这个：<a target="_blank" rel="noopener" href="https://github.com/ahonn/hexdit">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p><h2 id="怎么用？">怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <s>装逼</s> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p><p>确实，这才像在写博客。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p><p>我甚至都不怕被你看！</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p><p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p><p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p><p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_'的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p><p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p><p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为**“选择当前文章是否隐藏”**的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p><p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p><h2 id="另外还给对hexo不熟悉的写手准备了一个大功能。">另外还给对hexo不熟悉的写手准备了一个大功能。</h2><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p><p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p><p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p><p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a target="_blank" rel="noopener" href="https://github.com/ColMugX/hexo-theme-Nlvi">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p><p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p><p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p><p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p><p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p><h2 id="是什么？">是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p><p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>]]></content>
      
      
      <categories>
          
          <category> 曲苑杂坛 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞electron + vue + webpack2 + TypeScript什么体验</title>
      <link href="/blog/2017/08/22/do-markdown-hexo/"/>
      <url>/blog/2017/08/22/do-markdown-hexo/</url>
      
        <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p><p><a target="_blank" rel="noopener" href="https://github.com/ColMugX/vue-ts-electron-starter">vue-ts-electron-starter</a></p><p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p><p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p><p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p><p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。</p><span id="more"></span><h2 id="讲在前面">讲在前面</h2><p>在这之前我用的是<a target="_blank" rel="noopener" href="https://github.com/CodeFalling/blog-admin">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p><p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p><p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p><p>所以这次打算的技术选型是：</p><ul><li>TypeScript</li><li>electron</li><li>vue</li><li>vuex</li></ul><p>electron + vue环境的话，直接使用<a target="_blank" rel="noopener" href="https://github.com/SimulatedGREG/electron-vue">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p><h2 id="为什么使用TypeScript">为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p><p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p><p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p><p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p><p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p><p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p><h2 id="干！填坑！">干！填坑！</h2><p>两点核心</p><ul><li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li><li>从入口到组件都使用<code>TypeScript</code></li></ul><p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p><p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm i -S typescript ts-loader vue-class-component# ornpm i -S ts-loader vue-class-componentnpm link typescript</code></pre><p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;test: &#x2F;\.ts$&#x2F;,loader: &#39;ts-loader&#39;,exclude: &#x2F;node_modules|vue\&#x2F;src&#x2F;, options: &#123;appendTsSuffixTo: [&#x2F;\.vue$&#x2F;]&#125;&#125;</code></pre><p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm i -S tslint tslint-loader</code></pre><p>老位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;test: &#x2F;\.(ts)$&#x2F;,enforce: &#39;pre&#39;,exclude: &#x2F;node_modules&#x2F;,use: &#123;loader: &#39;tslint-loader&#39;&#125;&#125;</code></pre><p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p><p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tsc --init#通过tsc初始化得到</code></pre><p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p><p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p><h2 id="开始填坑">开始填坑</h2><ul><li>入口必须是<code>.ts</code></li></ul><p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">Module build failed: Error: Could not find file: &#39;...*.ts&#39;# 或者Module build failed: Error: Could not find file: &#39;...*.vue&#39;</code></pre><p>所以必须是TS入口</p><ul><li>建议关于<code>script</code>部分分开写。</li></ul><p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p><ul><li><code>vue-class-component</code>核心</li></ul><p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">@Component(&#123;  name: &#39;landing-page&#39;,  components: &#123;    SystemInformation  &#125;&#125;)export default class LandingPage extends Vue &#123;  open (link) &#123;    (this as any).$electron.shell.openExternal(link)  &#125;&#125;</code></pre><p>漂亮，清晰。（当然复杂一点，就复杂了！）</p><ul><li>关于对Vue进行扩展</li></ul><p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> electron </tag>
            
            <tag> editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的call，bind，apply</title>
      <link href="/blog/2017/08/14/js-call-apply-bind/"/>
      <url>/blog/2017/08/14/js-call-apply-bind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p></blockquote><p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p><p>还是上次的代码，修改一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let test &#x3D; obj.getNametest()&#x2F;&#x2F;undefined.</code></pre><p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;obj.getName()&#x2F;&#x2F;koala</code></pre><span id="more"></span><p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p><h2 id="call">call()</h2><blockquote><p><strong>call</strong></p><ul><li>vi. 呼叫；拜访；叫牌</li><li>vt. 呼叫；称呼；召集</li><li>n. 电话；呼叫；要求；访问</li><li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li></ul></blockquote><p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let cal &#x3D; obj.getName&#x2F;&#x2F;先定义出来cal.call(obj)&#x2F;&#x2F;koala   （指向还给他，不动其他把它叫出来</code></pre><h2 id="apply">apply()</h2><blockquote><p><strong>apply</strong></p><ul><li>v.应用；使用；涂；敷</li><li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li></ul></blockquote><p>再来一手必应翻译简直就是，不谈了！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let apy &#x3D; obj.getName&#x2F;&#x2F;这手还是不变apy.apply(obj)&#x2F;&#x2F;koala  （可以说不是指向还给他，这不是假装了，而是直接套用</code></pre><p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-%E5%92%8C-apply-%E5%8C%BA%E5%88%AB">下面再讲</a></p><h2 id="bind">bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p><blockquote><p><strong>bind</strong></p><p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p></blockquote><p><s>顺便，请以上三家公司尽快给我打钱，谢谢合作。</s></p><p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let bid &#x3D; obj.getName&#x2F;&#x2F; [Function: getName]          (这手还是不变&#x2F;&#x2F; 接着这样做，把this指向回去，变成一个可以自由操作的变量bid &#x3D; bid.bind(obj)&#x2F;&#x2F; [Function: bound getName]bid()&#x2F;&#x2F; koala   （这样才会运行，因为刚刚只是抢过来了</code></pre><h2 id="call-和-apply-区别">call()和#apply()区别</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let cal &#x3D; obj.getNamecal.call(obj)&#x2F;&#x2F;koalalet apy &#x3D; obj.getNameapy.apply(obj)&#x2F;&#x2F;koala</code></pre><p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName(param1, param2) &#123;    return this.name + &#39; params: &#39; + param1 + param2    &#125;&#125;let cal &#x3D; obj.getNamecal.call(obj, 1, 2)&#x2F;&#x2F;koala params: 12</code></pre><p>那么<code>apply()</code>就有区别了？哎！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let apy &#x3D; obj.getName&#x2F;&#x2F;这手还是不变apy.apply(obj, [1, 2])&#x2F;&#x2F;koala params: 12</code></pre><p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p><p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p><p><strong>下一篇，讲Javascript的柯基化！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JavaScript的this</title>
      <link href="/blog/2017/03/03/js-this/"/>
      <url>/blog/2017/03/03/js-this/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一次被this支配之后的思考</p></blockquote><h2 id="开门见山">开门见山</h2><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        return function() &#123;            return this.name        &#125;    &#125;&#125;console.log(obj.getName()())    &#x2F;&#x2F;undefined.</code></pre><p>题目这样，我第一次回答的是<code>koala</code>。现在想了一下，估计是满脑子想吃波星冰乐给冲昏了脑子。<br>如果我改下！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        let that &#x3D; this    &#x2F;&#x2F;this -&gt; that        let name &#x3D; &#39;koala&#39;        return function() &#123;            return that.name &#x2F;&#x2F;this -&gt; that        &#125;    &#125;&#125;console.log(obj.getName()()) &#x2F;&#x2F;koala&#x2F;&#x2F; 或者第二种，利用ES6let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        let name &#x3D; &#39;koala&#39;        return () &#x3D;&gt; &#123;            return this.name        &#125;    &#125;&#125;console.log(obj.getName()()) &#x2F;&#x2F;koala</code></pre><h2 id="解题想法">解题想法</h2><p>我的理解，<code>this</code>其实跟其他语言的<code>self</code>应该是差不多。就是指代自己，比如说在一个<code>function</code>里面，那么<code>this</code>指向的就是这个func。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function colmugx() &#123;    &#x2F;&#x2F;do something.&#125;</code></pre><p>可能我讲的不清楚，就是<strong>this其实就是括号里的东西。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function colmugx(&#x2F;** this *&#x2F;) &#123;    &#x2F;&#x2F;do somethings&#125;</code></pre><p>当然这是我的理解，我觉得应该就是这样的，所以刚刚那样取到的this并不是this。</p><h2 id="浅谈this">浅谈this</h2><p>只讲两种我懂的东西。</p><h3 id="跟着new走">跟着new走</h3><p>就是用new来创建对象的话，那么<code>this</code>就会跟着这个new</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;    constructor(name) &#123;        this.name &#x3D; name;    &#125;    func() &#123;        return this    &#125;&#125;let a &#x3D; new Animal(&#39;koala&#39;)console.log(a.name) &#x2F;&#x2F;koala</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;    constructor(name) &#123;        this.name &#x3D; name;    &#125;    func() &#123;        return this    &#125;&#125;let a &#x3D; new Animal(&#39;koala&#39;)console.log(a.func()) &#x2F;&#x2F;Animal &#123; name: &#39;koala&#39; &#125;</code></pre><h3 id="ES6中括号函数的this">ES6中括号函数的this</h3><p>括号函数的<code>this</code>，不存在的！</p><p>说是不存在，实际上并不是说真的不见了，而是它会绑定到上一层函数中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">func(()&#x3D;&gt; &#123;    &#x2F;&#x2F;do somethings.&#125;&#x2F;** ,this *&#x2F;)</code></pre><p>而如果不是括号的话</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">func(function(&#x2F;** this *&#x2F;)&#123;    &#x2F;&#x2F;do somethings.&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript所有for</title>
      <link href="/blog/2017/03/02/js-for/"/>
      <url>/blog/2017/03/02/js-for/</url>
      
        <content type="html"><![CDATA[<h2 id="先讲for">先讲for</h2><p>我觉得这应该是最古老而且实用性最强的for了，就是三段式定义。<code>for (;;)</code><br>想到当年考java编程基础的时候（一门学科），有一道手写题要用到循环，我抬手就是<code>for (var ...)</code>…</p><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i;i&lt;len;i++)</code></pre><p>其中不管怎样，常规for必须要两个;，因为就是这样，里面有三段式嘛。第一个是定义自走变量，第二个是条件，第三个是自加或自减。实际上for应该是这样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i;let len;i&lt;len;++i)</code></pre><h2 id="for…in">for…in</h2><p>这个在上次总结对象遍历已经提到了，它好像也就遍历对象用得多一点。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i in sth) &#123;&#125;</code></pre><p>不过<code>for in</code>的话，为什么说遍历对象比较多，其中一个除了好写~~（打死吧这人）~~，还有一点它只能用来遍历有key或者说是个index的东西，比如数组，它只能读到数组的index，那对象的话就直接读到键值咯。而且有一点的是，你读数组，<strong>读出来的index是个string不是number</strong>。这个要记得，因为js这种弱类型的东西，如果索引相加就变成字符串相加了……<strong>（我幼儿园就会20以内加减法了，1加2等于12)</strong></p><h2 id="forEach">forEach</h2><p>这个方法就不是古老的方法了，JS(ES5)版本的时候的，针对数组的一个方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">arr.forEach((i)&#x3D;&gt; &#123;&#125;)</code></pre><p>这种遍历的话，你遍历完直接能把数据处理掉最好，因为如果不是的话就麻烦了…它并不是一个开放的遍历，而是借用的闭包函数做的遍历。可以看成是<code>arr.func()</code>，它是一个数组方法，传进去一个<code>callback</code>，那就厉害了啊，闭包一个特点就是保护变量避免污染啊，变量保护是双向的啊…进得去出不来… （所以我的微信小程序openradio有用到计数器的时候不敢用这个，而且这个方法也是针对数组才能用的）</p><h2 id="for…of">for…of</h2><p>这是ES6的新东西，它比<code>for in</code>遍历的更多，没有<code>for (;;)</code>复杂，对比<code>forEach</code>它是开放的不是闭包，也就是那些条件控制流什么的都可以操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i of arr)</code></pre><p>可是不止，好像还可以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i of &#39;colmu&#39;) &#123;    console.log(i)  &#x2F;&#x2F;&#39;c&#39;\n &#39;o&#39;\n &#39;l&#39;\n &#39;m&#39;\n &#39;u&#39;\n&#125;</code></pre><p>不过它不能遍历对象！不能遍历对象！不能遍历对象！而且错误信息<code>TypeError: str[Symbol.iterator] is not a function</code>。所以这里我不行不BB了。</p><blockquote><p>所有实现了[Symbol.iterator]接口的对象都可以被遍历。</p></blockquote><h2 id="for-in-和-for-of-对比">for in 和 for of 对比</h2><p>一个栗子就能锤到头皮发麻</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let arr &#x3D; [6,6,4,2,8]for (let i in arr) &#123;    console.log(i)  &#x2F;&#x2F; 0,1,2,3,4&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let arr &#x3D; [6,6,4,2,8]for (let i of arr) &#123;    console.log(i)  &#x2F;&#x2F;6,6,4,2,8&#125;</code></pre><h2 id="summary">summary</h2><p>光说区别不行，我要讲怎么用！</p><p><s>万能膏药<code>while</code></s> （不对走错片场…）</p><p>万能膏药<code>for (;;)</code>：这是怎样都能用的，不过就是长了点，但是定义细了多。</p><p>数组专利<code>forEach</code>：数组的方法，只能用在数组。</p><p>能用在数组的：<code>for</code>, <code>forEach</code>, <code>for in </code>, <code>for of</code></p><p>能用在找头的：<code>for in</code></p><p>只要支持[Symbol.iterator]要什么找什么的：<code>for of</code></p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来搞一手关于Javascript对象继承</title>
      <link href="/blog/2017/02/22/js-extends/"/>
      <url>/blog/2017/02/22/js-extends/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小爝（知乎用户）：js里面什么都是对象，所以你看单身狗学这个语言学的老快了。</p></blockquote><p>就前几天看到的答案，觉得对啊！js这种边缘OP的语言，你说它没对象它是可以有的，你说它是面向对象语言它不是。<br>所以来研究一手关于JavaScript的继承。研究过程用一下typescript（这个真有对象了）<span id="more"></span></p><h2 id="先看一下关于typescript的继承">先看一下关于typescript的继承</h2><p>看一下ts的类</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Parent &#123;    name: string    age: number    constructor(msg:string, age:number) &#123;        this.age &#x3D; age        this.name &#x3D; msg;    &#125;    sayHello() &#123;        return console.log(&#96;hello $&#123;this.name&#125;,now is $&#123;this.age&#125;&#96;)    &#125;&#125;</code></pre><p>然后来一手调用，全程感觉像在用<code>java</code></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">let par &#x3D; new Parent(&quot;mike&quot;, 16)par.sayHello()      &#x2F;&#x2F;hello mike,now is 16</code></pre><p><strong>答案我在terminal验证过的没问题！！</strong></p><p>接下来尝试一下如果我走继承会是什么样，来一手继承</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Parent &#123;    name: string    age: number    constructor(msg:string, age:number) &#123;        this.age &#x3D; age        this.name &#x3D; msg;    &#125;    sayHello() &#123;        return console.log(&#96;hello $&#123;this.name&#125;,now is $&#123;this.age&#125;&#96;)    &#125;&#125;&#x2F;&#x2F;Now extends.class Son extends Parent &#123;    constructor(msg, age) &#123;        super(msg, age);    &#125;    sayHello() &#123;        console.log(&#96;hello I&#39;m Son. next is my Parent&#39;s say&#96;)        super.sayHello()    &#125;&#125;</code></pre><p>来手调用验证结果</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">let sapi &#x3D; new Son(&#39;peanut&#39;, 10)sapi.sayHello()  &#x2F;&#x2F;hello I&#39;m Son. next is my Parent&#39;s say\n hello peanut,now is 10</code></pre><h2 id="该研究JavaScript的继承了">该研究JavaScript的继承了</h2><p>先来看一下第一个例子翻译成ES5(JavaScript)是什么样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Parent &#x3D; (function () &#123;    function Parent(msg, age) &#123;        this.age &#x3D; age;        this.name &#x3D; msg;    &#125;    Parent.prototype.sayHello &#x3D; function () &#123;        return console.log(&quot;hello &quot; + this.name + &quot;,now is &quot; + this.age);    &#125;;    return Parent;&#125;());var par &#x3D; new Parent(&quot;mike&quot;, 16);par.sayHello();</code></pre><p>首先是建立了个函数，函数内再嵌套一层函数，然后通过内部的<code>prototype</code>添加一个方法，最后返回整个父函数。<br>燃鹅在这个函数内部已经做了一次叫“原型链继承”的事情了。就是从父级，或者说从其他原型来指向到继承的实例来达到元素一并继承，这样我要实现后面的实例的时候就要连带前面的也一并执行了。</p><p>然后第二个例子，多了个继承</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var __extends &#x3D; (this &amp;&amp; this.__extends) || function (d, b) &#123;    for (var p in b) if (b.hasOwnProperty(p)) d[p] &#x3D; b[p];    function __() &#123; this.constructor &#x3D; d; &#125;    d.prototype &#x3D; b &#x3D;&#x3D;&#x3D; null ? Object.create(b) : (__.prototype &#x3D; b.prototype, new __());&#125;;var Parent &#x3D; (function () &#123;    function Parent(msg, age) &#123;        this.age &#x3D; age;        this.name &#x3D; msg;    &#125;    Parent.prototype.sayHello &#x3D; function () &#123;        return console.log(&quot;hello &quot; + this.name + &quot;,now is &quot; + this.age);    &#125;;    return Parent;&#125;());var Son &#x3D; (function (_super) &#123;    __extends(Son, _super);    function Son(msg, age) &#123;        return _super.call(this, msg, age) || this;    &#125;    Son.prototype.sayHello &#x3D; function () &#123;        console.log(&quot;hello I&#39;m Son. next is my Parent&#39;s say&quot;);        _super.prototype.sayHello.call(this);    &#125;;    return Son;&#125;(Parent));var sapi &#x3D; new Son(&#39;peanut&#39;, 10);sapi.sayHello();</code></pre><p>有点厉害，我先坐下来……</p><p>先是构造了个链子，然后（那个是闭包污染处理嘛…）…… 说不清了……</p><p>反正看子类，很明显在“Son类”结束前，有一个<code>(Parent)</code>，虽说ts对于类的处理都是一个大个的及时运行函数，但是&quot;parent&quot;运行时并没有带参数，而&quot;Son&quot;带了它的爹，如果我的理解的是对的的话，就是&quot;Son&quot;在运行的时候把&quot;Parent&quot;带着运行一次起到“继承”的效果。最后还是照原型链的理解。</p><h2 id="关于JavaScript的其他继承">关于JavaScript的其他继承</h2><p>还是因为我的爬虫小记中的现世界宝可梦数量及其名字的项目中，用到了<code>.call(this)</code>这个函数句。所以在想，是否可以使用构造函数走一波继承？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function a() &#123;    return console.log(&#39;this is a&#39;)&#125;function b() &#123;    a.call(this)&#125;</code></pre><p>然后调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">b()     &#x2F;&#x2F;this is a</code></pre><p>所以也是可以的。结束！</p>]]></content>
      
      
      <categories>
          
          <category> 前端思考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己造轮子！—— Syuanpi.css</title>
      <link href="/blog/2017/02/13/syuanpi-css/"/>
      <url>/blog/2017/02/13/syuanpi-css/</url>
      
        <content type="html"><![CDATA[<p>本来首发知乎，再说了现在这东西又不需要怎么用了，各种前端框架各种自动化，这些东西早就带得干干净净了。<br>这是demo的页面：<a href="https://colmugx.github.io/Syuanpi.css">Syuanpi.css</a><br>这是GitHub的页面：<a target="_blank" rel="noopener" href="https://github.com/ColMugX/Syuanpi.css">ColMugX/Syuanpi.css: ✨A library of CSS animations.</a></p><p>说到CSS动画库，其实有一个很出名很好用，“就像喝水一样简单”的叫做Animate.css的开源库子。那些动画真的挺炫酷的。然后我就想起，我自己在玩Hexo主题的时候不是动画也是自己写么，那要不把用过的动画自己封装起来，然后再加点跟自己脑洞产物的动画，然后自己也做一个库试试？然后我就把Syuanpi.css弄出来了…作为练习产物，日后想到什么好玩的实现方式也是会一直加一直加~ 不过我要说实话：不排除把Animate.css出现的部分动画自己再实现一遍进自己库子！</p><h2 id="为什么要出这东西…">为什么要出这东西…</h2><span id="more"></span><p>在知乎看了一段时间了认识了kpi这东西，觉得这东西好坑啊233，导致我现在觉得kpi的意思就是：有现有轮子不要用！不管怎样自己用的东西能做成轮子就给它做成轮子！然后再用自己的轮子！然后kpi就啪啪啪的往上走！不过这库子我的出发点还是想把我原来弄的一些基础的动画归类起来，加上自己比较会常用的操作封装起来，仅此而已。<br>在知乎学习的过程，就有一个关于没工作经验然后怎么面试的问题。就有提到关于自己开源自己的代码，不是不负责任的像托管作业一样把乱七八糟的东西放上去然后就说“噢！劳资也有开源”这样，至少要有一个给人一种便捷操作，要有头有尾，还要会写文档，不会写给个README也行。然后我也没经验，就听话这么做了…</p><h2 id="它是个什么东西…">它是个什么东西…</h2><p>好了说回来我的东西~ Syuanpi意思很简单，我喜欢它日后可以炫得一批233。但是它并不炫，而是一些很基础很基础的动画用法。不过，一些稍微认真的网站不就要点轻转场就行了嘛。比如我觉得博客挺认真的，但是没有转场动画又觉得好干燥，所以我的大部分动画起始点都是基于在自己博客上面用。而且动画的过程速度和位置全靠目测！不会计算也是硬伤呀…用的是stylus，不知道为什么总觉得那个被那个绿色的长的 ∮ 撩到了，然后就这么用了。<br>认认真真做作业，不要搞什么大新闻。就像标题说的，针对自己脑洞的产物。不过由于是自己第一次比较成型的“自己的作业自己做”，我还是好高兴的。如果有人愿意给star就更好了，还没体验过被5个star砸死是什么感觉呢~（不贪心的好孩子~）<br>嗯！该讲说明书了！<a target="_blank" rel="noopener" href="http://xn--GitHubREADME-bw5s79dg68csxgug160t3mxdzuve649b.md">大份说明书在GitHub的头页README.md</a>，所以就不讲了！</p>]]></content>
      
      
      <categories>
          
          <category> 前端实践 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Syuanpi </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于微信小程序</title>
      <link href="/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/"/>
      <url>/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>向腾讯大佬低头！</p></blockquote><p><strong>说在前面，你们这下可不能说我这博客天天吹水不讲东西了！</strong></p><h2 id="说说这大佬又想干什么！">说说这大佬又想干什么！</h2><p>怎么说，腾讯微信真的是野心挺大的，要把微信做成一个应用平台<br>谁还能想的起来微信当时只是定位为一个低流语音信息的即时通讯工具啊！<br>小程序怎么定义呢，就是一个在微信启动的App<br>不过归根到底还是个Web App<br>那这么说来其实也可以说是一个以微信做壳的App了，相对于隔壁那个叫Ionic的东西来说。<br>不过怎么说，这小程序应该也是依托公众号来实现的吧，我看它文档都是在公众号里面。<br>先上地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214">下载链接</a><br>这开发工具原来就是一个chrome开发者工具，可能是因为加了小程序这么个东西，现在也有开发功能了<br>刚刚试用了一下，效！率！贼！差！（默默打开了Atom）<span id="more"></span></p><h2 id="这东西大概怎么写怎么用">这东西大概怎么写怎么用</h2><p>我粗略看了一下啊，这东西跟隔壁那些什么<code>angular</code>啊，还有<code>vue</code>啊什么都有点差不多，就是前后绑定然后做逻辑。<br>大概结构就是（不会用树形，随便看一下）</p><pre class="line-numbers language-none"><code class="language-none">- &#x2F; - pages     - index         index.js         index.wxml         index.wxss     - logs         logs.js         logs.json         logs.wxml         logs.wxss - utils     util.js app.js app.json app.wxss</code></pre><p><strong>这结果tm似曾相识啊！</strong><br>好了这就是个Web App，那讲一下那些文件干嘛的呗。<br>说到底还是个老biao子，js就不用说了（哎等下这东西好像还是得依托<code>NodeJs</code>啊，顺便说下我特别不喜欢<code>PHP</code>…）</p><p><code>wxml</code>:是个什么，wxml其实就是xml了，只是有点特殊的xml，可以理解成就是我们做ionic那个html吧<br><code>wxss</code>:卧槽了就是这个wxss！卧槽！挑白了说就是个CSS！不过在像素定义有点不同。引用一下</p><blockquote><p>尺寸单位<br>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<br>设备rpx换算px (屏幕宽度/750)px换算rpx (750/屏幕宽度)<br>iPhone51rpx = 0.42px1px = 2.34rpx<br>iPhone61rpx = 0.5px1px = 2rpx<br>iPhone6 Plus1rpx = 0.552px1px = 1.81rpx</p></blockquote><p>所以官方说的是，<strong>“我们鼓励使用iphone 6 作为标准屏幕开发”</strong><br>原话是</p><blockquote><p>建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p></blockquote><p>（噢…是嘛…</p><p>另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。</p>]]></content>
      
      
      
        <tags>
            
            <tag> weapp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
