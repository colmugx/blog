<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>用 rust 实现i18n converter</title>
      <link href="/blog/2023/12/16/build-xls2json-with-rust/"/>
      <url>/blog/2023/12/16/build-xls2json-with-rust/</url>
      
        <content type="html"><![CDATA[<p>软件国际化必然需要翻译文件。虽然我也很想用类似 <code>locize.com</code> 之类的服务管理翻译，这样 <code>i18next-locize-backend</code> 直接游戏结束</p><p>可惜用不得，只有一个甚至早期管理还很乱的 excel 文件，所以需要解决「如何把它变成 json」的问题</p><h2 id="TL-DR">TL;DR</h2><ul><li>插件类型应用必然使用抽象工厂，早在设计 <a target="_blank" rel="noopener" href="https://github.com/FEMessage/upload-to-ali">FEMessage/upload-to-ali</a> 服务端就这么用</li><li>将文件对应为统一结构，以扩展的形式输出对应要求格式文件</li><li>使用 <code>calamine</code> 解析 <code>xls(x)</code> 文件</li><li>使用 <code>rayon</code> 直接让列表多线程</li></ul><span id="more"></span><h2 id="原始需求">原始需求</h2><p>因为确实需求很简单：将一个有规则的 excel 文件按照 i18next 可用的格式转成 json 文件。第一行是标题，除了第一列是 key，第二列开始是每个语言（例如简体中文、美式英语…）</p><p>所以这里大致有两个问题：</p><ol><li>获取传入参数</li><li>解析 excel 文件</li></ol><p>第一个还行，可以使用 <code>clap</code>。但这里不是一个非常复杂的 cli 应用，避免麻烦，直接读取 <code>env::args()</code> 分段即可</p><p>而第二个也直接找现成的解析库。今非昔比， rust 生态已经很好了。所以这里选择已经在 README 里暴打其他语言同行遥遥领先的 <code>calamine</code>（但不支持 write），大概是这样用的</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use calamine::&#123;Reader, Xlsx, open_workbook&#125;;fn main() &#123;  let mut excel: Xlsx&lt;_&gt; &#x3D; open_workbook(&quot;file.xlsx&quot;).unwrap();  if let Some(Ok(r)) &#x3D; excel.worksheet_range(&quot;Sheet1&quot;) &#123;      for row in r.rows() &#123;          println!(&quot;row&#x3D;&#123;:?&#125;, row[0]&#x3D;&#123;:?&#125;&quot;, row, row[0]);      &#125;  &#125;&#125;</code></pre><p>搞的很快啊，POC 一下子就弄完了。但是！本体 Qt 程序也有一样的需求，毕竟一心同体</p><p>虽说 <code>QTranslator</code> 和 <code>QtLinguist</code> 很强，但对我们来说只解决把 tag 取出来提供到 excel，转成 <code>.ts</code> 文件还是需要一个程序完成</p><p>那就格局大一点，excel to any，万一哪天需要 xml（来自后来人的说明：Qt 组直接以最简单最直接最不需要考虑产品化的思路干出一个序列/反序列全套程序，所以这个用不上了）</p><h2 id="如今实现">如今实现</h2><p>所以核心思路演变为：</p><ul><li>将每一组翻译变成一个通用结构</li><li>以扩展的形式读取这个通用结构列表，写出扩展想实现的输出</li></ul><p>非得拽一下，就是 <code>parser</code> -&gt; <code>interpreter</code></p><p>所以问题拆解成两个实现：</p><ul><li>一个通用的 converter</li><li>若干个 extensions (e.g. i18next-extension)</li></ul><h3 id="Converter">Converter</h3><p>开始解决第一个问题：excel -&gt; 「AST」</p><p>刚刚有提到这个文件的格式：</p><blockquote><p>第一列是 key，第二列开始是每个语言对应的翻译</p></blockquote><p>这个时候我们可以用一个结构体描述</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct LangPosition &#123;  name: String,  position: usize&#125;</code></pre><p>开始构建工作列表。假设这里有 6 种语言，那么就可以包装成 <code>[LangPosition; 6]</code></p><p>但是对于程序执行中不可能知道具体数量，所以构建一个 <code>Vec&lt;LangPosition&gt;</code>，通过扫标题来获取「有多少语言」。类似这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let header &#x3D; range.rows().next().ok_or(Error::Msg(&quot;Empty sheet&quot;))?;let mut lang_list &#x3D; Vec::&lt;LanguagePosition&gt;::new();for (i, cell) in header.iter().enumerate() &#123;    if let Some(language) &#x3D; cell.get_string() &#123;      &#x2F;&#x2F; 把语言和列索引加入 HashSet      lang_list.push(LanguagePosition &#123;          language: language.to_string(),          position: i,      &#125;)    &#125;&#125;</code></pre><p>现在已经知道了每个语言的对应关系，当需要生成某个语言的翻译文件，只需要让 <code>Extension</code> 处理这个 <code>LanguagePosition</code> 即可</p><p>但并不是，这里只是有某个语言和它的位置，现在需要做的是把 <code>key</code> 和某个语言的 <code>value</code> 对应起来并变成一个列表，所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct Atom &#123;  &#x2F;&#x2F; key  key: String,  &#x2F;&#x2F; 与之对应的 i18n value  value: String,&#125;</code></pre><p>接下来要遍历 <code>Vec&lt;LanguagePosition&gt;</code>，并且「按照单个语言为单位，通过 Extension 执行输出」。这里会用到一个 crate：<code>rayon</code></p><p><code>rayon</code> 是一个并行计算库，即可以使遍历这种事以多线程的方式运行，且无数据竞争。这对这个需求来说非常好 —— 每个语言的处理其实都很独立</p><p>所以这里要做的就是：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use rayon::prelude::*;lang_list.par_iter().for_each();</code></pre><p>按照 <code>row[0]</code> 是对应的 key，而 <code>row[position]</code> 则是对应 language 的翻译，就可以很方便给每种语言生成 <code>Vec&lt;Atom&gt;</code></p><p>接着顺便将这个列表丢给 <code>Converter</code> 的 <code>generate</code> 方法，<code>generate</code> 方法会调用对应的 Extension</p><p>所以应该补充一下，<code>Converter</code> 的结构：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct Converter &#123;  processor: Option&lt;Box&lt;dyn Extension&gt;&gt;,&#125;</code></pre><p>ok，来活了！为什么 <code>Option</code></p><p>其实这里要的很简单：初始化 Converter 的时候可以先不提供，由 <code>converter.register</code> 注册 Extension 并形成链式调用出去</p><p>这样做的目的是，当以后会有多个 Extension 想并行处理，则直接改成 <code>processors</code> 并且 <code>register</code> 可以变成以一种 <code>processors.push</code> 的形式</p><p>所以初始化 <code>Converter</code> 的时候，<code>processor</code> 可以是 <code>None</code>，并且当 Extension 是 <code>None</code> 时也可以直接处理异常，甚至是啥都不做，提醒一下然后直接退出</p><p>但是 <code>dyn Extension</code>？</p><h4 id="dyn-impl">dyn / impl</h4><p><code>dyn</code> 指动态分发，在运行时确定真正的返回类型。而 <code>impl</code> 与之对应即静态分发，编译期决定返回类型</p><p>换句话说，当要实现多态时，事实上是很难甚至是没办法知道「到底实现 Trait 的是谁」，只有真正运行起来才知道</p><p>但不管运不运行，只要是「鸭子模型」就都无所谓。而在程序之间传递的变量甚至是返回值，其实是可以知道「这个 <code>Struct</code> 就是实现了这个 <code>Trait</code> 甚至要求实现」，所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">fn register(self, ext: impl Extension + &#39;static) &#123;&#125;</code></pre><p>而且，dyn，dynamic，意味着编译时也无法确定 size，所以只能进堆，所以需要 <code>Box</code>，在 2018 之前处理这种情况是 <code>Box&lt;Trait&gt;</code>，在 2018 之后就变成了 <code>Box&lt;dyn Trait&gt;</code></p><p>为什么 2018？因为这俩是在 2018 Edition 新加的</p><h3 id="Extension">Extension</h3><p>一切准备好之后，意味着单个工作流内，会有一个<code>Vec&lt;Atom&gt;</code>等着挨处理，这个时候 Extension 只要要求实现 <code>transform</code> 就好了，或者说至少实现 <code>transform</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">trait Extension: Sync &#123;  &#x2F;&#x2F; 要求是 String 方便下一步写入文件  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String&#125;</code></pre><p>另外再实现 <code>ToString</code>，这一步是为了用户交互时可以 <code>print</code> 出当前正在使用什么扩展</p><p>其实应该实现 <code>Display</code>的，但是实现 <code>Display</code> 需要处理所有权的问题。例如我把 Extension 提供给 <code>register</code> 之后，所有权也对应转移。这个时候还要考虑 <code>Copy</code> 或者 <code>Clone</code> 就显得很麻烦</p><p>所以：</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">trait Extension: ToString + Sync &#123;  &#x2F;&#x2F; 要求是 String 方便下一步写入文件  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String&#125;</code></pre><p>剩下要做的，就是看需求实现对应的 Extension，例如 <code>I18NextExt</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">struct I18NextExt;impl Extension for I18NextExt &#123;  fn transform(self, data: Vec&lt;Atom&gt;) -&gt; String &#123;&#125;&#125;</code></pre><p>实际上在 Extension 和 Language 还做了一些额外的工作，但跟核心思路无关且不太好说，应该就这样差不多了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我必须立刻在 Tauri 跑 WebRTC</title>
      <link href="/blog/2023/07/26/tauri-signal-server/"/>
      <url>/blog/2023/07/26/tauri-signal-server/</url>
      
        <content type="html"><![CDATA[<p>按照需求，本来实现 <code>WebSocket</code> 的目的是收发 <code>Banshee</code> 的消息（主要是收）</p><p>后面突然灵光一闪：上个 <code>WebRTC</code> 怎么样？于是开始一段「为了醋包饺子」的心路历程：</p><ol><li>虽说原本是为了本地调试，但这套技术很明显内网都能用</li><li>如果有一个「授权」对话，那么就可以在内部进行「远程问诊」</li><li>测试或者验收遇到什么问题，望闻问切的第一步是<strong>望</strong></li><li><strong>Remote Display / Remote Desktop</strong></li></ol><h2 id="TL-DR-9">TL;DR</h2><ul><li>调整 <code>WebSocket</code> 支持的实现</li><li>实现信令服务器部分</li><li>因为流量都在内网，所以不需要转发（STUN）</li></ul><span id="more"></span><h2 id="什么是-WebRTC">什么是 WebRTC</h2><p>WebRTC（Web Real-Time Communications）是一项实时通讯技术，它允许网络应用或者站点，在不借助中间媒介的情况下，建立浏览器之间点对点（Peer-to-Peer）的连接，实现视频流和（或）音频流或者其他任意数据的传输。对于原生客户端（例如 Android 和 iOS 应用），可以使用具备相同功能的库</p><p>一言以蔽之：跟打电话一样</p><h2 id="调整实现">调整实现</h2><p>虽然 rust 有 <code>WebRTC</code> 实现，数据处理可以直接在应用后端搞定，但为了方便（浏览器支持才是原生支持），我希望将数据转发到应用前端，使用 <code>TypeScript</code> 完成</p><p>所以上一篇提到的 <code>WebSocket</code> 实现需要调整：监听 tauri 的 <code>Event</code> 并从 <code>WebSocket</code> 转发出去；监听 <code>WebSocket</code> 跟 <code>WebRTC</code> 相关的信息并从 tauri 的 <code>Event</code> 转发出去</p><p>麻就麻在这，有两套观察者互相套起来了</p><p>TODO: 已经忘记具体是什么问题了，总之我是这么解决的</p><h3 id="只要阻塞就拆线程">只要阻塞就拆线程</h3><p>tauri 的 <code>Event</code> 同样会因为监听的关系出现上一篇文章关于 <code>socket.recv</code> 的问题，一旦阻塞就拆线程</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">spawn(async move &#123;    &#x2F;&#x2F; FTN mean Frontend to Native    t.listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        sender            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);</code></pre><p>但是如果这么写的话，就会被编译器叼柒：<code>sender</code> 的生命周期可能没那么长（闭包还异步闭包）</p><p>彳亍。先借一下广播解决一下这个问题：广播跟 <code>sender</code> 同一层作用域，通过广播来转发这层数据，回收时间一致</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (tx, _) &#x3D; broadcast::channel(100);spawn(async move &#123;    t.get_win().listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        tx            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);</code></pre><p>接着，广播收到包之后，就要转发给 <code>WebSocket</code> 让它发出去</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let mut rx &#x3D; tx.subscribe();spawn(async move &#123;    let mut sender &#x3D; sender.lock_owned().await;    while let Ok(msg) &#x3D; rx.recv().await &#123;        if sender.send(msg).await.is_err() &#123;            break;        &#125;    &#125;&#125;);</code></pre><p>跟住就又碌柒：如果这么写，<code>tx</code> 的所有权早在刚刚 <code>send</code> 那层就转移了(move)</p><p>彳亍。先解决问题：<code>clone</code> 一份</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (tx, _) &#x3D; broadcast::channel(100);let tx_for_tauri_send &#x3D; tx.clone();spawn(async move &#123;    t.get_win().listen(&quot;FTN&quot;, move |e| &#123;        let payload &#x3D; e.payload().unwrap();        tx            .send(Message::Binary(Vec::from(payload.as_bytes())))            .unwrap();    &#125;);&#125;);let mut rx &#x3D; tx.subscribe();spawn(async move &#123;    while let Ok(msg) &#x3D; rx.recv().await &#123;        if sender.send(msg).await.is_err() &#123;            break;        &#125;    &#125;&#125;);</code></pre><p>这个解决方式只能说是为了快速实现而写的，我认为它有很大重构空间（但重构也不更新文章）</p><h2 id="实现信令服务">实现信令服务</h2><p>这个需求的场景相当于永远只有固定一方拨（<code>banshee</code> 侧），固定一方接(<code>cockpit</code> 侧)，所以这里的「信令」服务相当于只转发了 <code>SDP</code> 和 <code>ICE</code>，其他啥都没做</p><p>因为 tauri 这边已经将前端和后端用 <code>Tauri Event</code> 打通，接入前端跟 <code>Tauri App</code> 用 <code>WebSocket</code> 打通，所以只需要在接入前端侧实现 <code>Offer SDP</code> 并将 <code>mediaDevices.getDisplayMedia</code> 的数据 <code>addTrack</code>，拿到 <code>ICE</code> 发送出去</p><p>而 tauri 这边只需要等收到 <code>Offer SDP</code> 之后换一个 <code>Answer SDP</code> 回去即可在内网环境内传输音视频</p><p>因为这部分哪里都是一样的就不贴实现，全靠 <code>RTCPeerConnection</code></p><h2 id="References">References</h2><ul><li><a target="_blank" rel="noopener" href="https://webrtc.org/getting-started">https://webrtc.org/getting-started</a></li><li><a target="_blank" rel="noopener" href="https://github.com/webrtc-rs/webrtc">https://github.com/webrtc-rs/webrtc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> tauri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我必须立刻在 Tauri 跑 WS</title>
      <link href="/blog/2023/07/25/tauri-ws-server/"/>
      <url>/blog/2023/07/25/tauri-ws-server/</url>
      
        <content type="html"><![CDATA[<p>其实开发一个程序思路一直都是一致的，并不会因为是前端就会差/简单多少。再加上之前因为有「多端」这个「产品概念」之后，所以程序上一直在解决一个问题：如何将 Web 之外的逻辑固定下来？于是有了 <code>Banshee</code>，下次细说</p><p>既然有一个框架了，并且也选择使用跟 <code>Angular</code> 类似的 root 级 DI 这种路线之后，开始有一个想法：</p><blockquote><p>流向很清晰，这个时候有一个测试监控一体机是不是实现方便作用不小？</p></blockquote><p>于是有了 <code>Banshee Cockpit</code>，但它也跟 <code>Banshee</code> 一样，下次细说</p><p>又到了技术选型环节：早在三年前就尝试的 electron 方案 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>（已归档），当时是为了直接在树莓派运行智能闹钟程序时顺便提供 API 以远程操控，所以让 <code>electron</code> 附带的 <code>node</code> 跑起来一个 <code>koa</code></p><p>でも、选型依然是我目前的经典搭配：Tauri + Solid。那首先要解决的有两个问题：</p><ol><li>还是一样，需要跑一个 server</li><li>因为需要收发 <code>Banshee</code> 的信息，所以需要 <code>WebSocket</code></li></ol><h2 id="TL-DR-10">TL;DR</h2><ul><li>你可以直接用 <code>Rust</code> 提供的基础库，但我用 <code>axum</code></li><li>集成起来很方便，麻烦的是 <code>Rust</code></li><li>摆烂了，<code>Rust</code>对于内存的执着有种让人想一拳打爆屏幕的冲动</li></ul><span id="more"></span><h2 id="选个框架">选个框架</h2><p>原因还是跟三年前一样，从 NIO 开始是没必要的，集成一个服务端框架更方便使用。</p><p><code>Rust</code> 现在「主流」的服务端框架有三种：</p><ul><li>actix-web</li><li>rocket</li><li>axum</li></ul><h3 id="actix-web">actix-web</h3><p>作为我最喜欢的框架（在该文章之后已经易位），有活肯定是第一个想到，就是<strong>不知道怎么塞进去</strong>比较可惜</p><p>更大的原因是因为 actix 和 tauri 使用了两套异步逻辑，即使让 actix 运行起来了效果也不好。GitHub 也有一个类似的<a target="_blank" rel="noopener" href="https://github.com/tauri-apps/tauri/discussions/2942">相关讨论</a></p><p>而且还有一个我之前没发现的，作为客户端问题也很大的问题：这 B 东西体积有点大</p><h3 id="Rocket">Rocket</h3><p>Rocket 集成起来非常简单，只需要在 tauri 的 <code>main</code> 程序挂一个 <code>tokio</code> 入口或者是 <code>launch</code>，并且在 <code>setup</code> 把相关的上下文带进去，很轻松就完成</p><p>当我拿出香槟 🍾 打开的一瞬间，我发现有一个更大的问题：Rocket 不支持 <code>WebSocket</code>…</p><p>直接抬走</p><h3 id="axum">axum</h3><p>在 AI 时代之前获取信息全靠「漫反射」，但 AI 之后就不一样了</p><p>孤陋寡闻的我只知道两个框架，两个框架之后就没活了。但现在我可以打开之前跟我<a href="/blog/2023/04/02/chatgpt-novel/">一起写小说</a>的 <code>Bing AI</code>，从那得知还有一个体积不大性能也不错的新秀 <code>axum</code>。当我看到开发它的组织是 <code>tokio-rs</code>，直接上了</p><h2 id="跑个-server">跑个 server</h2><p>跑起来确实也没什么感觉，虽然可以直接跟着当前线程执行，但我还是为了方便还是多开一个线程跑 server，毕竟不是 <code>JavaScript</code> 不阻塞</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F; create servertauri::async_runtime::spawn(async move &#123;    server::create_server(&amp;main_window).await;&#125;);</code></pre><p>剩下的跟直接用 <code>example</code> 没有区别，直接跑个 Hello World 也就这样</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">async fn create_server() &#123;    let app &#x3D; Router::new().route(&quot;&#x2F;&quot;, get(handler));    let addr &#x3D; SocketAddr::from(([127, 0, 0, 1], 3000));    println!(&quot;listening on &#123;&#125;&quot;, addr);    axum::Server::bind(&amp;addr)        .serve(app.into_make_service())        .await        .unwrap();&#125;async fn handler() -&gt; Html&lt;&amp;&#39;static str&gt; &#123;    Html(&quot;&lt;h1&gt;Hello, World!&lt;&#x2F;h1&gt;&quot;)&#125;</code></pre><p>因为我们的需求是跑一个 <code>WebSocket</code>，按照 example 改改可以得到这个</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">pub async fn create_server(win: &amp;Window) &#123;    let app_state &#x3D; AppState &#123;        communication: Communication::new(win.clone()),    &#125;;    let server_app &#x3D; Router::new()        .route(&quot;&#x2F;cockpit-connect&quot;, get(ws_handler))        .with_state(Arc::new(app_state));    let port &#x3D;        find_available_port().expect(&quot;No available port found in default, please provide a port.&quot;);    let addr &#x3D; SocketAddr::from(([127, 0, 0, 1], port));    println!(&quot;Server running on port &#123;&#125;&quot;, port);    axum::Server::bind(&amp;addr)        .serve(server_app.into_make_service())        .await        .unwrap();&#125;async fn ws_handler(ws: WebSocketUpgrade, State(state): State&lt;Arc&lt;AppState&gt;&gt;) -&gt; impl IntoResponse &#123;    ws.on_upgrade(move |socket| handle_socket(socket, state))&#125;async fn handle_socket(socket: WebSocket, state: Arc&lt;AppState&gt;) &#123;    while let Some(msg) &#x3D; socket.recv().await &#123;        match msg &#123;            &#x2F;&#x2F; 这个需求不使用 text 传输            Ok(Message::Binary(data)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 想用可以这么用            &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;            &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)            &#x2F;&#x2F; &#125;            Ok(Message::Close(_)) &#x3D;&gt; &#123;               println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            Err(e) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理            _ &#x3D;&gt; &#123;&#125;        &#125;    &#125;&#125;</code></pre><h2 id="rust-经典臭问题">rust 经典臭问题</h2><p>到这会发现，如果使用了 <code>socket.recv</code> 还想在 <code>socket.send</code>，<code>socket</code>这个参数开始有「所有权问题」，你只能在<code>socket.recv</code>的作用域内用<code>socket.send</code>。这就相当抽象：只能回复是吧</p><p>好在这不是一个非常见问题，毕竟在不同作用域里处理信息和发送信息是一个非常常见的需求。搜了一圈，发现可以用 <code>stream::StreamExt</code> 和 <code>SinkExt</code> 拆分一个流</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let (sender, mut receiver) &#x3D; socket.split();while let Some(msg) &#x3D; receiver.next().await &#123;    match msg &#123;        &#x2F;&#x2F; 这个需求不使用 text 传输        Ok(Message::Binary(data)) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        &#x2F;&#x2F; 想用可以这么用        &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;        &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)        &#x2F;&#x2F; &#125;        Ok(Message::Close(_)) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        Err(e) &#x3D;&gt; &#123;            println!(&quot;&#123;:?&#125;&quot;, data)        &#125;        &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理        _ &#x3D;&gt; &#123;&#125;    &#125;&#125;</code></pre><p>现在看起来收发自由了，但是当进入到 <code>receiver</code> 时，整个应用会像冻结了一样，下面的逻辑都无法执行到，也就变成了：只要没收到信息，所有要发送的信息都发不出去…</p><p>好在这也不是一个非常见问题，因为好像除了 <code>JavaScript</code> <s>这种垃圾语言</s>都是这样的 —— 都是同步阻塞类型</p><p>所以我暂时先这么做：将处理信息的逻辑送到另一条线程</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">spawn(async move &#123;    while let Some(msg) &#x3D; receiver.next().await &#123;        match msg &#123;            &#x2F;&#x2F; 这个需求不使用 text 传输            Ok(Message::Binary(data)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 想用可以这么用            &#x2F;&#x2F; Ok(Message::Text(data)) &#x3D;&gt; &#123;            &#x2F;&#x2F;     println!(&quot;&#123;:?&#125;&quot;, data)            &#x2F;&#x2F; &#125;            Ok(Message::Close(_)) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            Err(e) &#x3D;&gt; &#123;                println!(&quot;&#123;:?&#125;&quot;, data)            &#125;            &#x2F;&#x2F; 其他情况丢弃，函数是 () 返回不处理            _ &#x3D;&gt; &#123;&#125;        &#125;    &#125;&#125;)</code></pre><p>现在基本上做到了收发自由</p><h2 id="References-2">References</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/tokio-rs/axum">https://github.com/tokio-rs/axum</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> tauri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>写代码还有激情吗?</title>
      <link href="/blog/2023/07/20/passion-of-coding/"/>
      <url>/blog/2023/07/20/passion-of-coding/</url>
      
        <content type="html"><![CDATA[<p>在今年的上半年，看以前以码为友的群，群主在逼问一个群友。详情看这个吧</p><p><a target="_blank" rel="noopener" href="https://2nthony.com/posts/passion-of-coding">写代码还有热/激情吗? - 2nthony</a></p><p>说实话，代码这个事情想到还是会激情澎湃，每天还是能维持非常活跃的「创作」思维。但是写代码，还是淡了</p><p>原因有很多，体力、生活、工作……</p><span id="more"></span><h2 id="关于体力">关于体力</h2><p>别不承认，确实会随着年龄增长而感觉力不从心。刚毕业的时候能因为热情莽它个凌晨3点，第二天8天照样醒来去上班。相当于一天 <strong>仅需要 6 小时</strong> 睡眠时间就可以满足一天的生活</p><p>现在是做不到了，回到家会明显感受到疲倦。可以说现在上班因为「不纯粹」导致花费太多的精力，下班了再看到电脑只会想起白天的事情，故大多数时间不想使用电脑</p><p>也可以说剩余的精力确实无法支持了，以至于其实很多时候都会想「如果有机器能直接让我的想法变现就好了，不是要无中生有变成产品，我可以颅内编程」</p><h2 id="关于工作">关于工作</h2><p>Actually，上班时还是有写一些东西。这两年都在实现「无框架化」的操作。</p><blockquote><p>AVR is evil – Phodal</p></blockquote><p>写了两个东西：</p><p>第一个是对业务的沉淀，实用型库。大多数 infrastructure 类型的例如 <code>Request</code>, <code>Tracking</code> 都是 Adaptor Pattern</p><p>第二个是框架化的实践。我希望把整洁架构和六边形架构都融合到前端项目中来，因为我们接下来的项目属于是中型长线更新型项目，严格意义上并不算「前端」，所以有完整的测试和 DDD 明显会更好。主要技术还是 DI 和单例，CQRS, ES 我们都会包含到框架里</p><p>并且很明显，第二个产品会提供 adaptor port 给第一个产品，也就是第一个产品的 <code>Request</code> 和 <code>Tracking</code> 等等也会有 adaptor 接到框架，也就是 Application - Adaptor - Adaptor…</p><p>但显然两个框架都在我手里，interface 是一样的就完事儿了</p><p>除此之外还有一个远程观察/调试工具也正在开发，我觉得很有意义。例如远程请求拦截，观察应用运行状态，甚至直接观察操作（WebRTC 可以做到）</p><p>第二第三是计划开源，到时候看内部情况</p><h2 id="关于生活">关于生活</h2><p>确实生活的影响也很大，除了说自身身体之外，生活上的事情也会影响到我。但我确实不喜欢讨论自己的生活</p><p>其实可以盘算一下，我已经立项的项目到现在都过了多久</p><ul><li>nlvi 3.0：19年，直接放弃</li><li>nlvi Next：20年，没有进展</li><li>resumer：20年，因为简历直接没有需求所以不做</li><li>kazusa：20年开始，22年调整方向，至今只是能读取文件</li><li>setsuna：20年提到，21年还在技术选型，至今没有像样的逻辑</li><li>ayaka：22年提出，只能说实现一个 SPA Blog 的话能勉强算是一个 POC</li><li>evolution pong：21年刚到游戏公司，想如果以 pong 为原型不断加入玩法看能有什么效果的实验，但只完成基本功能</li><li>……</li></ul><p>坑多，每个坑的规划（项目管理）做得不好，加上设计不充分。导致每次打开电脑想开始某一段开发时，总会被各种问题困扰或者无法推进，最终只会是「先想想还没想好」而终止开发</p><p>加上现在会投入很多时间给自己的生活，可能原本周末会坐下来，即使只是坐着没有推进，但还是会验证一两个技术问题。而现在……</p><h2 id="所以">所以</h2><p>flappy bird。只要点击屏幕，bird 就会稍微抬头；但只要放弃点击屏幕，bird 就会下坠，而且是重力下坠</p><p>当我觉得「还是要放弃吗」的时候，我会去看看曾经的自己，看看曾经也对此有过激情的朋友们：包括不限于 yuexun, 2nthony，或是 Randy</p><p>其实我已经慢慢变得对信息不太敏感，也不知道现在该去哪里看什么东西。我也曾经让 4ark 推荐我一些 RSS</p><p>当我发现 yuexun 还会去参加 RustConf 的时候我还是会先是羡慕，然后想</p><p>我是否还是程序员？</p>]]></content>
      
      
      <categories>
          
          <category> 思考 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>跟 ChatGPT 共同创作？</title>
      <link href="/blog/2023/04/02/chatgpt-novel/"/>
      <url>/blog/2023/04/02/chatgpt-novel/</url>
      
        <content type="html"><![CDATA[<p><img src="/blog/Image/bingai-dalle.jpeg" alt="Bing 调用 DELL-E 生成结局场景"></p><p>不讲虚的，直接开始</p><p>正文在最后一个章节，爱看不看</p><p>如果你选择阅读，希望你可以猜测一下：哪部分内容由 AI 生成的？</p><p><strong>Tips: 不一定是成片的内容，全程有来有回</strong></p><h2 id="TL-DR-2">TL;DR</h2><ul><li>配合的版本是 Bing AI</li><li>出于这B的限制，文章除了是多次对话拼接而来，还需要应对实时更新问题</li><li>联网、实时的 ChatGPT 更令人害怕</li><li>颠覆了原本我对 NLP 原本的理解</li><li>用于文学创作还是太硬，它依然还是“计算机思维” —— 效率达成目的</li><li>AI 经常忘记上标点（别利用这一点去猜，我手动补上了）</li></ul><h2 id="总结">总结</h2><p>就是一个字：害怕，非常害怕</p><span id="more"></span><p>我用的是 Bing AI，并不是说 GPT3.5 或是 GPT4 不好，而是后者对我来说有点麻烦，不如微软爹的东西直接打开就能用，加上本来就是 Microsoft Edge 的用户，不存在专门下个浏览器</p><p>大多数情况下我们配合得还算很好的，基本上即使分成了很多个会话（我有时候会想看更多发展，会打开三个标签页同时接一样的内容），虽说生成的内容不是很喜欢，<strong>但大致思路是很接近的，甚至 AI 给我提供了一些事件和制造节奏的思路</strong></p><p>过程上真的一边写一边笑，在想这怕不是日系故事有套路，都这么写；AI 是不是先知道了「暗恋和表白」的结果所以一有机会就 A 上去；这个发展真的，我来我也这么做（x</p><p>加上我的提示语其实不多，而且这个属于创作类型的使用类型，所以很有意思</p><p>实际上在预训练时就已经把几乎「能看的所有东西」都过了一遍，知书达理，博学多才应该是「非常正常」的事，<strong>直到我看到它去搜索</strong>了「日本高中毕业」、「薰衣草的寓意」等等我们在续写过程中出现的一些关键词，并像原本聊天问答一样经过理解之后<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，这时<strong>不是对所有搜索到的资料进行一个总结，而是继续代入回「小说」这个语境再继续续写工作</strong>，并且它依然能把它续写的相关内容画上虚线。我看着对话底下的「了解详细信息」，真的令人感到害怕。</p><p><img src="/blog/Image/bingai-1.png" alt="Bing AI 搜索剧情发展所需信息"><br><img src="/blog/Image/bingai-2.png" alt="Bing AI 根据信息续写"><br><img src="/blog/Image/bingai-3.png" alt="Bing AI 信息来源"></p><p>总的来说，我非常喜欢这次尝试结果，因为不管是剧情发展，还是人物性格，人物关系，我觉得 AI 都大致上是真的了解到的</p><p>只不过措辞和文字相对真正的作家可能显得稚嫩不成熟，加上我从来不看网文小说…</p><p>再挖个坑？因为这个小说的人物设计、背景、以及一些东西的含义我是真的设计过的，如果凑合的话，要不真的写一部正经的？这波自己写</p><h2 id="正文">正文</h2><p>叠甲：由于已经记不清到底打开了多少个对话才有这些内容，为了让每个对话（虽然上限是20条，但大多数都是到12 13就因为你用过就会懂的原因 AI 直接跳出）之间联系比较自然，衔接的部分一般都是我自己补上去的，但有时候太跳脱了，我也只是当做测试不会花太多时间，文案会显得很粗糙。<s>当然你也可能看不出衔接。</s></p><p>并且我会尽量给这些内容打个小节？也许它并不合适</p><blockquote><p>PROMPT:<br>我们现在开始故事接龙。接下来我会简单介绍一些背景和信息点：“女主会按照风铃草来设计，包括不限于性格，形象，名字等等。男主人公是一个非常普通的高中生，其他部分都交给你设计包括男主姓名。这是一个日系校园恋爱故事，故事发生在日本高中的毕业季，女主是喜欢一个同班的男同学也就是男主人公，一直暗恋不敢表白。最后在毕业那天，女主已经在想放弃和好好跟高中的生活告别了，但在离开校园大门前，发现男主正拿着一束风铃草在校门口等她。” 你可以搜索各种你认为需要的公开的资料。如果你准备好了就回答准备好了。我先写，你来续写。</p></blockquote><h3 id="1">1</h3><p>家里的院子里有一片风铃草，那是我妈妈种的。她说过，风铃草有着迷人的优点，并希望我能像风铃草一样。但她始终没有告诉我那是什么。</p><p>又是一个清晨，阳光穿过厚厚的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。这是我的同班同学，我们从小学就一直是同学，也是无话不说的闺蜜。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你从来不把发带直接扎在头发上，而是做成像边夹一样别在头上呢！”</p><p>“嗯，因为我觉得这样更有特色一点吧，而且我喜欢浅蓝色，就像风铃草一样”我笑着回答。</p><p>“风铃草？话说你家门口的那片植物是不是就是风铃草？”薰突然像是一个问题孩子，“风铃草是不是还有一个名字叫忘忧草？”</p><p>“忘……忧……草”我心里不断地想着这个词。是啊，我应该怎么面对我的忧愁呢……</p><p>我很在意一个人，他是我的同班同学，名叫悠太，是一个很普通的男生。他没有什么特别出众的地方，也不是什么学霸或者校草。但他看起来总是很安静，很专注，很有思想。他喜欢看书，喜欢音乐，喜欢观察周围的事物。他的眼神总是很深邃，很温柔，很有魅力……</p><p>“你是不是又在想那个男生了？你看你又是这样，突然魂就不知道飞到哪儿去了！”</p><p>我突然如惊醒一般，连忙转头看了一眼薰，她的五官都快以鼻子为中心挤成一团了，我感受到了薰涌上来满满的怨念。</p><p>“我真的很不明白你为什么对他这么在意！”薰越想越气，“他对所有人都爱理不理，这么多年也没见他参加过什么活动。他甚至会因为别人去打扰他而发脾气！”</p><p>“你快别这么说。”我拉了拉薰的衣角。</p><p>只听到薰话音刚落，薰的脸色又变得非常的甜美阳光，“你看那个连，长得好帅，不仅成绩很好，琴棋书画都很擅长。还有还有！身上总有一股迷人的，每天不重样的清香。”</p><p>我就这么看着薰光滑而圆润的脸上，又从一脸花痴相进行了一次一百八十度的渐变，“而且人家还很关心你！他对你多好啊！那么多喜欢他的女孩子他从来都不看一眼！我真的好羡慕你！噢~你是不是在吊着人家！你要是不喜欢人家能不能直接说！你不喜欢有的是人喜欢！”</p><p>“薰，你别说了，我真的不喜欢连。”我无奈地说道，“他虽然很优秀，很帅，很有才华，但是他不是我的类型。我对他没有任何感觉，也不想吊着他。”</p><p>“那你为什么不拒绝他呢？”薰不解地问道，“他已经向你表白了好几次了，你每次都说要考虑一下，你这样不是在耽误人家吗？”</p><p>“好了我们先不要聊这个话题了！”我们就这样走着走着，不知不觉到了校门口，“明天就是毕业典礼了，你有想过毕业以后的事情吗？”</p><p>“我还没有想过哎，你想过了吗？能不能告诉我你的计划啊铃酱~”</p><h3 id="2">2</h3><p>“我啊，我——”</p><p>“钟同学——”啊，这个声音，我跟薰回头一看，是连。</p><p>“早上好，钟同学，山本同学。”</p><p>“早上好连同学。”我下意识地瞟了一眼薰，果然她整个人都已经迷糊了。</p><p>“钟同学，你今天的发夹真可爱，很适合你呢。”</p><p>“谢谢”，我迅速回避掉他的眼神，心想：求求你能不能不要再在意我啊……我要怎么逃走啊……</p><p>“钟同学，我能跟你说一句话吗？”连突然说道，“其实我有一件事情想跟你说，很重要的事情。”</p><p>“什么事情？”我紧张地问道，“你说吧。”我隐隐约约感觉到，他又会说……</p><p>“其实……”连犹豫了一下，“其实我一直很喜欢你，我想跟你在一起。”</p><p>“啊……”我惊讶地看着他，不知道该怎么回答。</p><p>“钟同学，你不用马上回答我，你可以考虑一下。”连温柔地说道，“但是请你不要拒绝我，给我一个机会吧。”</p><p>“我们要快点去教室了！马上就开始上课了！”我给薰使了一个眼色。但薰好像没有看到，她一直在盯着连看。</p><p>“薰！！！”我大喊了一声，“马上上课了！！”</p><p>“啊…啊！我们要先去上课了！”薰依然还是眼巴巴的盯着连边看边说道，“不好意思啊，铃酱她总是这样……”</p><p>“快走啦！”，我拉着薰就跑了起来，往楼里奔去。</p><p>“等等，钟同学！”连追了上来，“你还没有回答我呢！”</p><p>“对不起，连同学，我现在不能回答你。”我说道，“我还有很多事情要考虑，我需要一些时间。”紧接着我拉着薰头也不回地往前跑。</p><p>好像已经甩开了，我心里这么想到。于是我们渐渐放慢脚步朝着自己的教室走去。</p><p>“铃兰，你怎么能这样呢？”薰责备我说，“你不是说你不喜欢他吗？怎么每次都这样！”</p><p>“可是……”我无奈地说，“可是他对我这么好，我真的又不忍心拒绝他。”</p><p>“那你就这样拖着他吗？”薰皱着眉头说，“你知道吗，你这样做对你自己也不好。”</p><p>“那我们就别再说这个了。”我打断了她，“我们还是聊回毕业典礼吧。你有没有准备什么礼物给老师和同学呢？”</p><p>“嗯……”薰想了想，“其实我还没有准备呢。你呢？”</p><p>“我也没有呢。”我说道，“不过我想送一些手绘的卡片给大家，上面画上他们的头像和一些祝福的话。亲手做的礼物也许更有意义呢”</p><p>“哇，你真是太有心了！”薰感动地说道，“你这样做一定会让大家都很开心的！”</p><p>“谢谢你。”我笑了笑，“其实我也有点舍不得毕业呢。毕竟我们在这里度过了三年多的时光，有过很多难忘的回忆。”</p><p>我们就这样聊着聊着，到了教室。教室里已经有不少同学了，他们都在互相打招呼。</p><p>我不急不缓移动到自己的座位上，坐下挂好自己的书包，突然感觉好像有谁看了我一眼。</p><p>我捕捉到悠太朝我脸上射出的视线，悠太似乎也发觉到了，瞬间收回他的眼神。他坐在窗边的座位上，手里拿着一本书，看得很专注。他没有跟任何人说话，也没有收到任何礼物。他就像一个孤岛，与周围的世界隔绝。透过窗户微弱的阳光溅射在他的身上，一切都如此平静和静谧。</p><p>“真的让人很好奇啊，他到底每天都在想些什么呢？”我不禁这样想。</p><p>“你又在看他，那个奇怪的男生。”薰走过来指着悠太摇头说道，“一点毕业的气氛都没有，他不会是觉得这样很酷吧？”</p><p>“可能他不喜欢这种场合吧。”我说道，“或者他有什么心事呢。”</p><p>“心事？”薰疑惑地问道，“他有什么心事啊？”</p><p>“我也不知道。”我摇摇头，“只是猜测而已。”</p><p>“我真的无法理解，你总是向着他。他明明也没对你做过什么事。”薰漠不关心地刷着她的手机。</p><p>“铃兰！铃兰！”薰突然非常激动地缠住我的胳膊，“快看快看！我收到了一封大学的录取通知书！”</p><p>“哇！你收到了录取通知书啊！”我惊讶地说道，“你可真是个幸运儿呢！”</p><p>“嘿嘿嘿~”薰得意地笑道，“那是当然啦！”</p><p>“那你被哪所大学录取了呢？”我问她。</p><p>“嗯……”薰想了想，“其实我报了好几所大学，这封是其中一所的。你呢？”</p><p>“我啊……我还没有收到任何录取通知书呢。”</p><p>“啊，真的吗？”薰关切地问道，“你不要着急，你一定会收到的。你是一个很优秀的女孩子，你的成绩也很好。我相信你会被你想去的大学录取的。”</p><p>“谢谢你。”我说道，“你真是个好朋友。”</p><p>“不客气。”薰笑着说道，“你要加油哦。”</p><p>我跟薰拥抱了一下，感受到了她的温暖和支持。我心里有些感动也有些紧张。我不知道我的未来会怎样，我能不能实现我的梦想，我能不能遇到我的爱人。但是我知道，无论如何，我都不会忘记我的高中生活。</p><h3 id="3">3</h3><p>就在这时，铃声响了。老师进来了。他手里拿着一本书和一张纸。</p><p>“同学们，请安静一下。”老师说道，“我想跟大家做一个小测试。”</p><p>“啊？小测试？”大家都惊讶地各自议论纷纷。</p><p>“这个小测试不是为了考核你们的知识，而是为了考核你们的心情。”老师说道，“这个小测试只有一个问题，就是：你对高中生活有什么感想？”</p><p>“这个问题……”大家都沉默了。</p><p>“你们可以用任何形式来回答这个问题，可以是文字，可以是图片，可以是音乐……只要能表达出你们的真实感受就行。”老师说道，“你们可以用纸笔来做这个小测试，时间限制在十分钟内。”</p><p>“老师，这个小测试有什么意义吗？”有人问道。</p><p>“这个小测试的意义就是让你们回顾一下自己的高中生活，感受一下自己的成长和变化。”老师说道，“也让你们有一个机会跟自己和大家说再见。”</p><p>“再见……”大家都低声重复了一遍。</p><p>“好了，开始吧。”老师说道。</p><p>大家都开始做起了小测试。有的人用手机打开了相册，翻看着自己的照片。有的人用纸笔写下了自己的心情。有的人用耳机听着自己喜欢的歌曲。</p><p>我决定用画画来回答这个问题。我想通过画表达我的高中生活的点点滴滴，我的快乐和悲伤，我的收获和失去，我的梦想和现实。</p><p>于是，我开始画起了薰衣草……</p><p>我觉得它很适合我，我知道他可能不会注意到我，也不会喜欢我，但是我还是忍不住对他抱有希望。我想用薰衣草来表达我的心情，也许他能感受到我的心意。</p><p>我画出了一片薰衣草田，上面有一只小鸟在飞翔。小鸟代表着自由和梦想，它可以飞向任何地方，也可以找到自己的伴侣。我希望自己也能像小鸟一样，能够追求自己的梦想，能够遇到自己的爱人。</p><p>我画出了一座小屋，里面有一张桌子和一把椅子。小屋代表着安静和思考，它可以让人放松和沉淀。我喜欢在小屋里看书，听音乐，画画。这些都是我跟悠太有共同的爱好，也是我们之间唯一的交集。我希望自己能在小屋里跟他相遇，能够跟他分享我的想法和感受。</p><p>我画出了一颗大树，上面挂着一个风铃。大树代表着坚强和成长，它可以抵御风雨和寒冷。我在高中生活中经历了很多困难和挫折，但是我没有放弃，而是努力学习和进步。</p><p>我把这些元素都组合在一起，形成了一幅美丽的画面。这就是我的高中生活的写照，也是我的心灵的映射。我对这幅画感到很满意，也很感动。这就是我的答案。</p><p>“你画得真好啊！”薰走过来看了看我的画说道，“这是什么花啊？”</p><p>“这是薰衣草。”我说道，“你不知道吗？”</p><p>“哦，原来是薰衣草啊。”薰说道，“它跟我的名字很像呢。”</p><p>“是啊。”我说道，“你知道它的花语吗？”</p><p>“不知道呢。”薰说道，“你告诉我吧。”</p><p>“它的花语是‘等待爱情’。”我说道。</p><p>“等待爱情？”薰重复了一遍，你觉得爱情是什么呢？“</p><p>“我觉得爱情是……”我想了想，“是一种心灵的契合，是一种灵魂的共鸣，是一种无法言喻的感觉。”</p><p>“哇，你说得好深刻啊！”薰赞叹道，“你是不是已经遇到了你的爱情呢？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰奇怪地问道，“你怎么会不知道呢？”</p><p>“因为……”我低下了头，“因为我喜欢的人可能不喜欢我。”</p><p>“啊，真的吗？”薰惊讶地说道，“你喜欢的人是谁啊？”</p><p>“他是……”我刚想开口，就听到了老师的声音。</p><p>“同学们，时间到了，请大家把自己的小测试交给我。”老师说道，“我会把你们的答案都收集起来，作为我们班级的纪念。”</p><p>大家都把自己的小测试交给了老师，老师一一收下，并且给出了一些评价和感想。轮到我的时候，老师看了看我的画作，赞叹道：</p><p>“铃兰同学，你的画真是太美了！你用薰衣草来表达了你对高中生活的感想，很有创意和深意。你是一个很有才华和情感的女孩子，你的画让我感动了。”</p><p>“谢谢老师。”我说道，“您也是一个很好的老师，您教了我很多知识和技巧。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了我的画作，然后走向了悠太。悠太也拿出了他的小测试，交给了老师。</p><p>我看到老师也很惊讶地看着悠太的画作，问道：“悠太同学，你的画也很美啊！你用风铃草来表达了你对高中生活的感想，很有——”</p><p>“什么？风铃草？！”正在走神的我突然听到了老师说悠太画的是风铃草，吓了一跳，本能地发出了“啊！”的声音。</p><p>“你怎么了？铃兰同学？”老师站在悠太座位边上朝我的方向看，“你刚刚遇到什么问题了吗？”</p><p>“没……没什么。”我尴尬地说道，“我只是有点惊讶而已。”</p><p>风铃草？为什么他会画风铃草呢？难道他也喜欢风铃草吗？还是他有什么别的寓意呢？</p><p>“惊讶什么？”老师问道。</p><p>“惊讶……”我瞟了一眼悠太的画作，“惊讶悠太同学画的是风铃草。”</p><p>“为什么会惊讶呢？”老师又问道。</p><p>“因为……”我不知道该怎么回答，只好编了一个理由，“嗯……我也喜欢风铃草，我也没想到悠太画的也是花。”</p><p>“哦，是这样啊。”老师笑了笑，“那真是巧合呢。你们两个都很有眼光，风铃草是一种很美丽的花，也很有寓意。”</p><p>老师转向了悠太，“你用风铃草来表达了什么感想呢？”</p><p>“没什么，就是单纯想画风铃草。”悠太说道，语气淡淡的，一如既往的冷静回答，仿佛人类的感情与他无关。</p><p>“就是单纯想画风铃草？”老师有些不解地问道，“你就没有什么特别的感想？”</p><p>“没有。”悠太摇摇头，“可能风铃草很好看，很有意思。”</p><p>“好看，有意思？”老师又问道，“展开讲讲？”</p><p>悠太想了想，“我喜欢风铃草的颜色，浅蓝色，很清新，很舒服。我喜欢风铃草的形状，像小铃铛，很可爱，很有趣。”</p><p>“原来如此。”老师点点头，“你对风铃草的描述很细致，很生动。你是一个很有观察力和感受力的男孩子，你的画让我印象深刻。”</p><p>“谢谢老师。”悠太说道，“您也是一个很好的老师，您教了我很多知识和技能。我会永远记住您的。”</p><p>“不客气。”老师笑着说道，“你要加油哦。”</p><p>老师收下了悠太的画作，然后走向了其他同学。我倾听着他跟老师的对话，心里有些疑惑也有些失落。他为什么只是单纯想画风铃草呢？他没有什么特别的感想吗？他对高中生活没有什么回忆和感情吗？他对我没有什么期待和祝福吗？</p><p>为什么他会画风铃草呢？难道他真的只是单纯想画而已吗？还是他有什么别的原因呢？</p><p>我想起了他平时的样子，总是一个人坐在角落里，看着书或者听着音乐，从不跟任何人交流。他总是那么冷漠，那么孤独，那么神秘。</p><p>他到底在想些什么呢？他到底喜欢些什么呢？他到底喜欢谁呢？</p><p>我突然感觉到一阵心跳加速，一阵脸红。我赶紧低下了头，不敢再看他。</p><p>是不是我想多了，也许他真的只是想画风铃草而已吧。或许他喜欢风铃草般的女孩子，跟我没有一点关系。或许……或许他根本就——</p><p>从来没把我放在眼里。</p><p>我突然感到一阵心痛，像是被刀刺了一下。我不敢再看他的眼睛，我不敢再听他的声音，我不敢再靠近他的身边。我只想逃离这里，逃离他，逃离自己。</p><p>就这样熬过了一整个上午，而我一整个上午都没有在听课。</p><p>“铃兰，你怎么了？”薰走过来，拍了拍我的肩膀，“你脸色很不好啊。”</p><p>“没……没什么。”我勉强笑了笑，“我只是有点累而已。”</p><p>“累？”薰关切地问道，“我们休息一下，正好，我们一起吃午饭吧。”</p><p>薰把我拉了起来，我跟薰走出了教室，向着室外走去。我回头看了一眼悠太的方向，发现他正看着我。我们的目光在空中相遇，然后又迅速分开。我感觉到我的心又跳了一下，然后又沉了下去。</p><p>这就是我们之间最后的交流吗？这就是我们之间最后的告别吗？</p><p>我不知道。我也不想知道。</p><p>我只想忘掉他。忘掉他的存在，忘掉他的影子，忘掉他的画作。</p><h3 id="4">4</h3><p>“今天天气好像是有点糟糕呢……我还以为早上只是太早了云层有点厚而已呢~”我尝试着找一个话题掩盖此刻的心情。</p><p>“你反应很大啊？”薰看着我有点虚弱的表情，也不忘记嘲笑我，“你该不会以为，那个男生真的是在意你吧？怎么你还不让人家喜欢风铃草了，你也不是风铃草啊。”</p><p>是噢，总不能因为我的名字带着铃，妈妈喜欢风铃草，我就强行占有了这个世界的风铃草吧。我不断这么安慰自己。</p><p>“当然不是，”我赶紧解释，“我没有在想风铃草的事”</p><p>“没有在想风铃草的事？”薰不信地说道，“那你刚才为什么会吓得那么厉害？”</p><p>“我……”我支支吾吾地说道，“我只是觉得很巧合而已。”</p><p>“巧合？”薰反问道，“你觉得这是巧合吗？”</p><p>“嗯，是啊。”我点点头，“这不是很正常的吗？”</p><p>“我的意思是，”薰摇摇头，“他都没有为你做过什么事情，你怎么就以为人家对你有意思。”</p><p>“我也没有这么想。”我忙否认道，“我只是觉得他很有才华。”</p><p>“哦，是这样啊。”薰不以为然地说道，“那你为什么不去告诉他呢？”</p><p>“告诉他？”我吃了一惊，“你是说，告白？”</p><p>“对啊，告白。”薰说道，“你不是喜欢他吗？”</p><p>“我……”我犹豫了一下，“我不知道。”</p><p>“你不知道？”薰无奈地摇摇头，“铃兰，你真是太胆小了。你知道明天结束，你可能再也见不到他了吗？”</p><p>“我知道。”我低下了头，“但是，我怕。”</p><p>“你怕什么？”薰问道，“你怕被拒绝吗？”</p><p>“不……”我摇摇头，“我怕失去他。”</p><p>“失去他？”薰不解地说道，“你本来就没有拥有过，你还能失去什么？”</p><p>“我……”我咬了咬嘴唇，“我怕失去这份感情。这份对他的喜欢，对他的敬佩，对他的思念。如果我告诉他，如果他拒绝了我，或者接受了我，那么这些感情就会消失。就像风铃草一样，随风而逝。”</p><p>“铃兰……”薰轻轻地叹了口气，“你真是太傻了。你知道吗？感情不是用来藏着的，而是用来表达的。如果你真的喜欢他，就应该勇敢地告诉他。也许他也喜欢你呢？也许他也在等你呢？也许你们可以在一起呢？虽然我还是不理解为什么你对他会这么在意。”</p><p>“可是……”我还想说什么，但被薰打断了。</p><p>“没有可是。”薰说道，“铃兰，如果你再不行动，就真的会后悔一辈子的。相信我，你不会想要那样的结果的。”</p><p>“薰……”我看着她真诚的眼神，感觉到她对我的关心和鼓励，但我还是拒绝了薰。</p><p>“还有一天时间呢，让我再好好想想吧”我把头低下来，感觉内心像一场风暴，翻滚着各种矛盾和冲突……</p><p>薰看着我，无奈地摇了摇头，她知道我是个固执的人，不会轻易改变主意的。她只好放弃了劝说我，转而换了一个话题。</p><p>“对了，铃兰，你知道吗？”薰说道，“今天下午有一个画展，好像是一个社团的作品展示。”</p><p>“社团？作品展示？”我稍微把头微微侧倾表示好奇，“绘画社？”</p><p>“是呀是呀，”薰从书包里拿出了一张传单，上面写着“致我们的高中生活”，还有一幅画作的缩略图。</p><p>“去看看吗？”薰说道。我看着薰，从她的脸上看到了非常感兴趣五个大字。</p><p>“去看看？”我疑惑地问道，“去哪里看？”</p><p>“去画展啊。”薰说道，“今天下午三点到五点，在学校的美术馆。我们一起去吧。”</p><p>“快点，快点。”她催促道，“我们还有半个小时就到画展开始了。我们不能迟到。”</p><p>“等等，等等。”我挣扎着说道，“我还没准备好呢。”</p><p>“没关系，没关系。”薰说道，“有我在呢。放心吧，一切都会好的。”</p><p>她带着我跑出了教室，向美术馆的方向飞奔而去。</p><h3 id="5">5</h3><p>我们跑到了美术馆的门口，看到了一排排的人在排队进入。我们也赶紧加入了队伍，等待着进入画展。</p><p>我看了看海报，上面有一幅画作，是一群高中生在校园里欢笑着。他们有的拿着书本，有的拿着乐器，有的拿着画笔，有的拿着球拍。他们的表情都很自然，很快乐，很真实。</p><p>“这幅画是谁画的啊？”我问道，“好厉害啊。”</p><p>“不知道呢。”薰说道，“可能是绘画社的社长吧。他应该是个很有才华的人。”</p><p>“是吗？”我说道，“你对他很感兴趣吗？”</p><p>“不是啦。”薰摇摇头说道，“我只是对他的画感兴趣而已。我想看看他还画了什么。”</p><p>“哦，这样啊。”我说道，“那我们快点进去吧。”</p><p>我们终于排到了门口，进入了美术馆。里面有很多画作，都是绘画社的成员们用心创作的。每幅画都有一个标题和一个简介，介绍了画作的背景和意义。</p><p>我们一边走一边看，不时地发出惊叹和赞美。有些画作让我们回忆起了自己的高中生活，有些画作让我们感受到了别人的高中生活。每幅画都有自己的故事和情感。</p><p>“你看，你看。”薰突然拉住了我的手，指着一幅画说道，“这幅画好熟悉啊。”</p><p>画作是一幅风景画，画面上是一片风铃草田，还有一对男女的背影。男生手里拿着一束浅蓝色的风铃草，单马尾女生则把头靠在男生的肩膀上。两人看起来很恩爱，很幸福。</p><p>我下意识地看了一眼右下角，一边看一边轻声读了出来：“《风铃草之恋》，作者：藤原悠——”</p><p>我突然倒吸一口凉气，感觉后背开始一点点发凉，又像是被谁揪住了一样，接着又觉得非常的不可思议——很自然地用双手捂住了自己的嘴和鼻子。</p><p>“这是……真的……？”我的眼神反复在画布上的内容和右下角的标签之间来回移动，一遍又一遍的确认。</p><p>“这是悠太画的？”薰凑近瞧了瞧，“还真的是！真没想到他还是绘画社的成员，原来他这么有东西！”</p><p>接着薰又用手肘顶了一下我的手臂，“哎哎，你说，他画得是真好，但是他是不是只会画风铃草啊？”</p><p>“但是，”薰说道，“多美啊，多浪漫啊。这就是他对爱情的理想吧。你说，这个女孩会不会就是他喜欢的人呢？”</p><p>我死死地盯着这幅画，感觉到我的心被刺了一下。这就是他心中的风铃草之恋吗？这就是他心中的女孩吗？那么，我在他心中又是什么呢？</p><p>“喂，喂！”，薰突然摇了一下我，“姐妹你别傻愣着鸭！开麦！开麦姐妹！”</p><p>“啊……啊！”，我突然如梦惊醒，扭头看了一眼薰，“没……没什么事……画得很好……是……看起来很幸福…嗯…对……”。我低下头，仿佛在想什么事情，又什么都没想。</p><p>“铃兰，你在说什么啊？”薰摇摇头说道，“你今天怎么了？”</p><p>“没有”，我非常轻声的回答了薰的问题，但这个声音已经微小到似乎仅仅是通过骨传导传递到我的耳朵而已。</p><p>“你觉得这个女孩，会是你吗？”薰挽着我的手，头微微低下，似乎在尝试观察头发背后的我此刻的表情。</p><p>我突然猛地一抬头，“什么？我？女孩？我？”</p><p>“是啊！”薰微微靠在我的肩上，“老师给我们的那道题，他画了风铃草。现在放在眼前的这幅画，内容也是风铃草……”</p><p>“其实我总是嘴上说说，但是我能感觉到，他可能对你有意思。”薰的头突然离开了肩膀，微微地晃动了一下，又贴到了肩上，“其实我都看到好多次，他总是在不经意间偷偷看你，又突然地甩断视线……”</p><p>我听着薰的话，心里一阵乱糟糟的。我真的很喜欢悠太，但是我从来没有勇气告诉他。我只是默默地关注着他，欣赏着他的才华，羡慕着他的自信。</p><p>我以为他心里有别的女孩，也许是那些漂亮的，聪明的，活泼的女孩。我以为他和我之间，只有风铃草这一点微不足道的联系。不，他不知道我的名字跟风铃草有关系，这根本不是联系。</p><p>“你说得对。”我终于开口说道，“这幅画真的很美，很浪漫。这就是悠太对爱情的理想吧。”</p><p>“那你呢？”薰问道，“你对爱情的理想是什么？”</p><p>“我……”我犹豫了一下，“我想……和喜欢的人在一起……就好了。”</p><p>“那你想好了没有？”</p><p>“想好……想好什么？”</p><p>这时薰的头彻底离开了我的肩膀，直勾勾的盯着我，“去做你想做的事！”</p><p>“可是……”我还想说什么，但是被薰打断了。</p><p>“别可是了。”薰重复道，“你要抓住机会啊。”</p><p>“可是……”我还想说什么，但是被薰拉着就往画展的出口走去。</p><p>“我们去哪里？”我问道，“不看了吗？”</p><p>“还看什么画展啊。”薰说道，“你都不是很想继续看了，我们回去找他啊。”</p><p>“找他？”我惊讶地问道，“找他干什么？”</p><p>“找他告白啊。”薰说道，“你不是喜欢他吗？你不是想和他在一起吗？”</p><p>“我……”我瞪大了眼睛，不敢相信自己的耳朵。</p><p>“你怎么了？”薰看着我，一脸的不解。</p><p>“你……你让我去告白？”我结结巴巴地问道，“你是认真的吗？”</p><p>“当然啦。”薰说道，“这不是很正常的吗？”</p><p>“不……不正常啊。”我说道，“这太突然了啊。我怎么能去告白啊。”</p><p>“为什么不能呢？”薰问道，“你有什么顾虑吗？”</p><p>“顾虑？”我说道，“顾虑太多了啊。万一他拒绝我怎么办？万一他嘲笑我怎么办？万一他觉得我很烦怎么办？万一他已经有喜欢的人怎么办？”</p><p>“哎呀，你想太多了。”薰说道，“你要有点自信啊。你又不是没有优点，你又不是没有魅力，你又不是没有人气。你为什么要自卑呢？”</p><p>“可是……”我依然被薰再次打断。</p><p>“画展先看到这吧，我们回教室。”</p><h3 id="6">6</h3><p>我们从美术馆出来，看到天空突然下起很大的雨，我们急忙跑到一个屋檐下，躲避着雨水。雨水顺着屋檐起伏间的缝隙，成股地滚了下来，重重地砸向了地面。</p><p>“哎呀，怎么会突然下这么大的雨啊。”薰抱怨道，“我们没有带伞啊。”</p><p>“是啊。”说完便观察周围的情况，看看能不能找到一条不会淋雨的路线回到教室。</p><p>“有了！”我突然喊了出来，“我们可以先沿着这个建筑边缘走，然后再穿过这个通道，中间可能有一点点路会淋到，但应该没问题。你可以吗？”</p><p>“我可以！我们先这样吧，先回到教学楼再想想怎么回家。”薰点了点头表示同意我的建议。</p><p>“那我们先这样，跑起来！”</p><p>我们跟着我的计划，沿着建筑边缘跑去，但是雨越下越大，我们的衣服和头发都被打湿了。我看了看薰，她的脸上有些苦恼，但也有些兴奋。她的眼睛在雨中闪闪发光，像是一颗星星。</p><p>“你没事吧？”我关心地问她。</p><p>“没事，就是有点冷。”她笑了笑，“不过这样也挺有意思的，就像是冒险一样。”</p><p>“是啊，我们好像是在逃亡。”我也笑了起来，“不过我们要快点，不然会感冒的。”</p><p>“嗯。”她点点头，加快了脚步。</p><p><strong>我们终于穿过了通道，来到了教学楼前。教学楼是一座四层的建筑，外墙是白色的，窗户是蓝色的。教学楼的门口有一个大大的屋檐，可以遮挡雨水。我们跑到屋檐下，松了一口气。</strong></p><p>“太好了，我们终于到了。”我说。</p><p>“是啊，真是太幸运了。”薰说，“不过我们现在怎么办？我们都湿漉漉的。”</p><p>“对啊。”我看了看自己的头发，“不过还好，我们先回教室休息，再找找有没有什么东西可以擦干。”</p><p>我们沿着走廊向教室走过去，当我们走到门前，只见到有一个身影正从我们教室里打算出来。“看，是连，他来我们教室干什么？”薰拽了拽我并朝前指了一下。</p><p>有点被打湿的我看到连之后感到愈发的寒冷，心想：“他来干什么啊！”</p><p>“钟同学，山本同学。你们？”连看到我们之后，一脸诧异，“你们是淋雨了吗？你们没事吧？”</p><p>接着连一个箭步闪现到一个课桌前，迅速地抄起了桌子上的毛巾，朝我们走了过来。</p><p>连把毛巾掸开，接着对折了一遍。然后一手抓住毛巾，打算朝着我的头发扑过来。</p><p>我下意识地躲闪了一下，“请不要这样，我自己来，把毛巾给我就好”。连微微笑了一下，放下举过我头顶的手，并把毛巾递到我的面前，“给~”</p><p>我迅速接过毛巾，又把毛巾摊开，熟练的将毛巾包住自己的头发，稍微用力搓了一下。</p><p>“好香”，应该是包住头发的一瞬间，挤压出了原本停驻在毛巾间的空气，顺带着毛巾散发出来的淡淡的清香。我一边一边搓着自己的头发，一边重新回溯毛巾是从哪张课桌拿过来的。</p><p>“给，你也要擦一下”，我把毛巾递给了薰。薰接过毛巾，照着我的动作又重复了一遍。</p><p>“谢谢你”，我低头向着连说道，同时心里又很担心他又要“故技重施”。</p><p>“你也太贴心了叭！”薰擦完头发之后，小心翼翼的把毛巾对折一遍，又对折一遍，变成一块小方块，想要还给连，“你怎么会想到给我们准备毛巾！”</p><p>“不客气。那个”连注视着我，仿佛又要说出那句。</p><p>“不，先别”我及时打断了连，“如果你还要说‘喜欢我’之类的话，不好意思，对不起”</p><p>“好吧，你还是拒绝我了吗？”连看着有点失望。</p><p>“我不能马上回答你，不好意思”我把整个身子扭向了一边，面对着白色墙壁。</p><p>“好吧，我先走了，你们要小心，不要感冒”，说完，连离开了教室。</p><p>薰把我转了过来，刚要开口，我打断了薰。</p><p>“我知道你又要说教我了，你这次想说什么？”我摆脱了薰的手掌，缓慢向我的座位走去。</p><p>“你真的……你真的”，薰顺势将手托住自己的脸颊，“我真的……我真的……”</p><p>“行了，我明白的”，当我走到我的座位旁，正要坐下时，看到课桌靠窗的一边，倚着一把雨伞。</p><p>“这是谁的雨伞？”我把伞拿了起来看了一眼，接着我突然灵光一闪，想到了毛巾，“毛巾呢？薰，毛巾在你那吗？”</p><p>薰把毛巾递了过来，“我是真的佛啦，铃兰，你是真 NB 啊，你真该死啊！”，薰好像有点要急哭了的样子，“你要是不稀罕舔狗，能不能让他舔舔我啊！”</p><p>“你在说什么啊！！！”我冲着薰喊了一声。没想到薰竟然突然对我是这个态度，我突然感到有一丝失望，顺手把毛巾抽回来。</p><p>“人家给你送毛巾，给你准备雨伞，你却这样对人家”，薰突然就哭了起来，“我真的……我看着好心痛，连真的好可怜……可怜的汤姆猫……”</p><h3 id="7">7</h3><p>“毛巾确实是从我桌子上拿的……”，我边回忆边念念有词，“伞和毛巾，到底是谁放在我桌子上的？”</p><p>此时教室里除了我们，没有其他人。教室也非常干净，黑板被擦得一点粉笔痕迹都没有，甚至还在反光，感觉能隐约看到我们的影子。窗户也紧闭着，只能透过窗户看到灰蒙蒙的天，以及雨水努力敲打玻璃发出清脆的声音。白色的窗帘也不会摆动，一切就像时间凝固了一般。</p><p>“还能有谁！当然是连拿过来的啊！你想一下刚刚除了我们俩，还有谁！”薰冲着我又嚷了一声，接着又软了下来，嘴里小声念叨着，“多好啊……多好啊！！！”</p><p>我起身走到薰的身边抱住了薰，试图让薰冷静下来，“好了，是我不好”。</p><p>“铃兰，你怎么能这样呢？”薰再一次责备我，用了跟早上一样的话语。但这次是抽泣的。</p><p>“我不想让他产生误会。”我小声的在薰耳边说，一边用手擦拭薰眼角上的泪痕。</p><p>“我不说了，我不说了，我什么都不想说了。”薰抬起头，用力吸了一下鼻子，“如果我是你的话，就好了。”</p><p>“我们先回家吧”，我拿着伞和毛巾。心想着，先把毛巾带回去洗干净，烘干。明天再连同雨伞一起带过来，看看是谁的吧。</p><p>于是，我手里拿着毛巾，然后挽着薰的手臂，另一只手拿着雨伞，带着她离开了教室。</p><p>我们走出了教学楼，来到了校门口。雨还是没有停，但是没有刚才那么大了。我打开了雨伞，为我们遮挡着雨水。薰紧紧地挽着我的手臂，靠在我的肩膀上。我能感觉到她的呼吸和体温，让我心里一阵暖意。</p><p>我们一起走出了校门，向东边走去。路上，我们没有说话，只是默默地感受着彼此的存在。我不知道她在想什么，也不知道自己在想什么。我只知道，这一刻，我很幸福。</p><p>看着走了三年的小路还是坑坑洼洼，路过的街道还是这么吵吵嚷嚷……</p><p>“还有两次”</p><p>“嗯？”薰贴着我，发出了娇贵的声音。</p><p>“我说，这条路，我们可能只会再多走两遍了。”我也靠着薰说道。</p><p>“嗯……”</p><p>我们就这样相互依着往前走，感觉走了没多久，眼帘里映入最熟悉的围墙，我到家了。</p><p>“你可以吗？薰？”我把手从薰的手臂间抽了出来，又很迅速地牵住了薰，“剩下的路，你可以自己走吗？”</p><p>“我可以的”薰伸手想接过雨伞，“你回家吧，我们明天见。”</p><p>我把伞转移给薰，自己跑回了家里。在家门口屋檐下转了个身，朝着薰挥了挥手。</p><p>“我回来了”，边脱鞋边跟家里打招呼，但好像家里也没有人。</p><p>我穿过了门厅，来到院子前。外面的风真的好大，门外的风铃草正在坚强地承受雨的洗礼，在努力的对着风向摆动自己，试图也想让自己平静下来。</p><p>雨敲打地面的声音，横风掠过的声音，以及顽强抵抗横风的风铃草，清脆的撞击声……各种声音在我的耳边，持续回响……</p><p>“风铃草，到底是什么意思？铃兰跟风铃草有没有关系？妈妈到底是想要让我知道什么？”我蹲了下来，抱住自己的腿，看着风铃草，陷入了沉思……</p><h3 id="8">8</h3><p>终于。</p><p>毕业典礼当天，还是到了。</p><p>还是像往常一样起了一个大早，像往常一样洗漱，像往常一样穿上自己的校服。</p><p>不过，这是最后一天穿校服了。</p><p>一切准备就绪，来到家门口。还是像往常一样在门口等着薰的出现。</p><p>阳光穿过薄薄的云层，穿过还未消散的雾气，像圣光一样照射在即将去学校的路上。</p><p>“铃兰——早上好——”，声音越来越近，借着一缕清香传递到我的耳中。“早上好，薰”我冲着她招了招手。</p><p>等到薰走到身边，我马上挽住薰的手臂。今天不管怎样，我都想这样走去学校。</p><p>“你今天的发带真好看，你还是这么喜欢浅蓝色呢”薰一边盯着我的发带一边说到，“但是你今天，竟然扎在头发上了！”</p><p>“单马尾的你，好可爱啊！！”，薰一边走一边用脸蹭着我的肩膀。</p><p>我们还是这么互相依着，踏着路面被风雨打下来的樱花，继续往前走。</p><p>“真不敢相信，我们就要毕业了。”薰叹了口气，“我们可能就此分开了，你会不会想我呢？”</p><p>“当然会啊。”我紧紧地挽着薰的手臂，“你是我最好的朋友，我怎么会不想你呢？我们以后还可以保持联系啊，还可以见面啊，还可以一起玩啊。”</p><p>“是啊，是啊。”薰点点头，“我们一定要保持联系，一定要见面，一定要一起玩。我们永远都是最好的朋友。”</p><p>“对啊，对啊。”我附和着说，“我们永远都是最好的朋友。”</p><p>我们就这样走着走着，不知不觉到了校门口。今天的校门口格外热闹，很多同学都提前到了学校，有的拿着相机拍照留念，有的拿着卡片写下祝福语，有的拿着花束准备送给喜欢的人。</p><p>“毕业典礼马上就开始了，我们先去体育馆吧。”我拉着薰，穿过人群，朝着体育馆走去。</p><p>我们穿着校服，戴着毕业帽，坐在体育馆的座位上。台上是校长和老师们，他们正在发表着毕业致辞，祝贺我们的成绩，鼓励我们的未来。台下是我们的同学们，他们有的在认真地听着，有的在偷偷地聊着，有的在悄悄地哭着。我看了看身边的薰，她也看了看我。我们都没有说话，只是微微地笑了笑。我们的眼神里，有着无尽的情感。</p><p>毕业典礼结束了，我们拿到了毕业证书，和老师们握手道别。然后，我们走到了操场上，和同学们拍照留念。我们拍了班级合影，社团合影，好友合影。我们拥抱着彼此，说着感谢和祝福。我们流着眼泪，笑着说再见。</p><p>“铃酱，我不想离开校园！”薰眼巴巴的看着我，感觉又要哭出来了，“我真的好舍不得学校，舍不得这段时光，舍不得你……”</p><p>说实话，我也很留恋这三年时光，这里有我最美好的回忆，最珍贵的友情，最深刻的感情。我也不想离开这里，不想离开他们，不想离开他。</p><p>但是我不想继续再多待一秒，因为……</p><p>“薰，结束了，我们回去吧”，我看着薰，此刻的我不知为何能做到如此冷血，说出这番话。</p><p>“我不！我不要！”薰向后退了一步，用力的摇了摇头，“我真的好舍不得，我想去多拍一些照片，我想去我们第一次上课的地方，我想去音乐室，我想……”</p><p>“那我在校门口等你好吗？”我打断薰的话语，并看着薰，眼睛发出渴求的信号，心里一直想着，千万要接收到并能理解。</p><p>“好…好吧……”薰不舍地说道，“那你要等我噢！无论如何要等我噢！！！”，接着薰回头，一头扎进楼里。渐渐的，看不到人影。</p><p>我也回头，朝着校门口走去。“我就站在门口等着薰回来吧”，边走边这么想着。</p><p>当我走出大门，看到写着学校名字的铭牌前站着一个人。</p><p>“是悠太！他怎么站在这里！”我突然感觉自己的心率正在飞快上升，又快一点，再快一点……</p><p>悠太笔直地站在校门口，仿佛在等着谁。</p><p>“那是什么！”我看到了悠太，背在身后的手上，似乎拿着什么东西。</p><p>“风……风铃草！？”我突然感到一丝窒息感，“为什么？他在这里干什么？他在等他喜欢的人出现吗？”</p><p>悠太好像看到了我，笔直地朝我走了过来。</p><p>“怎么办怎么办怎么办怎么办怎么办怎么办怎么办”我不知道自己该干什么，但是他正在一步步逼近，我应该怎么办，我束手无策。</p><p>“钟铃兰……”，悠太开口了。</p><p>“啊，啊！”我抬头看了一眼悠太，“你也，你也太失礼了吧藤原同学！你怎么能直接叫人家的姓名！”</p><p>“对不起，你在等人？”</p><p>“嗯……我在等薰。”我说。</p><p>“薰？”他有些惊讶，“她还没走吗？”</p><p>“她还想去看看学校。”我说。</p><p>“哦，这样啊。”他说，“那你们……你们要一起回家吗？”</p><p>“是的。”我说，“我答应了薰，我们要一起走回家，最后一次。”</p><p>“你……”他欲言又止，似乎有什么话想要说，又不敢说出来。</p><p>“我什么？”我问。</p><p>“你……你喜欢我吗？”</p><p>他终于说出了那句话。</p><p>“我……我……”我感觉到我的脸正在变得越来越热，我不知道该怎么回答。我下意识地很想用手扇扇自己的脸散热，但我不敢。我的心里有千言万语，却说不出一个字。</p><p>“对不起，我向你道歉。是我冒犯了。”悠太低下头，扭捏了一下，“那个……嗯……”</p><p>悠太把双手从后面移向了前面，双手捧着一束花。是浅蓝色的……是风铃草。</p><p>“我猜你有所疑惑”，悠太解释道，“你想说，现在根本没有风铃草。是的，现在确实还不到风铃草的花期。”</p><p>我的大脑一片空白，我不知道他想干什么。</p><p>“其实我一直在偷偷喜欢着你，但是我又很害怕。我知道，我在别人眼里，是一个没有朋友的怪人，所以我怕。”悠太换了个姿势，继续说道。</p><p>“我一直想表达我的心意，但是如果被拒绝了，这些感情就会消失。就像风铃草一样，随风而逝……”</p><p>“可是，如果毕业了我都不能说出我想说的话，我可能会一直后悔下去，后悔一生……所以我给自己一个期限，也在逼迫自己，不管怎样，即使毕业了，我也要在毕业当天，说出我的想法。你真的很好……”</p><p>悠太突然牵扯住我的眼神，我好想躲开，但又忍不住建立起联系。</p><p>“你很温柔，你对其他同学非常好，你也总是先想着别人……你很勤奋，我经常看到你在那家面包店打工，你在前台对着客人的甜美的微笑，让我内心感到治愈……你很坚强，体育课的长跑项目，你不小心摔倒了，还坚持站起来，走着也要走完全程……”</p><p>“我真的，我只能默默为你做点事情，虽然你也许永远都不会知道，那些是我做的。”</p><p>“这么说！！！”我突然恍然大悟，眼睛里突然有些温热，“不会是！昨天毛巾和雨伞？！还有之前的那些—— 我以为——”</p><p>“其实还有一些，”悠太的突然脸也红了起来，“总之，当你需要的时候，我就会在。”</p><p>“好吧，就到这里吧。这个送给你”，悠太双手捧着风铃草，递到我的面前。</p><p>我接过了风铃草，刚想开口。</p><p>“以后我们应该还会再相见吧，如果可以的话。祝福你，祝你在大学生涯里继续追逐你的梦想。”，说完，悠太转过身，准备离开。</p><p>“藤……悠太！”我叫住了他。</p><p>悠太回头看了一眼，微微一笑，“还有什么事吗？”</p><p>“那个……”我犹豫了一下，不知道该怎么说，“对了，如果毛巾是你的……”</p><p>我赶紧放下包，找到那条白色的毛巾。它已经失去了原本的味道，现在跟我衣服的味道一模一样。</p><p>我拿着毛巾追了上去，递给悠太。“这是你的毛巾，我希望你能收下。”</p><p>悠太微微一笑，收下了毛巾，并礼貌性地点了下头，然后回头想继续走。</p><p>“还有！！”我再一次叫住了悠太。</p><p>“还有什么事吗？”</p><p>“还有……”我把花束换到了自己的左手，并举起了自己的右手，向前伸去，手背向上，手指尖向下压低了15度……</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>看了一个 b站 视频，一个知乎回答，还有一个不知道是什么打不开 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ChatGPT </tag>
            
            <tag> AI </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重新学习 JavaScript</title>
      <link href="/blog/2023/02/14/relearn-javascript/"/>
      <url>/blog/2023/02/14/relearn-javascript/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是一篇视频稿（Final Cut 爆炸了所以没去薅叔叔）</p></blockquote><p>孔子曾说：</p><blockquote><p>“温故而知新，可以为师矣”</p></blockquote><p>Confucius 曾经也说过：</p><blockquote><p>“When reviewing old knowledge, you can have new experiences and discoveries, and you can be a teacher.”</p></blockquote><p>意思就是：经常翻看以往学过的知识，一般总能学到新知识。这样就可以可持续性当你爹（？</p><p>想一想，从 16 年到现在一直用 <code>TypeScript</code>，至今已经成为主流。在今天这个大好日子，我决定听孔子一回，重新学习 <code>JavaScript</code></p><p>并且，孔子还说过：</p><blockquote><p>知之者不如好之者，好之者不如乐之者</p></blockquote><p>所以我决定邀请各位，请让你<strong>身边</strong>的人一起学</p><span id="more"></span><h2 id="环境">环境</h2><p>虽然直接使用浏览器方便一些，但我们现在应该本地都有一个 <code>node</code>，这可能对我们来说更为方便。顺便的可以温习一遍简单的 <code>File IO</code>，毕竟这是几乎所有语言入门都需要接触的部分</p><p>本文环境配置如下：</p><ul><li>OS：最新最时尚最卡的 MacOS Ventura</li><li>node: v16.13.2</li></ul><h2 id="基本类型">基本类型</h2><p><code>JavaScript</code> 是一款“函数式” <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup> 解释型脚本语言，所以这部分我们可以使用 Node REPL</p><p>打开终端，输入这个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node</code></pre><p>首先是基本类型：<code>JavaScript</code> 有<strong>三种</strong>基本类型：<code>string</code>, <code>number</code>, <code>boolean</code></p><p><code>string</code> 叫字符串，如果有其他编译型语言经验的话可能一时会觉得奇怪，但在 <code>JavaScript</code> 没那么讲究，字符串就是基础类型</p><p>字符串由一对引号包起来，也没那么多讲究 —— 单引号双引号都可以</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &#39;I love you&#39;&#39;I love you&#39;&gt; &quot;I love you, too&quot;&#39;I love you, too&#39;</code></pre><p>如果你的字符串出现了必要的单引号（例如 do not 的缩写），这时为了避免歧义，应该用一种引号（双引号）来作为语法识别，这样字符串内就可以使用另一对引号（单引号）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; &quot;I don&#39;t hate you&quot;&quot;I don&#39;t hate you&quot;</code></pre><p><code>number</code> 叫 number，数字，同样也没那么多讲究 —— 不分 32 位 64 位，不分整浮点，甚至双精，甚至 <code>decimal</code></p><p>配合一些基本的操作符（operators），我们可以把 REPL 作为计算器使用</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 1+12&gt; 1*11</code></pre><p>计算机的世界，计算没有大括号（{}），没有中括号（[]），只用小括号表示优先级，嵌套越深则越优先。举个例子</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 4 * (40 - (2 - 12) + 40 * 2)520</code></pre><p>这个时候你再试试除以 0。不过我们小学都学过，除法里是不能除以 0 的。但是学编程，就是要敢猜敢试。放心，不会起火</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; 520 &#x2F; 0Infinity</code></pre><p>看，尝试得到了新的理解。这个式子也许对你还有另一种含义：<strong>爱与无限之间，只有一个「无条件」</strong></p><p><code>boolean</code> 指布尔值，指一对真实反义词，例如对和错，真和假，0和1。通常用在逻辑分支</p><p>计算机是严格的，对就是对的，错就是错的。<strong>但你们之间，没有绝对对错</strong></p><p>懂行的人别急，确实还有两种：<code>undefined</code> 和 <code>null</code>，它们一般情况下指「没有」，但他们严格来说不是一个意思：<code>null</code> 指这个值是空的，但本身也是一个值；<code>undefined</code> 是真的没有，且未知</p><p>就像你现在问你身旁的人问你今天有没有想TA，你回答 “没有”。虽说可能真的没想你，但其实心里还有你</p><p><strong>而有些人想都没得想！</strong></p><h2 id="函数">函数</h2><p>在复习函数之前先随便复习一下定义变量</p><p>严格 ES6 之前我们只会用 <code>var</code>，但如今我们都默认有两种定义方式：<code>var</code>, <code>let</code>，还有一种定量定义方式：<code>const</code></p><p>变量指定义之后，值还能改；定量指定义之后，值无法修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var lovedGame &#x3D; &#39;League of Legends&#39;lovedGame &#x3D; &#39;JX Online 3&#39; &#x2F;&#x2F; 世界上最好的 MMORPLGconst lovedOne &#x3D; &#39;You&#39;lovedOne &#x3D; &#39;Her&#39;&#x2F;&#x2F; Uncaught TypeError: Assignment to constant variable.</code></pre><p>严格讲，<code>var</code> 和 <code>let</code> 有一点区别，<code>let</code> 有声明使用顺序（死区）<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>和作用域限制，换句话说更“安全”，所以现在对于新手来说，无论如何优先使用 <code>let</code></p><p>接下来到函数，一般声明一个函数会有两种方式，一种是正常的函数声明，一种是基于语言特性的声明</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 1.function fn() &#123;&#125;&#x2F;&#x2F; 2.const fn &#x3D; () &#x3D;&gt; &#123;&#125;</code></pre><p>第二种其实就是一种「把函数也当做一个变量/定量」的思路，具体区别不展开<sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>调用一个函数很简单</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fn() &#x2F;&#x2F; 函数有参数就照着传</code></pre><p>Ok，小节实践，尝试以下函数并调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function calc(n) &#123;  return ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n&#125;&#x2F;&#x2F; 也可以这么写，是不是更帅了const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * n</code></pre><p>（可以在 REPL 运行）</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; const calc &#x3D; n &#x3D;&gt; ((n + 52.8) * 5 - 3.9343) &#x2F; 0.5 - 10 * nundefined</code></pre><p>REPL 是这样的，输入的下一行永远是返回值。接下来输入调用看看</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">&gt; calc(1)520.1314&gt; calc(51)520.1314&gt; calc(564)520.1314</code></pre><p>你们也是这么简单纯粹吧 —— <strong>不要总问是不是变丑了，不管你变成怎样，都会一直爱你</strong></p><h2 id="实践">实践</h2><p>接下来就不用 REPL 了，因为接下来想整 <code>Network</code> 和 <code>File IO</code>。纯 <code>JavaScript</code> 这个语言是不带 IO 实现的</p><p>这一次就随便练一下写文件好了，我们的目的是：获取一个网络上的资源，并写下来</p><p>首先创建一个文件，就叫 <code>love.js</code>，随便放在你能找到的地方</p><p>先定义一些变量，照着复制就完事了</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const fileName &#x3D; &#39;love.txt&#39;</code></pre><p>接下来是引入一个<code>fs</code>包</p><p>由于现在已经是 <code>import/export</code> stable 的时代，所以包引用哪种都可以</p><p>但如果使用 <code>module</code> 模式的话需要将 <code>package.json</code> 的类型更改为 <code>module</code></p><p>我们直接执行，也不引入 npm 概念，所以我们这里用 <code>CommonJS</code></p><p>在最顶上（<code>fileName</code> 的上方）写入</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 文件系统const fs &#x3D; require(&#39;fs&#39;)&#x2F;&#x2F; 路径模块（用于系统各种跟路径相关的工具）const path &#x3D; require(&#39;path&#39;)&#x2F;&#x2F; 网络const http &#x3D; require(&#39;https&#39;)</code></pre><p>接着我们在最开始写的变量（<code>fileName</code>）下面新增一行</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 将要保存文件的路径（自动拼接绝对路径）const currentDir &#x3D; path.resolve(__dirname, fileName)</code></pre><p>然后是网络请求，我们一般都会封装成一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  http.get(    &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,    res &#x3D;&gt; &#123;      let data &#x3D; [];      res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;        data.push(chunk);      &#125;);      res.on(&#39;end&#39;, () &#x3D;&gt; &#123;        return data.toString()      &#125;);    &#125;)&#125;</code></pre><p>最后一行写上文件写入就行啦（注：这个示例跳过错误边界）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request())</code></pre><p>接下来在终端运行它吧！</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">node .&#x2F;love.js</code></pre><p>然后报错了！</p><p>这个时候我们应该学会看错误，这也是编程的基础。<strong>有错就说明清楚，然后调整，这样才能和谐相处</strong></p><blockquote><p>The “data” argument must be of type string or an instance of Buffer, TypedArray, or DataView. Received undefined</p></blockquote><p>这里说的是获取到一个 <code>undefined</code>，这个是不支持写入的</p><p>Actually，我们会给一个未知变量做边界控制，这里简单的直接短路吧<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, request() || &#39;&#39;)</code></pre><p>这个时候不报错了，我们去看一下这个目录下生成的 <code>love.txt</code> 文件吧！</p><p>当我们兴奋地打开之后发现，<strong>这是一个空文件</strong></p><p>千万不要想着「我的努力我的付出，得不到回应」</p><p>不要灰心，学习编程的过程就是不断发现问题，不断解决问题。<strong>感情也是如此</strong></p><p>但我们要的不是对「你错在哪儿了？」进行一个精准的回答，而是 <strong>code review</strong></p><p>通过 review 我们会发现，<code>request</code> 写错了 —— 异步函数在这里不能直接获取返回值</p><blockquote><p>异步编程技术使你的程序可以在执行一个可能长期运行的任务的同时继续对其他事件做出反应而不必等待任务完成。与此同时，你的程序也将在任务完成后显示结果。</p></blockquote><p>而网络对于一个 node 程序来说，就是一个异步工作</p><p>发现问题，开始解决问题</p><p>对于异步工作，我们总会很习惯的使用 <code>Promise</code> 来解决「回调嵌套」问题，使得代码看起来「同步」，而且可以非常直觉的处理「返回值」。换句话说，就是把整个函数的调用都放进了异步队列</p><blockquote><p>Promise 是现代 JavaScript 中异步编程的基础，是一个由异步函数返回的可以向我们指示当前操作所处的状态的对象</p></blockquote><p>所以，对 request 进行修改吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function request() &#123;  return new Promise(resolve &#x3D;&gt; &#123;     http.get(      &#39;https:&#x2F;&#x2F;colmugx.github.io&#x2F;blog&#x2F;file&#x2F;h.txt&#39;,      res &#x3D;&gt; &#123;        let data &#x3D; [];        res.on(&#39;data&#39;, chunk &#x3D;&gt; &#123;          data.push(chunk.toString())        &#125;);        res.on(&#39;end&#39;, () &#x3D;&gt; &#123;          &#x2F;&#x2F; 文件里有被转义的换行符，这里转回来          resolve(data.toString().replace(&#x2F;\\n&#x2F;g, &#39;\n&#39;))        &#125;);      &#125;)  &#125;)&#125;</code></pre><p>同时，「文件写入」语句也要做相应的修改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">fs.writeFileSync(currentDir, await request() || &#39;&#39;)</code></pre><p>这个时候再执行一遍！同样没有报错</p><p>但这一次不同了，当我们再一次打开 <code>love.txt</code> 文件时，我们会看到</p><p><img src="/blog/Image/heart.webp" alt="heart"></p><p>所以说，爱有时候也应该像这样：<strong>长久的爱与互相理解，建立在承诺(promise)和等待(await)</strong></p><p>我们已经约好了一直走下去的呀，等一会又怎样嘛</p><p>END -</p><p>（其实如果你有留意到这篇文章分类是在「动物园」下，或许早就知道了）</p><h2 id="Links-2">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://www.zhihu.com/question/266495749/answer/309719982">如何用数学的方法表白? - 知乎</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Introducing">异步 JavaScript 简介</a></li><li><a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Learn/JavaScript/Asynchronous/Promises">如何使用 Promise</a></li><li>本博客</li></ul><p>真是温故知新啊，看看这个引用区 ↓</p><p>全都是年轻不懂事的自己，瞎几把写</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>JavaScript 可以是函数式语言，但是极端还是存在争议，这里过分严谨一些 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我今天给 let 安排了 · Colmugx 's Blog</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a href="/blog/2018/07/04/different-function/">我就写个方法，这么麻烦？ · Colmugx 's Blog</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p>剧本味也太重了草，事已至此只能做一个违背祖宗的决定了 <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>田旗插在苹果上但没插好 —— MAUI + MusicKit</title>
      <link href="/blog/2023/02/07/maui-musickit/"/>
      <url>/blog/2023/02/07/maui-musickit/</url>
      
        <content type="html"><![CDATA[<p>众所不周知，在大概 3 4 年前曾经有这么一个项目叫 <code>sona</code>，这是一个音乐播放器，<code>react native</code>，连着网抑云。大概长这样</p><p><img src="/blog/Image/sona-v1.png" alt="sona"></p><p>过了这么久，我早就不网抑云，也以现在的眼光再看这个 UI 未免有些稚气，还有点费电资源 —— 整的什么垃圾</p><p>正好，关注了一年多的 <code>MAUI</code>，纯纯在 Build 看着宣布，然后 GitHub 开库，进 preview，到现在 stable。.NET 都从 6 preview 一直到 7…</p><p>所以先来搂一眼，正好也想复活这个产品，并且不优先解决网抑云，而是解决 Apple Music 和 Spotify，还有 <a target="_blank" rel="noopener" href="http://Last.fm">Last.fm</a>。再决定是改用 maui 重构还是继续用 RN</p><h2 id="TL-DR-8">TL;DR</h2><ul><li>C# 很香，但遗传了 Xamarin 的臭</li><li>安卓 SDK 两个包，噶了一个</li><li>平台能力最好还是用平台原生语言</li><li><strong>目前的 MAUI，狗都不用</strong></li></ul><span id="more"></span><h2 id="MAUI">MAUI</h2><p>一句话：MAUI 是另一个 React Native 但 C#，<strong>不是 Flutter</strong></p><p>MAUI 前面有 <code>Xamarin</code>（分平台的不是 <code>Xamarin.Forms</code>），服就服在<strong>微软能把各个平台的 API 都转一份</strong>，这样所有代码都使用 C# 编写，以便享受这个极其变态的编译器。当你创建一个 mac 的 Xamarin 应用，你会发现除了语法是 C#，无论结构还是文件组织都与直接用 XCode 创建出来的项目不能说有点相似，只能说完全一致</p><p>高情商：令人钦佩的软件工程能力；低情商：吃饱了撑着</p><p>所以作为后继者，MAUI 在平台调用依然会是全 C#，不像 flutter 或者 RN 在分别平台使用 swift/kotlin。这样有好坏</p><p>好是因为全 C#，在编写平台逻辑时可以直接使用通用的 <code>interface</code>，或者是 common 写一个 <code>partial</code>，再分平台补充实现。即使在通用代码也可以用 macro 来区分平台生成代码，毕竟不用担心，编译会根据编译目标选择源代码</p><p>坏那也坏，RN 和 flutter 的方式是让平台代码完全使用平台程序，相当于写了一个原生程序，通过桥通信交换信息，这样可以保证平台逻辑是绝对的平台逻辑，《非常原生》。而反过来就是 MAUI 的缺点，谁也不知道到底这个翻译官水平如何</p><h2 id="MusicKit">MusicKit</h2><p>WWDC21 宣布了 <code>MusicKit</code>，WWDC22 宣布了<strong>其他平台</strong>的 MusicKit SDK 和 Apple Music API，至此 Apple Music 可以在其他平台集成，包括 Web</p><p>只不过，据我所知，Apple Music API 和 MusicKit Web 只有很普通的音质，没有 ALAC，没有 Dolby Atmos，其实后者没有应该不奇怪</p><h2 id="Combine">Combine</h2><p>按照平台分，方案如下：</p><ul><li>iOS/iPadOS：系统带着了，直接写，可以参考 <a target="_blank" rel="noopener" href="https://github.com/xamarin/ios-samples/tree/main/ios11/MusicKitSample">Xamarin.iOS 的示例</a></li><li>Android: 使用官方 SDK，一共两个 aar</li><li>其他：只能封装 Apple Music API</li></ul><p>这个项目在 RN 的时候也仅考虑 iOS 和 Android。这次会考虑新增 iPad 和桌面端，但无所谓</p><h3 id="Create-Library-s">Create Library(s)</h3><p>如果按照 React Native 的习惯，可能会创建一个插件项目，接着分别在对应位置做平台实现。但，<code>Xamarin</code> 似乎不是这么做的</p><p>首先需要创建两个 Binding 项目：<code>Android Bindings Library</code> 和 <code>iOS Bindings Library</code></p><p>毕竟只是概念验证，所以这次不实现 iOS，先试试 <code>aar</code> 绑定。这里可以参考微软文档 <a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></p><p>在安卓，Apple Music 提供了两个 <code>arr</code>：</p><ul><li>mediaplayback：Apple Music 部分，用于获取专辑，音乐信息等</li><li>musickitauth: MusicKit 的验证部分（例如直接使用本地的 Apple Music 进行授权，类似通过 QQ 登录）</li></ul><p>一个一个来</p><h3 id="Droid-MusicKit-mediaplayback">Droid.MusicKit - mediaplayback</h3><p>（似乎 Xamarin 的插件大火都是这么命名的）</p><p>先处理 mediaplayback，按照文档，创建项目之后，把 <code>aar</code> 直接拖进项目，并设置「生成操作设置」</p><blockquote><ol start="5"><li>将 textanalyzer.aar 的生成操作设置为 LibraryProjectZip</li></ol></blockquote><p>Xamarin 虽然是这么设置的，但是在 Visual Studio 2022 <strong>已经没有这个选项了</strong>，取而代之的是 <code>AndroidLibrary</code></p><p>然后就可以开始生成了，<strong>要不怎么说微软 nb 呢</strong> —— .NET 会解析 <code>arr</code> 或者 <code>jar</code> ，将所有签名或者代码结构生成出来，并以类为单位生成一个个 C# 文件，作为 header file 使用</p><p>但，刚说什么来着？</p><blockquote><p>谁也不知道到底这个翻译官水平如何</p></blockquote><p>不出意外的话<strong>马上又要出意外了</strong></p><h3 id="寄！">寄！</h3><p><img src="/blog/Image/maui-musickit-error.png" alt="error"></p><p>mediaplayback 关于音乐部分是原生库（.so），应该是 JNI 部分依赖了 <code>javacpp</code>，而 <code>javacpp</code> 在翻译成 C# 的时候出问题了。尝试解决一下但无法解决，想抄作业全网搜索没有一个相似案例可以抄作业。如果直接用 kotlin 我会受这苦？</p><p>没办法只能退而求其次 —— 本地授权完获取 token 之后，剩下的走 Apple Music API。但即使可以的话，音质可能是收音机水平</p><h3 id="Droid-MusicKit-musickitauth">Droid.MusicKit - musickitauth</h3><p>跟 mediaplayback 一样，把 arr 拖进来，改成 <code>AndroidLibrary</code> 之后编译，很意外的非常顺利，只有几百个警告。<s>在老程序员的眼里，1000 个警告都是无异常</s></p><p>接着，在 MAUI 的项目中打开「引用」目录，右键这个目录添加引用，把 <code>Droid.MusicKit</code> 添加进来，再编译一遍。没有报错的话就是没有报错</p><p><strong>要不怎么说微软 nb 呢x2</strong>，在使用时，可以直接 using 包名</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">using Com.Apple.Android.Sdk.Authentication;</code></pre><p>这里采用的方式是：先在公用逻辑写一半类，接着在对应的平台实现里完成各个平台调用</p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth();    &#125;&#125;</code></pre><p>接着到 android 目录，创建一个 <code>MusicKitService.cs</code></p><pre class="line-numbers language-CSharp" data-language="CSharp"><code class="language-CSharp">namespace MauiDemo.Services&#123;    public partial class MusicKitService    &#123;        public partial void Auth()        &#123;            &#x2F;&#x2F; 当前 activity（如果有更好的方式的话欢迎告诉我）            var activity &#x3D; Microsoft.Maui.ApplicationModel.Platform.CurrentActivity;            &#x2F;&#x2F; 应用上下文（React Native 直接在 props 进来的那个）            var context &#x3D; Android.App.Application.Context;            var authenticationManager &#x3D; AuthenticationFactory.CreateAuthenticationManager(context);            var developerToken &#x3D; &quot;&quot;;            var intent &#x3D; authenticationManager                .CreateIntentBuilder(developerToken)                .SetHideStartScreen(false)                &#x2F;&#x2F; 授权页面显示的告示信息                .SetStartScreenMessage(&quot;要想听歌就赶紧授权！&quot;)                .Build();            &#x2F;&#x2F; 跳转 activity（android 原生应该很熟悉）            activity.StartActivityForResult(intent, 100);        &#125;    &#125;&#125;</code></pre><p>最后随便绑定到项目创建时的 Demo 的按钮上，不出意外的话点击按钮就能显示 Apple Music 的授权页面（跳转到 Apple Music 或者让你安装一个）</p><h2 id="总结-4">总结</h2><p>零零散散写了很久，文章周期很长。可能有上文不接下气的感觉</p><p>本来对 MAUI 寄予厚望，现在理性考虑还是不会使用</p><p>一方面是需要踩坑的地方目测得到的就有点多（如果之前没踩过 Xamarin 的话还得算上）；一方面目前社区不活跃，有点冷门的实现自己搞不定</p><p>体感上会比印象中的 React Native 好很多（新解释器和 Hermes 还没用过），但开发成本和理解成本不在一个层面</p><p>总之，看还是会看，暗中观察。用的话现在不会用（但是体感上 Xamarin 真的要比 React Native 好，很纠结…</p><h2 id="Link-2">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/samples/xamarin/ios-samples/ios11-musickitsample/">Xamarin.iOS - MusicKitSample</a></li><li><a target="_blank" rel="noopener" href="https://learn.microsoft.com/en-us/xamarin/android/platform/binding-java-library/binding-an-aar">Binding an .AAR</a></li><li><a target="_blank" rel="noopener" href="https://github.com/dotnet/maui/discussions/1340">MAUI Binding .aar library</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> MAUI </tag>
            
            <tag> MusicKit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成为玩家 2022</title>
      <link href="/blog/2022/12/31/to-be-a-gamer-2022/"/>
      <url>/blog/2022/12/31/to-be-a-gamer-2022/</url>
      
        <content type="html"><![CDATA[<p>本来想顺利过完 22 年，甚至一次都不想羊。他妈的防不胜防，22年最后一刻，现在觉得自己都不干净了</p><p>边咳边写故事，以后年终总结都是这样的形式，讲故事方便融资（x</p><span id="more"></span><h2 id="我想做的就是-JRPG">我想做的就是 JRPG</h2><p>今年有更多的时间花在系统学习音乐上，为什么</p><p>首先，JRPG 更强调剧情的推进，且有更强烈的 role play（相对于欧美RPG来说，代入日式RPG更需要想象），所以相对来说，JRPG 有一个更抽象的世界观。怎么交代清楚「现在身处一个怎样的环境」，<strong>除了文案旁敲侧击暗示之外，配乐起到非常关键的作用</strong></p><p>自从去年聊完《原神》之后，我发现越来越多的新游戏（所谓的二次元游戏）都开始强调配乐（这个时候我真想吐槽某个游戏吃老本的功力是真的得天独厚）。但毕竟不是谁家都是 HoYoVerse，从一开始就深入跟策划文案磨世界观，和游戏基本到开发末期再“配乐”，本质上还是有所区别</p><p>所以在游戏，音乐有一个更新的称呼：互动音乐（设计），且这是我们能叫出名的国外游戏公司的标配（比如真有你的 SE）</p><p>举个例子，最近的《宝可梦朱/紫》，四个地区分别有自己一个 theme，但每一个 theme 在步行、骑行、水边、特殊场景、战斗所使用的配器均不同，且使用的配器更适合当时的环境 —— 步行更多是一个比较纯净的钢琴，一旦上了摩托就会变成一个带 epic 的管弦，<strong>并且他们无缝衔接</strong>。这让探索旅途中，既体现了地区风格，又带给游玩者一个“更真实”的情绪</p><p>再加个例子，《八方旅人》和《异度之刃3》有一个差不多的设计</p><p>介绍下背景，《八方旅人》讲的是八个不同的角色为了实现各自不同的目标在同一片大陆展开冒险的游戏。在他们分别进 boss 战之前都有一段嘴炮用于剧情铺垫，此时配乐开始使用对应角色一个可以循环的短音乐，进战斗之后开始切为一个从这个短音乐的音阶和节奏型转换为战斗配乐的音阶和节奏型（大多是升音阶，学者中间段先接上前面的 3/4 转 6/8 一路卡到 4/4 进战斗）</p><p>也就是每个角色 boss 战之前配乐是这样的：循环段 -&gt; 过渡 -&gt; 战斗</p><p>这么做的好处同样很清晰：<strong>当你沉浸在故事时，不会因为配乐切换而打断情绪</strong>。同时游戏大多时候在嘴炮期就已经让你感觉到气愤/可怜，而在过渡段自然地滑进 battle theme 之后，玩家的情绪也已经非常自然地提到了激情的状态，巴不得直接就扬了面前这个B</p><p>而《异度之刃3》要提的是冠名怪（You Will Know Our Names-Finale-，这首也是系列第一首使用了完整的互动音乐设计的音乐</p><p>冠名怪的配乐被分成了四段：进去一段，怪进狂暴期一段（血条在火焰之后），濒死一段，<strong>收势两段</strong>。是的，收势分为以 Chain Attack 结束和普通结束。</p><p>上面描写了很多信息，那跟我有锤子关系？巧了，我想做的就是 JRPG。<strong>如果制作人都不知道自己的游戏将会是什么样，那又有谁会知道呢</strong></p><p>所以日后只要写关于游戏简评的文章，都会加上一个新章节：配乐分享</p><p>虽然但是，今年的钢琴没有任何进步。明年除了乐理要继续安排时间学习，要开始翻《配器法》</p><h2 id="好故事还要讲得好">好故事还要讲得好</h2><p>故事对于 RPG 来说非常重要，无论是美式 RPG 还是日式 RPG。关于日式和美式对于故事的区别我跟一些业内人员（世界观设计，文案）算是有过沉重的讨论，这里不谈，可以以后单独写一篇我的观点</p><p>翻看我的微信读书，发现《故事》读了 8 个月，我记得很清楚，其中第五章第六章花费了绝大多数时间。如何「科学」的写出一部能让众人娓娓而谈的小说是一件非常难做到的事情</p><p>这是写故事，好故事所需要的前置条件。再是讲故事，因为不管多好的故事，它终究暂时是在纸上。读小说吸引人的其中一点也在于画面与描写都在每个人的大脑中，每个人都有每个人想要的画面和理解，一千个读者眼中就会有一千个哈姆雷特</p><p>《故事》列举了非常多的影视作品片段作为案例用于解释故事点，实际上对于现代游戏来说…也没问题。现在能端上台面的 RPG 游戏，要求可越来越高了。除了需要成熟或独特的游戏玩法，镜头语言、场面调度等等影视手段也在不断地搬到游戏作品中去，加上这个时代出现了「虚幻5」这样的游戏引擎，越来越多不可能逐渐变成可能</p><h2 id="游戏首先要好玩">游戏首先要好玩</h2><p>今年刚好内部有一个 gamejam，抱着试一试的心态参加了。拿到主题之后，我们首先有一个世界观想法，然后开始写 GDD，开始决定类型、特点、关卡设计、<strong>音乐设计</strong>…</p><p>虽然我们最后因为其他原因没有参赛（报名了但没参赛），但在路演期间，在去试玩其他组的游戏，特别是一个后来成为冠军的游戏时，我突然悟了一个道理</p><blockquote><p>游戏首先要好玩 —— 魏皮特</p></blockquote><p>任天堂也是这样的主张，游戏设计再好，它不好玩就不是好游戏。所以<strong>从最开始我们的路线就是错的</strong> —— 浪费时间在决定是 2D 是 3D，是像素还是写实，<strong>甚至是 gamejam 没有时间考虑的音乐设计</strong>，都是无用功</p><p>也许这是 JRPG 的路线，但对于 gamejam 来说就是不适合，因为流程太长，无法在玩法上一击命中，那么短的试玩时间根本无法给试玩者留下任何印象，他们都是没有耐心的。在开发时也无故增加了许多工作量</p><p>并且我们在常规关卡设计中预计使用「华容道」，这其实已经被证明过多次这是个“偷懒”的游戏设计，如果关卡设计太难，这又会失去更多一部分玩家</p><p>总而言之，从此刻开始悟道什么是纯粹的快乐。明年再来</p><h2 id="减少后悔">减少后悔</h2><p>在复盘整年时，我发现上一节提到了 gamejam，实际上我本就有一个符合主题的游戏 —— 去年学习游戏开发时的原型《Pong Evolution》，真的本质上就完全符合主题</p><p>但为什么会想不起来？<strong>能力不够</strong>。能让我发现这个问题的依然是那个比赛的第一名，让我得到「原来主题还可以这样理解」的启发</p><p>这让我又有一个新的想法：如果我就以一个游戏原型，不断地去参加内部的比赛，每次都为了贴合主题添加新的元素，积累下来会不会非常有意思？</p><p>多做减少后悔，现在我是这样想的</p><h2 id="你做的前十个游戏都是垃圾">你做的前十个游戏都是垃圾</h2><blockquote><p>你做的前十个游戏都是垃圾，所以赶紧做掉吧 —— Jesse Schell</p></blockquote><p>上面提到的 JRPG 确实是我目前在游戏工作中最大的梦想，但我不可能一直吊死在一个项目上，停留在「完美的设计」上，即使这是我最想做好的游戏</p><p>我能理解标题的含义，初出茅庐就做出完成度非常高的作品几乎不可能。与其纸上谈兵不如先做起来。十个必然是一个虚数，其含义是不断地做，坚持做，越做越多，越来越多的错误，越来越多的总结…</p><p>作为程序员应该更能理解。刚开始写一个应用程序的时候，我肯定大多数人都还无法理解设计模式的重要性（说不定现在大多数前端也不理解，所以我还是不认为这些前端是程序员（x</p><p>Wwise 是一个商业软件，自然它也官方适配同样是商业引擎的 Unity 和 Unreal，而对于目前作为我学习伴侣的 godot 就没有这种完美适配。所以在我开始学习「交互音乐设计」同时也在思考「如何设计一个在 godot 比较方便我自己使用的声音管理类？」、「autoload 是否就可以做到？」</p><p>这大概就是「垃圾」的意义</p><p>这个游戏我至今都一直在修改和补充 GDD，但确实不会贸然开始设计程序，因为我的垃圾还没写完（x</p><h2 id="是该有所不一样了">是该有所不一样了</h2><p>去年的这个时候还在抑郁的期间，总结非常的 down</p><p>今年更多被一个压力更大的工作看上了，几乎一整年都在围绕这个工作</p><p>公司给机会了所以尝试开发一个框架。在最开始设计的时候并没有把它当框架设计，今年开始发现业务复杂度越来越「奇妙」之后，决定给它加个核心转成框架，以后讲</p><p>加上在公司活整得很散，所以今年感觉比较疲，几乎所有开坑的产品都是 idle</p><ul><li>kazusa - 游戏剧本编辑器</li><li>setsuna - 个人事项管理</li><li>ayaka - 文档生成器（CSR, SSG）</li><li>hikari - 图片预览器</li></ul><p>是该有所不一样了，原本给自己设计的知识管理工具后面推翻改成游戏剧本/文案编辑器，应该以后更多都会根据自己的需求开发工具</p><p>有太多想做的事情，甚至当前很想去开发《无限暖暖》…</p><p>就这样，今年没有那么多抱怨和抱负，大概是因为正在生病</p>]]></content>
      
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>web 「性能优化」</title>
      <link href="/blog/2022/12/15/web-optimization/"/>
      <url>/blog/2022/12/15/web-optimization/</url>
      
        <content type="html"><![CDATA[<p>如果你在玩《剑网3缘起》，你会发现游戏有一个内置社区。虽然这个应用是个 CSR，但是会发现加载并不慢</p><p>而且这些都不是事后优化。所以正好可以分享一些可能对其产生作用的习惯和做法，或者说开发时可以注意的地方</p><h2 id="TL-DR-13">TL;DR</h2><p>总之就只有一个目标：尽量砍掉第一次加载的大小和尽量减少加载所需要花费的时间</p><ul><li>减少加载体积</li><li>懒加载/延迟加载：利用 import/export 做代码分段</li><li>充分利用 http2 和 vite（开箱即用版 rollup ）</li><li>非常巧合的做法，指跟 React Beta 版文档异曲同工</li></ul><span id="more"></span><h2 id="减少加载体积">减少加载体积</h2><p>前端的静态资源都在依赖网络传输，所以在第一屏尽量加载最小的资源。</p><h3 id="使用-preact">使用 preact</h3><p>这个应用在建立的时候 react 版本是 17，虽然已经有 react 18 但还不 stable。考虑一番之后觉得没有并发和批处理的 react 不够有吸引力。与此同时，preact 10 有：</p><ul><li>更小的体积，即使带着 <code>compact</code> 最后也就不到 10k，保守预估</li><li>更快的运行</li><li>react 16 兼容，沉淀组件直接用不用考虑需不需要升级或适配</li><li><code>&lt;Suspense&gt;</code> 在当时已经稳定</li></ul><p>当时的考虑是：现在用 preact 以后迁移回 react 18 问题也不是很大，所以在 react 18 没有稳定之前都可以用 preact。只不过在 <code>TypeScript</code> 环境下，写类型稍微痛苦了一些 —— 毕竟只有 <code>api</code> 是兼容的，类型可不兼容</p><h3 id="JS-加载">JS 加载</h3><p>首先是编译期处理，举个例子</p><pre class="line-numbers language-TypeScript" data-language="TypeScript"><code class="language-TypeScript">&#x2F;&#x2F; use-noop.tsexport function useNoop() &#123;  return () &#x3D;&gt; &#123;&#125;&#125;&#x2F;&#x2F; page.tsimport &#123; useNoop &#125; from &#39;.&#x2F;use-noop&#39;</code></pre><p>首先我们的规范决定了：工具放在 <code>utils</code> 目录中且<strong>一个文件仅有一个函数，并通过 <code>export</code> 导出</strong></p><p>所以我们在最开始就解决了一个问题：尽可能拆掉首包体积，或是能自然的利用 ES Module Tree Shaking (Rollup)</p><p>接着，由于我们的目标是Chromium(cef) 76 往上，那么<strong>可以直接使用 module 的形式加载</strong>且不需要 <code>polyfill</code></p><h2 id="懒加载">懒加载</h2><p>懒加载内容分两个：</p><ul><li>原本一起打包但已经 split 的 JS 文件</li><li>从网络上加载的媒体资源（图片，视频）</li></ul><h3 id="媒体资源懒加载">媒体资源懒加载</h3><p>这里主要是图片，虽然 Chrome 已经有浏览器级别的懒加载（loading=“lazy”）</p><p>Chrome 会根据当前网络环境决定要加载多远的图片，不过 Chrome 的阈值有点捉摸不透。最后还是决定使用 <code>lazysizes</code>，并且自己控制加载距离 —— 大概就在屏幕外面多一点点</p><p>于是「不必要」的网络请求又节省下来一点</p><h3 id="JS-懒加载">JS 懒加载</h3><p>可以懒加载的 JS 不少，对于我们来说大概有几种：</p><ul><li>首屏用不到的模块，懒加载</li><li>路由，组件懒加载</li></ul><p>首屏用不到的，或者在生产中用不到的模组例如 <code>vconsole</code>、<code>hls.js</code>，在第一次不参与加载</p><p>其次，我们在架构组织上采用分层组织，即页面组件(pages)作为消费层，业务代码根据需求和 <code>feature</code> 一一关联</p><p>我愿称之为渐进式 DDD，因为就是从 DDD 的思想不断简化，再通过磨合时间和程度逐步加上去，最后都习惯并理解「为什么持续维护项目型需要 DDD」</p><p>有机会的话下一篇分享 DDD 在我们实际场景中的运用。这里推荐一个项目叫 <a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh</a>，比较可惜的是这个框架诞生于我们的决定之后</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"># 这里隐藏掉了部分细节- common  - component  - model  - repository  - service- [feature]  - component  - model  - repository  - service...- pages  - [page]</code></pre><p>这样，<code>page</code> 对于我们来说只是一个组合功能的载体，从而又带来一个好处：<strong>一个页面可以决定哪部分直接添加，哪部分进 lazyload</strong>。加上 <code>preact</code> 已经稳定的<code>&lt;Suspense&gt;</code>，就可以实现不那么生硬的体验效果</p><p>并且所有的 <code>page</code> 都是通过路由 lazyload 的，也就是第一次加载不会加载到别的页面的 JS（这好像已经变成了基操）</p><p>到这其实有个问题：以上关于一个页面拆分懒加载，但它们始终都要在第一屏加载，下载量可是不变的</p><p>所以还有下一步操作，大小尽量砍了，该想怎么弄快了</p><h2 id="利用-http2">利用 http2</h2><p>http2 没有改动 http 的语义，但改动了头部压缩，新增优先级排序和多路复用</p><p>在 http1.1，由于每个请求都会开一个连接，所以早期前端优化有这么一手：把静态资源分布在不同域名下，例如 <a target="_blank" rel="noopener" href="http://img1.example.com">img1.example.com</a>，<a target="_blank" rel="noopener" href="http://img2.example.com">img2.example.com</a>。其实现在观察 github 也能看到类似的做法</p><p>但因为 http2 有了二进制分帧，所以基于此实现了共享TCP，到位了再根据标记和头部重新组装报文。在这之前 http1.1 是一整块纯文本，分区用的换行符（指头部和身体）</p><p>其实以上都「不重要」，只需要知道现在同一CDN下载不阻塞了。所以在 h2 之下，<strong>静态资源可以同时加载</strong>。这就解答了上面关于页面拆分的问题</p><h2 id="异曲同工？">异曲同工？</h2><p>Dan Abramov 也就是 react 的创作者，被小右也就是 vue 的创作者大狙点头之后，对 react beta 文档爆更了 3 天。原因就是被吐槽 TTI 和 TBT 占用时间太长被 vue 的文档吊锤</p><p>所以他对 react beta 文档改动了什么？</p><ul><li>工具函数拆分，改成一文件一函数</li><li>移除过时浏览器支持，从而移除 <code>polyfill</code> 的加载（react 现在也仅支持现代浏览器）</li><li>懒加载资源，例如 <code>@codemirror/lint</code> 和 <code>eslint</code></li></ul><p>所以现代前端优化，好像基础版就这么些操作，大家都是一样的。首先尽可能压低大小（可仅参考 gzip 之后大小），然后尽可能抬高加载速度显示速度（SSR，CDN）</p><p>实在不行，发现瓶颈出现在远端数据，那就上缓存！资源慢缓存资源，数据接口慢缓存数据，什么 service worker 全给它叠起来（x</p><h2 id="Links-3">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/mq2thez/blog/blob/main/upgrade-react-etsy/preact-vs-react.md">Updating React at Etsy</a></li><li><a target="_blank" rel="noopener" href="https://web.dev/browser-level-image-lazy-loading/">Browser-level image lazy-loading for the web</a></li><li><a target="_blank" rel="noopener" href="https://medium.com/geekculture/how-does-dan-abramov-optimize-beta-reactjs-org-after-be-complained-about-website-speed-840b02cf5ee8">How Does Dan Abramov Optimize beta.reactjs.org After Be Complained about Website Speed?</a></li><li><a target="_blank" rel="noopener" href="https://info.support.huawei.com/info-finder/encyclopedia/zh/HTTP--2.html">什么是HTTP/2？</a></li><li><a target="_blank" rel="noopener" href="https://github.com/aFarkas/lazysizes">aFarkas/lazysizes</a></li><li><a target="_blank" rel="noopener" href="https://github.com/remesh-js/remesh">remesh-js/remesh</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> preact </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我早就想拿 QuickJS 做 SSR 了</title>
      <link href="/blog/2022/12/12/quickjs-ssr/"/>
      <url>/blog/2022/12/12/quickjs-ssr/</url>
      
        <content type="html"><![CDATA[<blockquote><p>鸽了一年，不重要，下一篇解释</p></blockquote><p>现在几乎现代框架 SSR 默认都是用 <code>node</code>，难道不能用别的？原因很简单，同构，有天然适合的执行/运行时环境。拿 <code>React</code> 举例子，SSR 分两个步骤：</p><ol><li>静态部分先用服务器渲染一遍，最基本的都是拿入口过一遍 <code>renderToString</code></li><li>运行时水合，也就是不用 <code>render</code> 而是 <code>hydrate</code>，因为已经不需要在运行时创建节点，只需要绑定</li></ol><p>所以问题就很清晰：默认或者常规手段的 <code>hydrate</code> 和 <code>renderToString</code> 都是 JS 函数</p><p>当 QuickJS 刚出现在我的眼前的时候，特别是有人给 QuickJS 提供 rust 绑定的时候，我就在想一个问题：<strong>这 B 是不是可以直接拿来做 SSR ？</strong></p><span id="more"></span><h2 id="Why-QuickJS">Why QuickJS</h2><p>毕竟 rust 早就有 v8 绑定，<code>deno</code> 用的就是</p><p>你说得对，但是 QuickJS 是由著名神仙 Fabrice Bellard 所打造的一个小型并且可嵌入的 Javascript 引擎，它支持ES2020规范，包括模块，异步生成器和代理器。在这里，你可以用任何现代的 JavaScript 语言片段在几乎任何语言环境中运行，在自由的环境中邂逅不同的语言和技术栈，同时它还支持 Decimal 提案和运算符重载提案……</p><p>其实就是不挑</p><h2 id="前端">前端</h2><p>流水账，主要是踩坑流程</p><p>前端部分自不必多说，玩了两年半的 <code>solidjs</code>，现在只要不是上班都是用这款（其实上班能夹带私货的时候也用）</p><p><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a> 提供 SSR 各种形态的 demo，但他们都有一个特点：使用非常原生的 <code>rollup</code> 插件作为演示<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，那我正经用也不用这个啊，那不行，就得按 vite 工作流来。</p><p>so</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pnpm dlx degit solidjs&#x2F;templates&#x2F;ts</code></pre><p>首先 <code>vite.config.ts</code> 有两处调整：</p><ul><li>solid 插件激活 ssr，这在处理 ssr 输出时有用</li><li><code>noExternal</code>，后面讲为什么</li></ul><p>改完之后大概是这样</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export default defineConfig(&#123;  plugins: [solidPlugin(&#123; ssr: true &#125;)],  build: &#123;    target: &quot;esnext&quot;,  &#125;,  ssr: &#123;    noExternal: true,  &#125;,&#125;);</code></pre><p><code>package.json</code> 新增一个 <code>script</code>，不加也行</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;type&quot;: &quot;module&quot;,  &quot;scripts&quot;: &#123;    &quot;build&quot;: &quot;vite build --outDir .&#x2F;dist&#x2F;client&quot;,    &quot;build:server&quot;: &quot;vite build --ssr .&#x2F;src&#x2F;entry-server.tsx --outDir .&#x2F;dist&#x2F;server&quot;,  &#125;&#125;</code></pre><p>这里把输出路径都有点调整，目的是把客户端产物和服务端产物分开，不这么做也行。<strong>但入口是肯定分开的</strong>，即使这很基操不需要写下来</p><p>按照 vite 建议的做法，客户端入口从 <code>index.tsx</code> 改为 <code>entry-client.tsx</code>，则服务端入口为 <code>entry-server.tsx</code>，内容每个框架都差不多，按照前端框架的建议做即可</p><p><strong>记得客户端真实入口 <code>index.html</code> 里的 script 路径也要改！</strong></p><p>过一下 build，能看到 dist 下两组目录，下一步</p><h2 id="服务端">服务端</h2><p>Web Framework 不用挑，用的最多的（可能也是两年半），可能也是目前来说依然最虎的 <code>actix-web</code>，需要花心思的是找 binding</p><p>首先用的是 <a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a>，在品鉴这个项目的时候还顺便搜到另一个项目 <a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a>，这是一个类似的操作：通过 QuickJS SSR Vue，可以读读看</p><blockquote><p>Node outperforms QuickJS by a wide margin. Especially with enough cores and memory. However, QuickJS is very small and has very low memory consumption, so running it threaded in a Rust shell makes it possible to have very high throughput using very few resources in comparison.</p></blockquote><p>顺便品鉴完这个项目之后，开始缝合。不出意外的话马上要出意外了</p><h3 id="坑1：">坑1：</h3><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">unsupported keyword: export</code></pre><p>这里可以讲讲为什么上面要 <code>noExternal</code> ，原因很简答，vite 默认你是会用 node 的，加上 type 是 <code>module</code>，结果就是编译后的服务端入口依然有 <code>import</code> 和 <code>export</code></p><p>所以目的很简单：把所有用到的 js 都打成一个文件。并且这里还需要一个操作：去掉最后一行，也就是 <code>export</code> 部分</p><p>默认情况下是在 QuickJS global 环境下 eval 程序，直接当成 <code>REPL</code> 来用就完事了</p><h3 id="坑2：">坑2：</h3><blockquote><p>找不到 setTimeout</p></blockquote><p>一番查找，<code>setTimeout</code> 由 QuickJS 内置 module: os 提供，按道理来说 <code>setTimeout</code> 应该能在 globalThis 直接调用</p><p>没关系，直接 eval 进去吧</p><h3 id="坑3：">坑3：</h3><blockquote><p>不存在 os</p></blockquote><p><strong>这你妈你说你妈呢？</strong> 这怎么可能啊</p><p>只见 Issue 区赫然有这么一行</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs/issues/123">Is there any way to use std, os, and global?</a></li></ul><p>Ok，寄</p><h3 id="Finish">Finish</h3><p>本来看着是 star 最多的库</p><p>算了，还得是直接绑定来得稳定，虽然比较麻烦，相当于换个语言直接使用框架。但高级封装至少比低级封装容易使用</p><p>于是改用这个高级封装：<a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a>，这个就非常纯，需要直接生吃 Document</p><p>简单验证</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let test &#x3D; ctx.eval(&quot;let a &#x3D; 1; let b &#x3D; 2; a + b&quot;).unwrap();assert!(3, test);</code></pre><p>发现没问题，直接搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let result &#x3D; context.with(|ctx| &#123;    let _a: String &#x3D; ctx.eval_file(&quot;ssr&#x2F;dist&#x2F;server&#x2F;entry-server.js&quot;).unwrap();    let result: Object &#x3D; ctx.eval(r#&quot;render()&quot;#).unwrap();    let head: String &#x3D; result.get(&quot;head&quot;).unwrap();    let body: String &#x3D; result.get(&quot;body&quot;).unwrap();    let mut map &#x3D; HashMap::&lt;String, String&gt;::new();    map.insert(&quot;body&quot;.to_string(), body);    map.insert(&quot;head&quot;.to_string(), head);    map&#125;);</code></pre><p>这里转一次 <code>HashMap</code> 的原因是：<code>Object</code> 的类型没有声明，直接 return 出去有静态检查问题，rust 不允许</p><p>但因为是概念验证，先转成已知类型出去顶着用</p><p>编译没问题，继续搬</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">let template &#x3D; read_to_string(&quot;ssr&#x2F;dist&#x2F;client&#x2F;index.html&quot;).unwrap();let html &#x3D; template    .replace(&quot;&lt;!--app-head--&gt;&quot;, result.get(&quot;head&quot;).unwrap())    .replace(&quot;&lt;!--app-body--&gt;&quot;, result.get(&quot;body&quot;).unwrap());</code></pre><p>打印 html，确认内容就是一个完整的 html 文件。<strong>成了！</strong></p><p>那直接上 server-side，简简单单写个 get</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[get(&quot;&#x2F;&quot;)]async fn hello() -&gt; impl Responder &#123;    let html &#x3D; make_html();    HttpResponse::Ok()        .status(StatusCode::OK)        .content_type(&quot;text&#x2F;html&quot;)        .body(html)&#125;#[actix_web::main]async fn main() -&gt; std::io::Result&lt;()&gt; &#123;    HttpServer::new(|| &#123;        App::new()            &#x2F;&#x2F; 静态文件映射            .service(Files::new(&quot;&#x2F;assets&quot;, &quot;ssr&#x2F;dist&#x2F;client&#x2F;assets&quot;))            .service(hello)    &#125;)    .bind((&quot;127.0.0.1&quot;, 8080))?    .run()    .await&#125;</code></pre><p>浏览器输入一个令人熟悉的 <code>localhost:8080</code>，正常运行，JS 绑定也一切正常</p><p>代码会发布在 <a target="_blank" rel="noopener" href="https://github.com/colmugx/quickjs-ssr">colmugx/quickjs-ssr</a></p><h2 id="最后-3">最后</h2><p>这里只是一个简单验证，SSR 的 real world 肯定不是这么两步就能完成，否则就不需要像 <code>next.js</code> 和 <code>SolidStart</code> 这样的上层框架</p><p>并且，除了服务端需要考虑线程池等等这些问题之外，拥有 JIT 的 v8 可能性能上会更优</p><p>但我的目的也很简单，我要的不是 SSR，而是两个需求</p><ul><li>给 <code>ayaka</code> 提供一个静态页面生成的方式，但默认还是像 <code>saika</code> 那样的运行时 fetch</li><li>给 <code>kazusa</code> 提供脚本执行环境，不过这是个 optional，主要维护还是 lua 执行环境，这与既定用户群有关</li></ul><p>别问为什么又来一个 <code>ayaka</code>，问就是灵感来源 <a target="_blank" rel="noopener" href="https://github.com/2nthony/saika">2nthony/saika</a>，而不叫<code>sakuya</code>的原因仅是因为那会在玩原神银趴</p><p>最后，这可能是第一篇来自于这个主题 3.5 版本的文章，想给用 hexo 的这段时间一个完美的休止符，然后去开发有新设计风格的 nlvi 4</p><p>但是重构一半，交互上还是有缺陷，只不过说不影响阅读</p><h2 id="Links">Links</h2><ul><li><a target="_blank" rel="noopener" href="https://github.com/solidjs/solid/blob/main/packages/solid-ssr/README.md">solid-ssr</a></li><li><a target="_blank" rel="noopener" href="https://github.com/DelSkayn/rquickjs">DelSkayn/rquickjs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/theduke/quickjs-rs">theduke/quickjs-rs</a></li><li><a target="_blank" rel="noopener" href="https://github.com/galvez/fast-vue-ssr">galvez/fast-vue-ssr</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>solidjs 的 vite 插件来源于 rollup 插件的上层封装 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> quickjs </tag>
            
            <tag> vite </tag>
            
            <tag> solid </tag>
            
            <tag> ssr </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>作为玩家 成为玩家</title>
      <link href="/blog/2022/01/07/to-be-a-gamer/"/>
      <url>/blog/2022/01/07/to-be-a-gamer/</url>
      
        <content type="html"><![CDATA[<p>实际上 2021 年的总结早就写完了，这才是临时追加的一文。最终选择 shadow 年终总结有两个原因：</p><ul><li>那是一篇极其消极的文章</li><li>本文是一次自我救赎</li></ul><p>so，这也许是更合适的“年终总结”</p><h2 id="TL-DR-11">TL;DR</h2><ul><li>虽然还是前端，但身处游戏</li><li>对于以上，为什么</li></ul><span id="more"></span><h2 id="因为热爱">因为热爱</h2><blockquote><p>从主观感受聊到游戏设计，这大概就是热爱吧 —— 2021.4.30</p></blockquote><p>我觉得故事不用从盘古开天辟地开始讲起</p><p>非常幸运的是，当时的工作环境中，团队所有人都玩游戏，大部分都玩高品质单机游戏，所以我们业余茶歇都会聊游戏。甚至分享可以讨论游戏，甚至在会议室玩《决斗链接》，两人duel，其他人通过电视观战。而那会面试的时候，我们经常问的“你业余时间一般会做什么”，在得到瞬间的回答“我平时不玩游戏”反而会感到诧异</p><p>在当时，除了会讨论游戏好不好玩之外，我经常又会往下继续讨论。跟另外一位同事经常讨论现在的热点，以及游戏细节，和“我为什么喜欢xx游戏”。那个时候根本没想过会到游戏公司服务，大家只是玩家</p><p>后来遇到一些朋友，无一例外都来自于游戏公司。于是在氛围煽动下，我离开了所处不久的新环境。这里只能说：感谢 VP 的理解和支持，同时我没办法回应你的欣赏，实属抱歉</p><h2 id="“黑暗降临”">“黑暗降临”</h2><blockquote><p>永远不要忘记第一次听《疾如猛火》后潸然泪下的那个中午</p></blockquote><p>作为一个营销碰瓷游戏，在此之前我从来没有关心过，黑暗降临也指的是第一次的营销碰瓷。但在一次内部分享之前，一切都改变了</p><p>分享的大概主题是“原神的音乐设计”，发生在分享之前，游戏新闻也多多少少提到：</p><blockquote><p>《崩坏3》和《原神》的音乐火到出圈</p></blockquote><p>于是，这是我与原神的第一次接触 —— 我打开了原神的主主题（Main Theme）。那个层次的细腻和画面感一下子涌入脑中，光听音乐已经能大概能看到这是一片幻想大陆</p><p>紧接着，我听了一些场景音乐。有个熟悉的特点，场景音乐都分为日间和夜间，这个设计在这之前仅有《异度之刃》系列对我印象深刻</p><p>当天中午，引用的故事发生了。在五声宫调跳进中古调，加上民乐领跑，饱满的感情直接轰入灵魂。因为原神的早期世界观架在欧洲，主题也就偏中古调式。《疾如猛火》就是一首同时具有璃月主题与原神主题的战斗音乐，也就是就东方体裁碰撞西方体裁，民乐器碰撞管弦乐，毫不突兀，又交相辉映……就这样一下子崩不住了。落泪原因简单：在我们生活的这片土地上，真的诞生了品质如此优秀的游戏</p><p>其实很长一段时间我都没有打开过原神，下载过原神。但城邦、人物性格、人际特点几乎都靠音乐云了个七七八八。蒙德有大大小小的西欧建筑，遍地风车，人们过着惬意的生活；繁荣的璃月港口络绎不绝，不仅存在丰富的中华文化，更是做到最大的文化包容；像是一个存在于战争或荒乱的稻妻，人民憧憬和平，满怀希望。在绀田村的表达中更为明显，仿佛妻离子散，每天都盼望家人回家……而每个元素也有独特的风格，雷元素会有重金属或者电子音乐，火元素有急躁的风格或者摇滚，水元素总会用带有故事感的钢琴带情绪……</p><p>且不谈游戏质量，这已经能证明这是成功的游戏音乐了</p><p>这是一个即使现在想起来还是会鼻尖一酸的回忆，<strong>所以我不断提醒自己，不要忘记这个感觉。</strong>《鬼谷八荒》、《风来之国》、《戴森球计划》等等证明了我们是可以做出优秀的游戏，《原神》向我们展示了我们也能做出贴近日系上游品质的游戏。但是 <strong>这个日系游戏并没有屈服于这个 title —— 璃月的刻画告诉了全世界什么是中华文化。</strong> 原本我没有喜欢过任何一个角色，现在有了：<strong>红毹婵娟 —— 云堇</strong></p><p>与其说是爱上了 miHoYo，不如说只是喜欢 HoYo-MiX。我还是不会主动向人推荐《原神》</p><h2 id="“未成年保护”">“未成年保护”</h2><blockquote><p>周五、周六、周日和法定节假日<br>20:00 ~ 21:00</p></blockquote><p>两个朋友同一时间离职，相继去了三个不同的行业：游戏、教育、房地产。于是后面发生了什么已经不用讲了（笑</p><p>虽然 ban 的是网络游戏。但难免有些感慨。国内的游戏环境还是太糟糕了，被各种数值网游污染，导致人们根本没办法理解什么是游戏，怎么对待游戏。现在还有绝大多数人认为游戏 = 打怪升级刷刷刷，他们不懂《双人成行》为什么必须两个人玩；《风之旅人》为什么不告诉玩家 NPC 的由来；《传说之下》为什么不能打怪升级；《我的世界》为什么能成为电子工程摇篮（x</p><p>针对游戏问题，更重要的是成长期的陪伴。任天堂在 2000 年的时候就推出了“防沉迷机制”<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，但人家是如何理解防沉迷的？</p><blockquote><p>Wii的“家长监控”模式，最终选择了记录孩子的游戏时间，让他们和家长自行沟通决定游戏时间，用主机里的“游戏履历”督促孩子遵守约定，达到和“断电”同样的目的。</p><p>总之，大部分限制都能调整，只要家长和孩子商量好就行。这是任天堂“家长监控”系统的最大亮点。</p></blockquote><p>任天堂在本来是提供给监护人的信《致监护人》预判了“孩子可能正在寻找解除限制的方式”，并留下了一段话告诉小朋友：</p><blockquote><p>不守诺言，整天玩游戏肯定是不行的<br>但如果是“我才玩了一会……”就被爸爸妈妈说了<br>那或许就是没有好好决定游戏时间的缘故了！</p><p>确定一个规则，然后让爸爸妈妈通过这个软件监督自己，这样就能开开心心玩游戏了</p></blockquote><p>我是相信人在思维最发散的时候是应该接触电子游戏或者沙盘游戏的，而且应该培养一个健康的游戏价值观。<strong>至于那些什么“电子海洛因”的家长，反正每一代都有上瘾的东西。</strong> 尝试反问你的家长，上学的时候有没有沉迷过武侠小说，有没有沉迷过滚铁环，至少我屡试不爽。什么时候为人父母才能懂得：<strong>家庭才是第一教育场所，陪伴才是第一教育资源。</strong> 怪电视，怪游戏，怪玩具，怪邻居都是不可能解决问题的</p><p>你觉得你很忙，没时间陪孩子，把手机一丢让孩子自己玩。即使你手机没有王者荣耀，你的孩子也会因为抖音上瘾。到时候你敢举报抖音吗？你不敢！因为你也正上瘾着呢！</p><h2 id="主程摆烂">主程摆烂</h2><blockquote><ul><li>这个实现不了</li><li>我们最近太忙了，有空看一下</li></ul></blockquote><p>这来自于真实情况，但我只能轻描淡写</p><p>作为发行，确实有很多运营工作是需要我们做的，其中就有游戏中的社区入口。我们对接的两个游戏，一个 webview 不撑满，一个 webview 保留默认工具栏，更甚的是 android 与 iOS 的工具栏位置不同，但它们都会挤压视图空间。而这两个问题本不是问题，对于 unity editor 来说仅仅是一个开关而已。而当我们提出了问题时，对方回复了引用1；而当我们提出解决方式：仅加一条声明，对方回复了引用2</p><p>并且在合作过程中，游戏方经常爱理不理，甚至出现内存泄露时还直接推锅是社区造成的，<strong>并转发崩溃堆栈给我们排查问题，你他妈是认真的吗？</strong></p><p>这让我感受到了，“带着热爱工作”只是我的一厢情愿而已，无论到哪都是如此。我不再出声，用 unity 模拟了我们需要的调试环境（只用了一个 webview，并对 webview 定制），并加入他们不愿意做的退出功能（不愿意取消工具栏的原因是没有工具栏退出不了场景）。以此来解决我们的调试工作经常受阻导致我们自己的开发周期被压缩，最后再进游戏运行一遍确认效果即可</p><p>彼时彼刻我真的很敬仰腾讯游戏，在《腾讯游戏开发精粹2》里他们描述到了，他们在三个游戏引擎都开发了渲染后端，让社区和活动页面都能直接渲染在游戏引擎中。这种做法无论什么角度都是完美的，而我们却还在这种狗屁事情纠缠不清</p><h2 id="浅墨离世">浅墨离世</h2><blockquote><p>愿这本书，能帮助那些热爱游戏编程、怀揣游戏开发梦想，却苦于难以入门的人们，让他们少走弯路。</p><p>愿这本书，能为国产游戏、国产游戏引擎的崛起，开启一扇门，迎接新的黎明。</p><p>我们都还年轻，该做的梦及时去做，该追寻的梦想用力去追寻。</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><blockquote><p>我有一个梦想，将来的某一天，大家都能玩到拥有自己本土文化的优质游戏。</p><p>我有一个梦想，有一天，西游记能出ACT，让老外去体会中国文化西游记中“斗战胜佛”的打击快感，那一定比西方的动作巅峰之作《战神》、《鬼泣》更加深邃。</p><p>我有一个梦想，有一天，上海滩能出沙盒游戏，而不是玩《GTA》感受美国梦，亦或是玩着《热血无赖》体验国外公司强行塞给我们的“中国文化”。</p><p>我有一个梦想，有一天，不少3A大作不需要汉化，因为是我们自己的游戏，配音是中国的，文化也是中国的。</p><p>我有一个梦想，将来的某一天，国产游戏能像中国的其他产业一样，以一个领跑者的姿态，面对全世界，面对全宇宙，器宇轩昂，扬眉吐气。</p><p>这会是由我们一起去完成的梦想。</p><p>等着我们的好消息！</p><p>—— 《逐梦旅程：Windows游戏编程之从零开始》简介</p></blockquote><p>我不会揣摩已故之人，但能写下如此文字的人最后的结果竟然如此令人遗憾，想必在那瞬间肯定是无比绝望吧</p><p>我对浅墨并不熟悉，在这之前仅通过 opencv 了解过。在这之前因为方向不同，所以对 shader 等等也不关心。在某个周六，兄弟加班出门吃饭时，看到了某座楼下面围起来了，还在叹息：</p><blockquote><p>XX游戏怎么又……（为什么加又）</p></blockquote><p>当知道当事人是如此追梦人时，没有人不是心酸的。但凡在知乎看过那两则招聘文章，即使评论区各种冷嘲热讽，也能感受到作者对这件事抱足了信心。</p><p>也许世界就是这么现实吧。有人正在坚持“技术宅改变世界”，有人在摆烂，有人因为可能过高投入导致评估收益不清晰而在投入之前终止了投入</p><h2 id="最后-4">最后</h2><blockquote><p>在我的名片上，我是一个公司总裁；<br>在我自己来看，我是一名游戏开发者；<br>而在内心深处，我是一名玩家。</p><p>—— 岩田聪 -《玩者之心》- GDC2005</p></blockquote><p>故事是经过排列的，每发生一个事件，这种无助又坚定的心情就加深一层</p><p>《原神》向我们和世界展示了国产优秀的架空世界观和国产游戏音乐，我们再也不用羡慕史克威尔的音乐；《黑神话：悟空》向我们和世界展示了各个角度的正版“斗战胜佛”，我们再也不用羡慕拥有《战神》的圣莫妮卡。未来还有更多可能</p><p>但我们的环境还是很糟糕。所以，我能不能也做点什么，能不能不再是少数人的世界，能不能让更多人理解，即使这对我来说完全陌生。打嘴炮是最简单的，但这件事可能真的入脑了 —— 我开始怀疑我的选择和自己：我真的可以做到吗？我可什么都不会啊！</p><p>就像 2022 年潘通流行色<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>想要表达的那样（老样子，博客换颜色了），也刚好贴近自己和博客一直的追求：<strong>让一切充满想象力</strong>，希望可以继续坚持下去。毕竟，整个评论区可都是“你可以！！”啊</p><p>其实 <code>godot-pong</code> 是有在做的，现在是填充基本规则和做了音效音乐（音乐觉得做废了打算重做所以迟迟没上传）</p><p>希望 2021 年留下来的这篇文章，在未来不会被自己删除，并时刻提醒自己</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.huxiu.com/article/461405.html">https://www.huxiu.com/article/461405.html</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://www.pantone.com/color-of-the-year-2022">PANTONE COLOR OF THE YEAR 2022</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      
        <tags>
            
            <tag> 年度总结 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>为什么我没想过 EventBus</title>
      <link href="/blog/2021/11/24/why-not-eventbus/"/>
      <url>/blog/2021/11/24/why-not-eventbus/</url>
      
        <content type="html"><![CDATA[<blockquote><p>以下全是暴论</p></blockquote><p>这是一个发生在今年的对话：</p><blockquote><p>Q：组件通信有几种方式？<br>A：balabalabala（无非 props, provide/inject，vue 还有 $parent/$children<br>Q：还有吗？<br>A：postmessage 可以算吗<br>Q：也行，还有吗？<br>A：localStorage/sessionStorage 可以算吗？<br>Q：算半个，还有吗？</p><p>这 TM 不就这些方式还有吗？</p></blockquote><p>回来一拉清单，各家文章盘点确实还多了一个：<code>EventBus</code></p><span id="more"></span><h2 id="什么是-eventbus">什么是 eventbus</h2><p>简单理解：事件总线，一种订阅/发布模型，即是在希望发生事件处理的地方创造一个监听器(listener)，接着在希望影响到监听器所在位置变化或更新的地方加上发射器(emitter)</p><p>这样的好处是，任何位置都可以透传。因为事件总线（可以）是全局的</p><p>从名字上看，它应该是属于事件驱动设计的产物。这没问题，GUI 一直都跟事件驱动有关，浏览器在交互部分也是这么做的</p><p>那，这么多前端框架有没有使用事件驱动的？有，御三家里的 <code>Angular</code>。除了御三家那更多了，反而数据驱动才是新品种</p><p>OK 目的达成，我就是要绕到这个点上：为什么面试上问 Vue，甚至是 React，我就没想过 EventBus。<strong>因为这本来就跟数据驱动没关系</strong></p><h2 id="为什么我不用-eventbus">为什么我不用 eventbus</h2><p>不带 Vue 玩了这领域有争议。就一个问题：什么时候 React 会触发更新？</p><p>这个时候就应该有个经典公式：view = f(props, state)。也就是当 <code>props</code> 或者 <code>state</code> 发生更新了，<code>view</code> 会更新。或者换句话说，<strong>数据更新了视图会更新</strong></p><p>那这里就有一个问题：如果触发了某个事件，视图会更新吗？<strong>会更个几把！</strong> 要会更新你还需要 <code>setState</code> 吗？这也是为什么 <code>rxjs</code> 在 <code>React</code> 用起来就是没有 <code>Angular</code> 来得无尿点，最核心的一点就是你想通过 <code>rxjs</code> 通知视图更新就肯定需要在订阅做一次 <code>setState</code>，不管你封装了还是在 business code 里订阅一次写一次</p><p>而且我不用还有另一个原因：这东西在我的理解中，就是一个 <code>goto</code> —— 它会把代码弄得非常糟。本来是单向的数据流向，现在会完全不知道某个组件会因为什么而产生更新，流向变得不可观察</p><p>你可能会说，那 context 也是这么传的啊！可 eventbus 可不禁止子组件 call 父组件，不约定好就造成逆数据流</p><p>除此之外，事件名称是一个字符串（暂且只能是字符串），那么这个时候需要保证事件名不要重复。为了解决这个问题可能就会引入一个叫事件表的东西 —— 但你想用到某一个事件时，import 这个常量，毕竟常量背后什么静态值对于事件来说无所谓，对得上就行。这会发生什么问题？在生产过程中这问题发生得不要太多，最经典的就是忘记更新事件表，或者嫌麻烦摆烂直接写，最后发现因为一个大小写导致事件对不上……</p><p>除此之外还有！毕竟是一个订阅发布模型，你订阅了是不是得取消订阅。事件的东西你一旦开了他就会一直留存在内存中，处理不当的话可能会出现两个一模一样的 listener，而这个原因仅是因为上一个没有销毁……当然了最轻的问题就是你的某一个事件处理会响应 n 次，是的这只是最轻的</p><p>总之这非常反思维，在一个数据驱动的环境中，为了一点点 buff 而引入大量 debuff 是否得不偿失。经过一轮网上冲浪后发现，相关讨论不少（指两个）</p><ul><li><a target="_blank" rel="noopener" href="https://forum.vuejs.org/t/event-bus-is-it-a-good-idea/49853">Event bus - is it a good idea?</a></li><li><a target="_blank" rel="noopener" href="https://www.reddit.com/r/androiddev/comments/eksepr/why_some_people_dislike_eventbus/">Why some people dislike EventBus?</a></li><li><a target="_blank" rel="noopener" href="https://tkacz.pro/vue-js-why-event-bus-is-bad-idea/">Vue.js: why event bus is bad idea</a></li></ul><h2 id="你真的需要-eventbus？你用来做什么？">你真的需要 eventbus？你用来做什么？</h2><p>Vue 有 provider/inject，React 有 Context API，这应该够用了</p><p>跟数据有关的 API，Vue 有 Vuex，React 有 React / Recoil。他们本身也会遵循单向数据流</p><p>所以，到底是哪里需要在 React 环境中引入一个不属于数据驱动的东西。或者换个思路（挖个坑）：</p><p><strong>我们是否正在被框架绑定？一个本只是视图层框架，现在还包含了逻辑层？</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 一起玩吧</title>
      <link href="/blog/2021/09/04/game-pong-enhance-2/"/>
      <url>/blog/2021/09/04/game-pong-enhance-2/</url>
      
        <content type="html"><![CDATA[<p>稍微数了一下，要完整完成一个游戏其实要做的有很多。这篇依然是补完一个游戏</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-5">TL;DR</h2><ul><li>启动页面、得分牌</li><li>加入简单的 AI</li></ul><span id="more"></span><h2 id="完成情况">完成情况</h2><p>这把已经像一个游戏了。所以，可以一起玩吧</p><p>以下是记录本次更新一部分内容</p><h3 id="UI">UI</h3><p>目前是加了一个标题场景，但是过于没东西讲。老前端熟悉的 <code>flex</code> 布局思路一通搞完事</p><h4 id="切换场景">切换场景</h4><p>游戏是按场景(scene)来区分页面(非常前端的描述)，比如关卡类游戏一般会做很多 level 的场景。不同的是这可没有所谓的路由，而是直接切换(change)</p><p>这里使用的是：获取场景树，得到实例，切换场景(change_scene)</p><pre class="line-numbers language-cpp" data-language="cpp"><code class="language-cpp">get_tree()-&gt;change_scene(path);</code></pre><p>这个项目里的实现是：把这种按钮直接做成「组件」，暴露场景接口。在标题场景 <code>connect</code> 所有这个类型的事件，用统一事件处理跳转。这样就封装了跳转场景，方便以后处理设置界面啥的</p><h4 id="记分牌动画">记分牌动画</h4><p>有一个控件 <code>AnimationPlayer</code> ，用来控制能访问到的节点的动画，例如运动、变形。如果使用过 <code>flash</code> 那是相当熟悉 —— 关键帧打起来</p><h3 id="加入-AI">加入 AI</h3><p>周伯通虽然也行，但是自己玩还是得有个「对手」</p><p>现在看到 AI 人就不知觉紧张起来，感觉是个非常难的东西。其实 AI 就只是「人工智能」，其目的就是「假装是个人」，那游戏 AI 就是「假装有个陪你打游戏的人」。只不过现在的「机器学习」确实给游戏 AI 也带来了不少想象力 —— 他们的操作越来越像人的思维方式了</p><p>多智能还得看开发者。例如中小学机器人编程比赛中的经典项目足球项目和灭火项目，</p><blockquote><p>足球项目：最简单的逻辑就是通过传感器（指南针）判断两边方向，超声波测距，忘记什么传感器用来找球。摸到球之后直接把球往对方门里「撞」，完事。</p></blockquote><blockquote><p>灭火项目：都带着指南针和热力传感，主要还是看谁的寻路比较nb</p></blockquote><p>游戏 AI 很早就有，最经典的游戏 AI 还属南梦宫的吃豆人(pacman)<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>（对于我来说一样属于游戏设计必修课，甚至机器学习也可以）。</p><blockquote><p>一共四个干扰怪物，逻辑都不相同</p><p>红色 blinky：追着豆子，通过寻路算法找距离最近的路线<br>粉色 pinky：追豆子前方第四个格子，通过寻路算法找距离最近的路线。如果向上移动，则是左上方四个格子<br>青色 lnky：blinky 与豆子各自前方射线的交点，并两倍延长的点<br>橙色 clyde：追豆子到方圆 8 格内就会散开（纯气氛组）</p><p>四个单个逻辑不复杂且工作量很小的 AI，组合成一个看似一直在围堵玩家的敌方小队。这就是最经典的地方</p></blockquote><p>这篇文章再开个坑：我要写一篇我对游戏 AI 的理解。例如游戏设计中，一些非常难的 gameplay 可能会设计出让 AI 「放水」，让玩家以为 AI 真的翻车了，以此来鼓励玩家</p><p>好了，这一部分的重点本应该是这个游戏的 AI，目前的设计是： <strong>在自己的 y 与球的 y 距离大于 25 时，追球。25 差不多是板子的 1/4。</strong> 逻辑就这，没了</p><p>但别小看这简单的逻辑，在目前没有什么骚东西的环境下，只要没有什么花里胡哨的操作（例如拿板边去敲球）几乎没有胜利的机会。而现在这个环境玩骚的只会把自己的分骚没（比如我）</p><h3 id="冷却与重置">冷却与重置</h3><p>当球落某方门后，球会重置到游戏中点，没有操作，直接关闭了惯性和直接 set position</p><p>不过有一个小设计：败方接球。如果某方上一回合输了，这一回合由该方接首发球</p><p>所以，虽然是可以玩了，但是还是缺东西，比如很多关于游戏规则的完善</p><h2 id="下一步">下一步</h2><ul><li>发球 y 随机：目前发球的 y 是固定的，直接去接球点等球多没意思啊</li><li>随机首发球：第一球现在都发给左方，或许应该随机</li><li>胜利规则：现在这游戏一开就没边了…</li><li>暂停与结束界面</li><li>声音</li></ul><p>游戏补完之后，往后的更新就越来越慢了，因为想法越骚，实现也会越来越难</p><h2 id="Link">Link</h2><ul><li><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/82567889">游戏AI入门及AI优化</a></li><li><a target="_blank" rel="noopener" href="https://docs.godotengine.org/en/stable/classes/class_animationplayer.html">AnimationPlayer</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/27177424">现代游戏AI的鼻祖——聊聊你所不知道的《吃豆人》</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 发布</title>
      <link href="/blog/2021/09/02/game-pong-enhance-1/"/>
      <url>/blog/2021/09/02/game-pong-enhance-1/</url>
      
        <content type="html"><![CDATA[<p>其实游戏已经做很远了，为了真实性删了很多添加的东西…</p><p>本来可能已经开始描述第一个版本了，万万没想到发布到 web 时发生问题：编译产物报错</p><p>项目 <a href="https://colmugx.github.io/godot-pong">体验地址</a>，<a target="_blank" rel="noopener" href="https://github.com/colmugx/godot-pong">项目地址</a></p><h2 id="TL-DR-6">TL;DR</h2><ul><li>完成基本的击打、胜利条件、球的恢复</li><li>编译与发布</li></ul><span id="more"></span><h2 id="完成情况-2">完成情况</h2><p>基本的 gameplay 已经完成 —— 两块板子一个球，板子的后面是各自的「门」。</p><p>门选择 <code>Area2D</code><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>，原因是这个控件专门控制物理状态与检查物理状态；墙壁使用<code>StaticBody2D</code></p><p>板子和球目前均使用 <code>KinematicBody2D</code>，因为可以方便的模拟物理状态，反弹完全不需要代码描述。但板子可能应该换成<code>RigidBody2D</code>，这样可以模拟更多的真实物理，例如摩擦力，受力。不过目前需要求证：控制端使用 <code>RigidBody</code> 是否合理</p><p>完全没什么好讲的，非常简单的实现</p><h2 id="编译与发布">编译与发布</h2><p>由于 <code>native</code> 的关系，运行时会把 cpp 编译，并编译成动态链接库。例如 osx 使用 <code>.dylib</code>，那么 web 跟原生相关的肯定是 <code>.wasm</code> 。官方提供了原生端的案例<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>，而开发时也只编译了 osx 版本。</p><p>直到要验证发布到 github pages 时，出大问题，浏览器只显示 <code>abort(undefined)</code></p><h3 id="目前不能使用最新的-emscripten-编译你的-wasm">目前不能使用最新的 emscripten 编译你的 wasm</h3><p>经历各种尝试，例如直接从源码编译新的 template，但编译时也频出问题，甚至 debug 无法成功编译，接着进入无尽改编译参数等各种操作……</p><p>直到看到这个 issue <sup class="footnote-ref"><a href="#fn3" id="fnref3">[3]</a></sup></p><p>因为之前一直使用的 <code>emscripten</code> 版本已经是 26，所以猜<strong>是不是跟版本有关系，于是换成 17，成了</strong></p><p>于是有另一个猜想：<strong>官方发布的模板是否因为也使用 17 的版本发布，会导致 dll 对应不上。业务代码必须同样使用 17 编译代码才可以使用？</strong></p><h3 id="交给-github-action">交给 github action</h3><p>因为刚刚的 issue，发现这个作者对 godot 发布已经了然于胸，最后发现他提供了一个 ci 配置<sup class="footnote-ref"><a href="#fn4" id="fnref4">[4]</a></sup>，于是参考这个配置写了一个工作流，现在可以把整个发布路程交到 github 了</p><h3 id="记得提交-export-presets">记得提交 export_presets</h3><p>可能可以发现，前面大部分 action 都是失败的</p><p>如果选择了 github 的 .gitignore 模板，这个文件默认会被忽略。但缺少这个文件 ci 无法工作 —— 获取不到发布配置</p><p>so，记得提交，接着等待一切结束。顺带一提，github action 的配置应该不高，编译 godot-cpp 属实膀胱局</p><p>下一篇应该讲有完整 UI 的第一个版本，结束</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/physics/using_area_2d.html">使用 Area2D</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.godotengine.org/zh_CN/stable/tutorials/plugins/gdnative/gdnative-cpp-example.html">GDNative C++示例</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li><li id="fn3" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/godotengine/godot-cpp/issues/554">Building for HTML5 stopped working for emsdk 2.0.18+</a> <a href="#fnref3" class="footnote-backref">↩︎</a></p></li><li id="fn4" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://github.com/2shady4u/godot-cpp-ci">2shady4u/godot-cpp-ci </a> <a href="#fnref4" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从零开始的 Pong Game - 介绍</title>
      <link href="/blog/2021/08/29/game-pong-enhance-0/"/>
      <url>/blog/2021/08/29/game-pong-enhance-0/</url>
      
        <content type="html"><![CDATA[<p>做一个简单的项目介绍：</p><p>使用 <code>godot engine</code> 从零开始的 <code>pong game</code> 开发。开发会尽量保持简单，但希望不缺挑战</p><p>实现 <code>pong</code> 不是目的，作为我单方面宣布的「游戏开发中的 hello world」，完成它其实非常简单。所以我想做的：<strong>不断给游戏加入新东西，在显得合理的基础上，把能做的都加进去</strong></p><p>这个项目应该会一直进化，从越来越多的内容，到可能更合理的代码组织方式，一直到我认为的上限。可以是我做不来了，或者是达到游戏上限，毕竟这是一个雅达利时期的神作</p><p>所以项目将会使用：</p><ul><li>godot 3 (gdnative)</li><li><strong>C++</strong></li><li>photopea（用来弄点素材）</li><li>garageband / logic（声音）</li></ul><span id="more"></span><h2 id="你-TM-怎么想的">你 TM 怎么想的</h2><p>「在岸上永远学不会游泳」，这是在当时听到的兄弟对我说的一句话。<s>希望他不是因为嫌我菜让我爬而说出来的话</s></p><p>也为了记录，「如果单就以 pong 作为母版，到底能做到什么样子」，所以本身也是一个兴趣导向产物</p><p>这个系列还是不定期更新，甚至可能随时流产。流产的原因只有一个：搞不出来了…</p><p>就这样。下一篇先写一切的基础：如何让 pong 运行起来</p>]]></content>
      
      
      <categories>
          
          <category> 游戏 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> godot </tag>
            
            <tag> cpp </tag>
            
            <tag> pong </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>flutter desktop 能不能跨平台多窗口</title>
      <link href="/blog/2021/06/17/flutter-tauri/"/>
      <url>/blog/2021/06/17/flutter-tauri/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这篇文章极其具有时效性，在目前，<code>flutter</code> 不支持多窗口，但是已经有<a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">这么一篇文档</a><sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>。而且 flutter desktop 的多窗口可能已经计划中了。</p></blockquote><p>SETSUNA 的 UI 需要满足条件：桌面移动端统一 UI（没错过了半年还在选型）。现阶段可以选择的只有一个框架：<code>flutter</code>。而且：</p><ul><li>flutter 使用 <code>skia</code> 绘图而不是调用原生组件，表现统一</li><li>flutter 可以方便的响应式设计，UI 可以用同一套代码（只要可以，顺路兼容手机、折叠屏、横向平板、桌面布局）</li></ul><p>flutter 本就是先给移动端设计，可以直接用 <code>dart</code> 完成很多工作。但是在调研桌面时发现一个问题：<strong>找不到多窗口 API！</strong> 这不行。虽然 flutter 是允许原生编程，那我能会 <code>windows</code> 开发吗？！</p><p>等会，flutter 是不是已经支持了 web。那么，这波不得两面包夹芝士？</p><p><img src="/blog/Image/flutter-tauri-0.jpg" alt="flutter-tauri"></p><p>把 flutter 套进 <code>electron</code> 是不是就完成需求了！（顺便还可以实现简单 PWA 版本）</p><p>但是桌面端不选择 <code>electron</code>，咱用 <code>tauri</code>！毕竟现在全平台都 <code>webkit(blink)</code>，而且 <code>flutter</code> 使用 <code>canvaskit</code>，不需要担心表现…</p><span id="more"></span><h2 id="准备工作">准备工作</h2><h3 id="初始化">初始化</h3><p><code>tauri</code> 采用的是「集成到项目」的方式，所以先创建一个 flutter 项目（创建步骤省略）</p><p>接着，根据文档<sup class="footnote-ref"><a href="#fn2" id="fnref2">[2]</a></sup>集成 tauri：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">$ yarn add -D @tauri-apps&#x2F;cli$ yarn tauri init</code></pre><p>需要配置一些步骤。其中，<code>distDir</code> 选择的是 flutter 创建的 <code>web/</code>。开发地址暂时空过</p><h3 id="flutter-以服务运行">flutter 以服务运行</h3><p>与 electron 一样，tarui 运行的还是前端应用，所以要不执行 <code>index.html</code>，要不有个开发服务</p><p>flutter 直接调试会直接打开 chrome，所以这次运行换种方式：仅运行开发服务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 如果不指定端口，flutter 会随机一个高位端口，但每次启动都会更换端口flutter run -d web-server --web-port 4396</code></pre><p>flutter 服务没有热更，要更新的时候按 R <s>换弹</s> 更新</p><h3 id="配置-tauri-启动">配置 tauri 启动</h3><p>还记得刚刚漏了的运行地址？<code>tauri</code> 的配置都在 <code>tauri.conf.json</code> 中，找到 <code>devPath</code> 并补上</p><p>接着直接运行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yarn tauri dev</code></pre><p>顺利的话就能直接看到窗口了</p><p><img src="/blog/Image/flutter-tauri.jpg" alt="flutter-tauri"></p><h2 id="开整">开整</h2><p>虽然标题只提到了「多窗口」，但 realworld 肯定无法避开原生操作。而且不管是 tauri 还是 electron 都需要用 <code>JavaScript</code></p><p>tauri 前后端（rust）通讯采用命令（command）的方式，同样是通过 event bus 互相抛事件来做到。所以我们要让一切 JavaScript 的工作桥接到 dart 上</p><p>tauri 提供了两种向后端通信的方式：直接用挂载在 <code>window</code> 的对象或者使用提供的包：<code>tauri-app</code>。这里暂时先用 <code>window</code>，但后者也可以满足，后面写 dartjs 互操作篇再覆盖</p><p>接下来分成两部分：需要实例化调用 与 不需要实例化调用</p><h3 id="不需要实例化">不需要实例化</h3><p>其实意思就是可以直接访问直接调用，不用 <code>new</code>。而在 tauri 中，向后端发起命令的函数位于：<code>window.__TAURI__.invoke</code></p><p>按照我们使用 JavaScript 的思路，调用一个对象下面的方法，思路就是直接一直点（.）下去。那么这就是一个<strong>访问多层上下文</strong>的过程</p><p>可以了，换成 dart 写出来</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; flutter 肯定有 dart，那肯定有 dart:jsimport &#39;dart:js&#39; as js;&#x2F;&#x2F; 获得 tauri 挂载的对象final tauri &#x3D; js.context[&#39;__TAURI__&#39;];&#x2F;&#x2F; 调用这个对象里面的方法tauri.callMethod(&#39;invoke&#39;, [&#39;&#39;]);</code></pre><h3 id="需要实例化">需要实例化</h3><p>总有（一堆）东西需要 <code>new</code>，多窗口就是其中一个。（这就离谱，多窗口竟然不由 rust 发起创建）</p><p>负责创建窗口的 API 位于：<code>window.__TAURI__.window.WebviewWindow</code><br>（更 NM 离谱的是直接明牌告诉你再加一个 webview）</p><p>那么，JavaScript 需要实例化，意味着<strong>需要在 dart 也实现一遍实例化</strong>作为映射。等于我们要在 dart 有一个对应的 class，有 class 才能 new</p><p>dart 里边儿能有这玩意儿吗！那妹有怎么办啊？造啊！</p><p>这次不能用<code>dart:js</code>，得换一个</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">flutter pub add js</code></pre><p>然后是模拟一切。首先最好先创建一个新文件，这个文件会被声明为某个可以被 <code>JavaScript</code> “发现”的 library</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS()library tauri; &#x2F;&#x2F; 实际上在这篇文章这块没卵用import &#39;package:js&#x2F;js.dart&#39;;</code></pre><p>接着，这波我们要实例化的是 <code>WebviewWindow</code>，位于 <code>window.__TAURI__.window.WebviewWindow</code></p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;&#125;</code></pre><p>那 class 要能 new，得有一个 <code>constructor</code>，dart 和某些其他语言一样，再写一遍类名。其他方法该怎么写怎么写</p><p>再看一眼 tauri 文档，<code>WebviewWindow</code> 实例化带两个参：<code>label</code> 和 <code>options</code>，<code>options</code>是一个对象，关于新窗口的配置</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, Object options);&#125;</code></pre><p>再看一眼文档，<code>options</code> 的 type 是 <code>WindowOptions</code>，所以这里可以如法炮制，再造出一个结构</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title, &#x2F;&#x2F; 文章例子仅需要 title  &#125;);&#125;</code></pre><p>这样写的结构，仅支持 <code>getter</code>，所以如果需要 <code>setter</code>，可以按照 dart 的方式改写这个 class</p><p>接着把上面的改一下。完整的代码如下：</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">&#x2F;&#x2F; tauri.dart@JS()library tauri;import &#39;package:js&#x2F;js.dart&#39;;@JS(&#39;__TAURI__.window.WebviewWindow&#39;)class WebviewWindow &#123;  external WebviewWindow(String id, WindowOption options);&#125;@anonymous@JS()class WindowOption &#123;  external factory WindowOption(&#123;    String title,  &#125;);&#125;</code></pre><p>在<code>main.dart</code>创建一个新的按钮用来测试</p><pre class="line-numbers language-dart" data-language="dart"><code class="language-dart">ElevatedButton(  onPressed: () &#123;    final window &#x3D; WebviewWindow(      &quot;new_window&quot;,      WindowOption(title: &quot;Second Window&quot;),    );  &#125;,  child: Text(&#39;click&#39;),)</code></pre><p>完结撒花，结果不给图</p><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://docs.google.com/document/d/11_4wntz_9IJTQOo_Qhp7QF4RfpIMTfVygtOTxQ4OGHY">Desktop Multi-Window Support (PUBLICLY SHARED)</a> <a href="#fnref1" class="footnote-backref">↩︎</a></p></li><li id="fn2" class="footnote-item"><p><a target="_blank" rel="noopener" href="https://tauri.studio/en/docs/usage/development/integration">Tauri Integration</a> <a href="#fnref2" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> flutter </tag>
            
            <tag> tauri </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>组件化与工程设计</title>
      <link href="/blog/2021/02/16/component-and-engineering/"/>
      <url>/blog/2021/02/16/component-and-engineering/</url>
      
        <content type="html"><![CDATA[<blockquote><p>这是又一篇臆想文<br>如果看到文章的您，觉得给您带来了帮助，那纯属瞎猫撞上死耗子。</p></blockquote><h2 id="TL-DR-3">TL;DR</h2><ul><li>组件化在做什么，组件是什么</li><li>因为 toB 大型应用的历史原因，前端开始需要前端架构设计。或者说前端工程本就应该要架构设计</li></ul><p>所以是什么时候前端开发也发展成需要「软件工程」的时代了，<s>还不是现在用户的电脑越来越 nb 浏览器越来越 nb</s></p><p>工程实践变成燃眉之急绝对是近几年「是个🔨就要上云」造成的 —— 应用都希望变成 SaaS；都希望敏捷无感更新；都希望多端同步（这里不指跨平台）……</p><p>演变到这就产生一个问题</p><span id="more"></span><h2 id="问题">问题</h2><p>印象中的 toC 应用，它对于「历史包袱」的处理可以非常简单粗暴：</p><blockquote><p>都拖油瓶了，这不重构？顺道抬 KPI<br>既然都重构了，那整点新家伙，干活不累顺道抬 KPI (x2)</p></blockquote><p>所以 toC 应用总是会用上最新的技术，而且 toC 应用毕竟是直接面向个体用户的应用，所以无时无刻都在优化体验也说不定</p><p>但 toB 或者内部平台可不能说整就整，至少会遇到这些问题：</p><ul><li>“能用就行”</li><li>使用时间非常长，甚至可能公司开多久软件用多久</li></ul><p>如果再遇上几个持有「Promise没用过，应该是 vue 新加的功能」<sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup>观点的优质前端，这个应用的代码最后只能是 shit 了</p><h2 id="组件化">组件化</h2><p>我的二面可能会问一个没有什么正确答案也没什么理由的烂问题：</p><blockquote><p>如何理解组件化？</p></blockquote><p>但总能得到典型回答：</p><blockquote><p>工作中经常重复出现的功能<strong>抽</strong>成组件</p></blockquote><p>甚至是非典型回答：</p><blockquote><p>因为现在都用 vue，每一个 .vue 都是组件，这是 vue 要求的</p></blockquote><p>其中最经常得到的答案中，有一个关键动作：抽。所以又是什么时候组件化的定义变成了“抽组件”</p><h3 id="何为组件">何为组件</h3><p>在「C4模型」的官网中，关于组件的第一句话：</p><blockquote><p>The word “component” is a <strong>hugely overloaded term</strong> in the software development industry,</p></blockquote><p>很多地方其实都有组件概念，包括不限于 <code>sketch</code> 等设计应用都有组件概念。但一切都有相似之处：它们都可以是一个原子，一个单位，一个定义了接口能优秀完成某一部分工作的单位或者说 group。同理也适用于 sketch component —— 你定义了一个组件应该是怎样的元素构成与可变</p><p>所以上面的那句话，有后半句的：</p><blockquote><p>but in this context a component is a grouping of related functionality encapsulated behind a well-defined interface.</p><p>If you’re using a language like Java or C#, the simplest way to think of a component is that it’s a collection of implementation classes behind an interface. Aspects such as how those components are packaged (e.g. one component vs many components per JAR file, DLL, shared library, etc) is a separate and orthogonal concern.</p></blockquote><h3 id="为什么开始强调组件了">为什么开始强调组件了</h3><p>确实没错，当前流行三大视图框架中，都有组件概念，即一个 vue 文件之于 vue，一个函数之于 react，一个 component 之于 ng 都是各领域定义的“组件”，甚至是「一切都是组件」。但这仅是强调了这是某个框架的原子，而<strong>业务形态的组件是由业务的，而不是框架决定的</strong>。</p><p>所以一个组件，并不是把代码放在一个 vue 文件，这个就是组件。毕竟你这个时候你可以问：你的应用下是不是有一个 <code>pages</code> 目录？下面也有一堆 vue 文件，他们每一个都是组件？接着你就尽情围观前端圈内最大双标现场</p><h3 id="怎样就是一个组件">怎样就是一个组件</h3><p>我自己给定义了几点：</p><ul><li>输入输出是确定的（像函数）</li><li>可单元测试的</li><li>“高内聚，低耦合”（现在还写这句话都觉得有些羞耻）</li></ul><p>举个例子，拿我以前很喜欢的某公司的官网做栗子（我觉得还是憋猜是哪个公司了吧，我给🐴成这样还猜得到？）</p><p><img src="/blog/Image/component-1.png" alt=""></p><p>这张图，大多数前端会认为，红框可以是组件。<s>甚至认为绿框在某开源组件库能找到</s></p><p><img src="/blog/Image/component-2.png" alt=""></p><p>放心我没⭕️ 错，很多前端都会这么想的。全都 <code>margin-top</code> 给它安排得明明白白，这样最后一个就不用处理了</p><p>但总有一部分的前端会这么认为：</p><p><img src="/blog/Image/component-3.png" alt=""></p><p>这样做几个好处：</p><ul><li>因为可以让组件弹性方便布局。</li><li>那个小标题<strong>肯定复用很多，别的地方也会有类似设计</strong></li><li><s>上下边距啊，在 <strong>page</strong> map 组件的时候<strong>给套上不就好了</strong></s></li></ul><p>所以很少前端会想到以下甚至更多：</p><p><img src="/blog/Image/component-4.png" alt=""></p><p>所以先弄清楚：<strong>谁是原子</strong>？</p><p>也就是「哪些是组件？」<strong>这个问题在设计阶段就应该确定了，而不是“抽成组件”</strong></p><p>所以在软件开发上，本就没有所谓的前端后端啥端的区别，软件该怎么写就得怎么写。一个组件可以是一个对象</p><p>而这<strong>还只是布局而已</strong>，也就是所谓前端工程师的「核心工作」</p><h2 id="工程化">工程化</h2><p>说实话，当今被冠以「工程师」之名的前端开发，没有几个懂工程（包括写这篇文章的five）</p><p>问题在于越来越多的软件都希望以浏览器为容器运行。所以并不是前端需要工程化，而是软件形态在发生改变。而这也可以继续解释下来会发生的事情 —— JavaScript 会越来越不顶用，需要 WebAssembly 做更多事情；使用 Web Worker 做跟渲染无关的事情等等等等</p><p>再同理，并不是开始要求前端开发需要懂工程了，而是这是一个软件工程师要知道的东西</p><h3 id="什么时候前端也要工程设计了">什么时候前端也要工程设计了</h3><p>是个应用就需要设计，或者说<strong>前端一直需要工程设计</strong>，只不过长时间被认为不需要和不被理解</p><p>最近的「微前端」更多的适用场景也是建立于此 —— 太旧的应用你实在维护不动了，新增的东西就以「微前端」的形式加入，这样做不破坏原本的应用，同时可以用较新的技术维护新功能</p><p>toB 大应用，在「前端」内容中更多是表单表格，以及很多弱交互的东西，可能最重的交互也就可视化配置。其注定了不需要设计驱动，更多的都在数据处理上，也就是「弄清数据流」。并且这类应用只会越做越大 <s>（直到流产，或者换老板）</s>，而且它的直接用户是另一个企业，甚至可能是以「私有部署」的形式售卖。所以要做的是尽可能稳定与高效</p><p>所以为了运行稳定不背锅，不让数据水乱流，只能跟传统软件，甚至是最亲近的后端服务的做法一样，做架构设计</p><p>而那些认为「按照原型实现 page component」的前端们，看看你的应用，是不是正在 <strong>「同一个接口在同一时间请求了好几遍，甚至是开一个弹窗再把相同数据请求个几遍？」</strong>。就这还敢把 Angular 作为鄙视链底层，谁给的勇气？<s>所以胆小的已经在用 dva(umi) 了</s></p><p>我又突然想到一次经历，我问过一个问题：</p><blockquote><p>你这里写了期望是前端架构师，精通前端架构。那你觉得前端架构需要做到什么？</p></blockquote><p>然后我得到一个非 常 满 意的回答：</p><blockquote><p>前端架构就是制定目录结构，接着指定代码规范，用什么组件库 balabala…</p></blockquote><p>那行呗，你开心就好，现在连 webpack 都不兴提一嘴了</p><h3 id="那咋做嘛">那咋做嘛</h3><p>提前说明，前端工程逃不过使用很多工具，包括构建与编译等。这里不讨论以上问题，只有编程「思想」</p><p>扒拉一段软件工程的含义：</p><blockquote><p>应用计算机科学理论和技术以及工程管理原则和方法，按预算和进度，实现满足用户要求的软件产品的定义、开发、和维护的工程或进行研究的学科</p></blockquote><p>另外，IBM 的大型机之父布鲁克斯发布了《没有银弹》：</p><blockquote><p>从软件危机被提出以来。人们一直在查找解决它的方法。于是一系列的方法被提出并且加以应用。比如结构化程序设计，面向对象的开发，CMM，UML等等</p></blockquote><p>这里提到了「结构化程序设计」：</p><blockquote><p>结构化编程，一种编程典范。希望借此来改善计算机程序的明晰性、质量以及开发时间，并且避免写出面条式代码。</p></blockquote><p>其实说到底总会有几点：</p><ul><li>高性能</li><li>高可用</li><li>高稳定</li><li><strong>可维护</strong></li></ul><p>关于可维护，这个时候可以来几个经典问题，问问自己，我现在在写的这个应用：</p><ul><li>是否有自动测试：unit test, e2e test？</li><li>是否会出现：点一个地方，哪哪都在 loading？（排除你偷懒连 loading 都不给）</li><li>一样的模块，在不同地方显示是不一样的？</li><li>一旦有一个样式改动，需要改十几个文件？</li></ul><p>这个时候，「组件」思想又被抬上台面，毕竟 <strong>组件化即一种分治思想</strong>。如果逃离了这个，那么单元测试就无法实现，因为<strong>此刻不存在单元</strong>，第一个问题不攻自破</p><p>接着，因为在应用之初根本没对应用进行设计，每个人拿着原型就开始整，最后各自写各自的，数据流都在某个组件里维护。接着产品经理要求「各数据展示需要同步」的时候怎么办？还不是指着产品骂娘然后做了一手操作：在产生 update 的地方后再 fetch 一次数据。所以第二个问题接着不攻自破</p><p>那怎么做其实非常明了：</p><ol><li>应用设计：在应用之初规划数据流</li><li>interface：看起来像爽哥，声音像爽哥，那就是爽哥</li></ol><p>数据流在设计之初就很好办，遇事不决先抄一版 flux —— 用 store 管理各种列表的数据和状态；列表页可以 keep-alive，根据 route 流向决定 store 的更新；VM 做成订阅/发布模型，这样，数据发起更新后，正在订阅数据的 V 可以做出更新……</p><p><strong>别信某些平台的前端爽文。什么 vuex/redux 等被称为状态管理的 library，只能用来管理共享状态，不能用来存放业务数据。Angular 看到这场景不得当场笑裂开</strong></p><p>到这也会发现，各种「台」的大型应用，最后也都是面向对象的思想。应用一旦复杂起来就需要一个充血模型。<s>那就更好办了，前端也直接 DDD ！直接嫖了后端的架构设计图</s></p><p>（顺便非常推荐《人月神话》，即使土，但45年依然流行是有道理的，其对于软件工程和项目管理的经验还有参考价值）</p><h2 id="最后">最后</h2><p>本来写这个文章的时候是想把遇到的事情都嘴臭一遍的，最后还是把这部分都清干净了，作为一个可能有用的文字。在此特别感谢若干 toB 项目，这几年在 toB 的公司中摸爬滚打带给我的一些新（旧）灵感（都是嫖后端和 GUI 应用的），终于让我这种杂学玩家体现出一点点作用</p><p>同时践行「敏捷开发」也有一段时间了，足够扎实的设计才能敏捷，不然就变成永远在填坑，而不是敏捷</p><p>所以这篇文章也作为开始，现在正在实践把「领域驱动设计」和「C4 模型」带到前端开发中。没错，又想开一个博文坑…</p><p>越来越觉得，前端架构设计可以参考 <code>rust</code> 的 <code>trait</code>，或者 <code>swift</code> 的 <code>protocol</code>，以及他们的设计模式。主观上觉得他们在思想有点相似</p><p>（不知道下次轮到我去面试时，恰好我的面试官看了我的博客，拿这玩意儿狙我…）</p><h2 id="参考链接">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://c4model.com/">The C4 model for visualising software architecture</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B">维基百科 - 软件工程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E7%BB%93%E6%9E%84%E5%8C%96%E7%BC%96%E7%A8%8B">维基百科 - 结构化编程</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E6%95%8F%E6%8D%B7%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91">维基百科 - 敏捷软件开发</a></li><li><a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/%E9%A0%98%E5%9F%9F%E9%A9%85%E5%8B%95%E8%A8%AD%E8%A8%88">维基百科 - 领域驱动设计</a></li></ul><hr class="footnotes-sep"><section class="footnotes"><ol class="footnotes-list"><li id="fn1" class="footnote-item"><p>一次面试发生的真实案例。并提出了「async 要配合 axios 才能用；ajax 没人用了」等理论 <a href="#fnref1" class="footnote-backref">↩︎</a></p></li></ol></section>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 组件化 </tag>
            
            <tag> 软件工程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>再一次重新设计简历</title>
      <link href="/blog/2020/11/11/why-redesign-cv/"/>
      <url>/blog/2020/11/11/why-redesign-cv/</url>
      
        <content type="html"><![CDATA[<p>最近看到一个招聘，两年前同一个地方，同一家公司，同一种职位，<s>不同的 HR</s><br>于是又毫不犹豫直接发邮件，美曰「追梦」。假若有幸相遇，我必带着「纸模」赴约，两年了，不容易。<s>（确认是追了个寂寞）</s></p><p>但这不是本文重点，这里将要讲新的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 一同带来的新简历模板的设计思路</p><p><code>Resumer</code> 正在用 <code>Angular 10</code> 重构。当前 GitHub 的版本是使用 umi 编写的，还没写完就弃坑的原因是：太久没维护导致各种依赖问题不想处理…</p><p>所以，接下来都是个人理解，以及我的简历模板的三次迭代 —— <a target="_blank" rel="noopener" href="https://github.com/colmugx/resume">Resume</a>、<a target="_blank" rel="noopener" href="https://github.com/colmugx/resumer">Resumer</a> 和 Resumer(ng version)</p><h2 id="请停止使用这种模板">请停止使用这种模板</h2><span id="more"></span><p>我想这种简历，应该很多人都见过</p><p><img src="/blog/Image/resume-0.png" alt="常见简历模板"></p><p>我曾偶然跟 HR 聊过这件事，也跟一位外企 HR 偶然谈论过这种简历。总而言之，HR 们表达的观点大致如此：</p><blockquote><ul><li>一般简历上不会看照片或者证件照，除非职业对五官有要求。<strong>程序员是看技术与能力的岗位自然不关心。</strong> 但如果恶心到 HR 可能会直接刷掉（半开玩笑）</li><li>简历上看到图标或者进度条等等直接忽略不看，<strong>因为没有有效信息</strong></li><li>如果获得奖项或特长与求职无关不要放在简历；如果有 leader 看重价值观一致，兴趣爱好会在面试时有沟通，但放简历上不会加分</li><li>如果对自己的院校或者在校经历没有信心，可以把学历信息靠后</li><li>简历千万不要过于复杂，不要专门打印一页封面。简历即在最小篇幅的情况下展示尽可能多的能力描述</li><li>如果是需要表现设计能力的岗位，简历可以适当体现设计感，但切不可以过于浮夸</li></ul></blockquote><p>我虽是从来没用过这种简历模板，不过原因是因为太俗气。但写简历并不是一个「完形填空」的过程，并不是找一个模板把上面预设的内容填完就完事了，可能对于程序员来说，上面除了名字和联系方式都是废话</p><h2 id="Resume-——-初生牛犊的傲慢">Resume —— 初生牛犊的傲慢</h2><p>于是，第一版「展现自我」的简历「破土而出」</p><p><img src="/blog/Image/resume-1.png" alt="resume"></p><p>设计上，使用一个标题写了 RESUME，用 sketch 画的 svg，下面「front End Developer」即前端开发；正文则是非常常规的左右分栏；方块是二维码。</p><p>如此设计的原因，认为，前端工程师也是一门艺术，网页设计美感很重要，故标题恰好是一个能展现设计美感的位置；<br>当初听信了 HR 在阅读简历时，实现移动是一个「7」字形，所以按照这个形式将信息以重要程度依次由强到弱的摆放更加合适；<br>二维码则是当时个人在线简历有些流行，则通过 CSS + 模板渲染的形式开发了一个小应用，扫描二维码可以直接到达在线简历版本，同时在线简历有下载入口（为此特别设计了 CSS3 动画，也给标题设计了绘制动画）</p><p><img src="/blog/Image/resume-1-title.gif" alt=""></p><p>在投递简历过程中，（可能确实是处于当年前端供不应求的原因）有收到者觉得简历不错。同时我也通过这份得到了「初代梦之地」的橄榄枝。</p><p>但是，这是一份初生牛犊的傲慢 ——</p><ol><li>盲信「简历应该一页纸介绍清楚自己」</li><li>长篇幅的「报菜名」，相对的，聘方更希望得到「你在 什么时候 因 什么场景 下选择了 什么技术 解决了 什么问题」</li><li>不会有 HR 或者未来的 leader 专门去打开你提供的在线简历。在线简历只有可能在第一次沟通起到信息交换方便的作用</li></ol><p>所以这份简历问题也很明显：</p><ol><li>很多信息没有说明清楚</li><li>菜名报得越多，越容易翻车；「精通」这个词并不是一个好词</li><li>术业有专攻，前端工程师要的是工程，而不是熟悉 photoshop 切图的 32 种姿势</li><li>标题、二维码与图表、进度条异曲同工，一个浪费面积的表现</li></ol><h2 id="Resumer-——-过于自信的融合">Resumer —— 过于自信的融合</h2><p>本质上这还是一个前端项目，这个系列是因此而生<br>故本次改动的首要目的是实现符合 STAR 原则的适合技术类简历的「在线编辑器」，顺便更新设计</p><p><img src="/blog/Image/resume-2.png" alt="resumer - tfd"></p><p>具体效果可以<a href="https://colmugx.github.io/resumer">点击这里</a>试试做一个简历（可能有点难用）</p><p>使用编辑器编辑后，在预览页面 cmd + p 触发打印，会自动按照 A4 纸进行布局 <s>，右下角还会有一个淡淡的水印，这个水印又使得纸张看起来有点高级感</s></p><p>上一种其实还有一个布局问题：<strong>如果一页不够写，再增加一页，第二页会多出一个边栏的空位</strong></p><p>所以这一版不仅采用<strong>全宽布局</strong>，还有：</p><ul><li>新增灰阶，不同层级的信息使用不同灰阶颜色</li><li>去掉「无用信息」</li><li>新增自我介绍，采用关键词形式描述</li><li>工作经历中深入第二级，描述在该公司中的项目以及担当</li><li>从上到下直线动线</li></ul><p>因为这段时间沉迷于指定设计风格，所以灰阶、字号、边距都有统一的规则，包括成为接下来「败笔的标题装饰」</p><p>所以这份简历也有问题：</p><ol><li>有一次内推老哥特别有心给我提建议，其中就有标题下面这条线，原因是影响阅读</li><li>关键词的设计是一个双刃剑，处理不好不加分</li><li>使用过程发现，无法用项目说明的工作无处安放</li></ol><h2 id="NEW-Resumer-——-面向成熟的优化">NEW Resumer —— 面向成熟的优化</h2><p>经历「过于浮躁」之后，也在思考如何平衡「设计感」与「信息实」<br>最终，伴随着新编辑器的新设计「跃然纸上」</p><p><img src="/blog/Image/resume-3.png" alt="resumer - tfd2"></p><p>设计元素并没有改，毕竟「设计语言」 —— 依然是同一套灰阶，同一套表现。但这一次改进了这些：</p><ul><li>信息主次排列 + 平衡。姓名是最重要的，其次是应聘岗位与联系方式，辅助联系方式及其他信息放在右边做布局平衡</li><li>新增简述，对个人总结或者描述近况。HR 可以通过这里快速获取信息与匹配关键词</li><li>工作经验留出概述区以描述主要工作，并把项目经验置入其中以进一步详细在每家用人单位的工作内容</li></ul><p>主要都在围绕「金字塔原理」构建新结构，并小改一些表现方式</p><p>所以，这就是这一切学习、总结和沉淀 ~</p><h2 id="And-More">And More</h2><p>这里要介绍一下新编辑器了😃（还没开发完成，暂时没有体验地址）：</p><ul><li>重新设计动画</li><li>使用有新动效的编辑器，textarea 改为 richtext editor</li><li>加入预览窗，预览窗可以切换模板（正在尝试实现）</li><li>可以直接分享简历（正在尝试实现）</li><li>可以暂时保存草稿到本地；读取草稿到应用</li><li>调整打印设置使之更合理</li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计 </tag>
            
            <tag> 简历 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我又不跨平台我为什么要 electron</title>
      <link href="/blog/2020/08/08/hi-swift-react/"/>
      <url>/blog/2020/08/08/hi-swift-react/</url>
      
        <content type="html"><![CDATA[<blockquote><p>无图版，会更有图版</p></blockquote><h2 id="背景">背景</h2><p>上篇文章（最近总是莫名联动）才写了 electron，主观感受，<code>electron</code> 有这么些好处：</p><ul><li>使得前端技术可以运用在本地桌面应用</li><li>跨平台</li><li><code>Chromium</code> 让兼容性不是首要考虑对象</li><li>通过 <code>NodeJS</code> 既可以操作系统，也能利用本身能力与生态</li></ul><p>但是：</p><ul><li>我好像不需要跨平台</li><li>原生开发更加能操作系统 API</li><li>扯破大天不就是<code>webview</code>嘛</li><li>依然不需要考虑兼容性，并且体积会大幅减小</li></ul><p>所以，electron 再见！</p><h2 id="思路">思路</h2><span id="more"></span><p>这里的需求是，我想要在状态栏挂一个 webapp，它可以操作状态栏图标状态，可以控制通知</p><p>这里是大概思路：</p><ol><li>创建一个 MacOS 应用（用 swift 语言</li><li>应用支持状态栏图标，隐藏 dock 图标</li><li>创建 webview （使用 storyboard</li><li>加载本地 webapp （index.html</li></ol><h2 id="关于-Native-应用">关于 Native 应用</h2><p>虽然你会百般嫌弃 xcode，毕竟这是一个开大文件或者脸臭的时候能比 Atom 卡出三个 VSCode 的 <s>IDE</s>，但是钦点的集成平台不得不用</p><h3 id="创建应用">创建应用</h3><p>通过 Xcode 创建一个 MacOS APP，Swift 语言，UI 是 Storyboard。这年头 SwiftUI 算是完整，所以默认是 SwiftUI，但这里不用</p><p>修改<code>Info.plist</code></p><ul><li>添加<code>Application is agent (UIElement)</code>，值为 YES，目的是不想出现 dock 图标</li><li>添加<code>App Transport Security Settings</code> - <code>Allow Arbitrary Loads</code>，值为 YES，目的是本地调试 react 应用时，需要支持 http 请求</li></ul><h3 id="添加状态栏菜单与弹出窗">添加状态栏菜单与弹出窗</h3><p>在<code>AppDelegate</code>定义两行属性</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let menubar &#x3D; NSStatusBar.system.statusItem(withLength: NSStatusItem.variableLength)let popover &#x3D; NSPopover()</code></pre><p>接着，在<code>applicationDidFinishLaunching</code>（应用完成启动）定义他们的行为</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; if let 爽啊！if let menuBtn &#x3D; menubar.button &#123;   menuBtn.title &#x3D; &quot;click&quot;   menuBtn.action &#x3D; #selector(togglePopover)&#125;&#x2F;&#x2F; 需要在 Storyboard 添加一个 ViewController，当然可以顺便创建 webview 等会用到let popoverController &#x3D; NSStoryboard(name: &quot;Main&quot;, bundle: nil)  .instantiateController(withIdentifier: &quot;PopoverViewController&quot;) as? PopoverViewControllerpopover.behavior &#x3D; .transientpopover.contentViewController &#x3D; popoverController</code></pre><p><code>#selector</code>涉及到 OC 的领域了，可以说 Apple 对 MacOS 的上心程度远没有 iOS 高，大量 API 还在基于 NS。（怪不得要整合生态，心有余力不足）</p><p>所以这里需要写一个允许 OC 调用的方法，控制弹出窗的显示与隐藏</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">@objc func togglePopover(_ sender: AnyObject) &#123;    if popover.isShown &#123;        closePopover(sender)    &#125; else &#123;        showPopover(sender)    &#125;&#125;</code></pre><p>本体配置结束</p><h3 id="创建-webview">创建 webview</h3><p>storyboard 拉一个 webview 出来就完事，因为这波对 webview 没有自定义，所以不绑 class</p><p>打开刚刚创建的 <code>PopoverViewController</code>，绑定下组件（从 storyboard 按住 control 拖到类的属性区（不得不说，从第一次接触入门 iOS 我就爱上了苹果这个设计！））</p><p>然后就是第二喜欢的「面向协议编程」，扩展 <code>PopoverViewController</code>，继承 <code>WKNavigationDelegate</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; 其实本文其实用不到，先写着extension PopoverViewController: WKNavigationDelegate &#123;&#125;</code></pre><p>接着，<code>viewDidLoad</code>（视图加载结束）加点东西：</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">webview.navigationDelegate &#x3D; self&#x2F;&#x2F; 通过 userContentController 获取 webview 中的事件let contentController &#x3D; webview.configuration.userContentController&#x2F;&#x2F; 定义与前端交互的方法名contentController.add(self, name: &quot;hello&quot;)</code></pre><p>接着是获取前端页面并显示，这里需要分成两个情况</p><ul><li>本地 webpack 调试是启动服务器（localhost:3000）</li><li>编译后为静态文件，需要读取的是文件（index.html）</li></ul><p>两种情况如下，具体自行应用中判断（或者调试完干脆删掉其中一种）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let pagePath &#x3D; Bundle.main.url(forResource: &quot;index&quot;, withExtension: &quot;html&quot;, subdirectory: &quot;build&quot;)&#x2F;&#x2F; let devUrl &#x3D; URLRequest(url: URL(string: &quot;localhost:3000&quot;)!)&#x2F;&#x2F; load 方式也不同，一种是加载文件，一种直接加载 urlwebview.loadFileURL(pagePath!, allowingReadAccessTo: pagePath!.deletingLastPathComponent())&#x2F;&#x2F; webview.load(devUrl)</code></pre><h4 id="WKScriptMessageHandler">WKScriptMessageHandler</h4><p>这里涉及到一个东西：<code>WKScriptMessageHandler</code>，根据 Apple Developer</p><blockquote><p>A class conforming to the WKScriptMessageHandler protocol provides a method for receiving messages from JavaScript running in a webpage.</p></blockquote><p>（众所周知，Apple Developer 看和不看没有差别…）</p><p>总的来说，这是一个用来与 webview 中的 <code>JavaScript</code> 通讯手段的协议。简单说工作方式即在<code>window</code>中插入<code>webkit</code>，其中有一个属性是<code>messageHandlers</code>，这里下面的属性即在 <code>contentController</code> 约定的属性，前端通过调用这些属性的<code>postMessage</code>来达到传送信息的目的</p><p>所以这里又要用到第二喜欢的“扩展”协议编程，这次扩展的是<code>WKScriptMessageHandler</code>，需要 require 实现一个方法：<code>userContentController</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">extension PopoverViewController: WKScriptMessageHandler &#123;    func userContentController(_ userContentController: WKUserContentController, didReceive message: WKScriptMessage) &#123;        if message.name &#x3D;&#x3D; &quot;hello&quot; &#123;            &#x2F;&#x2F; 惊讶的发现 js 的 object 在传递到应用之后已经是字典的形状，故直接强转            let body &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)            &#x2F;&#x2F; 这里完全可以通过 switch 做模式匹配，不过这里没有            if (body[&quot;type&quot;] as! String) &#x3D;&#x3D; &quot;notify&quot; &#123;              let value: String &#x3D; (message.body as! Dictionary&lt;String, Any&gt;)[&quot;value&quot;] as! String              showNotification(title: value)            &#125;        &#125;    &#125;    &#x2F;&#x2F; 调用通知 api，显示通知    func showNotification(title: String) &#123;        let notification &#x3D; NSUserNotification()        notification.deliveryDate &#x3D; Date(timeIntervalSinceNow: 1)        notification.title &#x3D; title        NSUserNotificationCenter.default.deliver(notification)    &#125;&#125;</code></pre><p>原生应用青春版配置结束</p><h2 id="该-tm-轮到前端了！">该 tm 轮到前端了！</h2><p>又是 80 年切图经验的三板斧：直接<code>create-react-app</code>开个新应用</p><p>准备就绪之后，直接在<code>App.js</code>写就好了。刚刚定义了方法名<code>hello</code>，写一个新方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 点击按钮弹出通知const handleClick &#x3D; () &#x3D;&gt; &#123;  window.webkit.messageHandlers.hello.postMessage(&#123;type: &#39;notify&#39;, value: &quot;Hello World&quot;&#125;)&#125;</code></pre><p><code>render</code>有一个<code>Learn React</code>？就用你来做<code>button</code>！</p><p>不出意外的话，原生应用与 react 应用调试模式运行起来之后，点击<code>Learn React</code>就可以看到<code>Hello World</code>的系统级通知了！</p><h2 id="编译成品">编译成品</h2><p>首先对 webapp 进行编译，<code>yarn build</code>。然后将编译后的<code>build</code>（改个名也行）文件夹拖入 xcode 工程中，注意需要复制，且为<code>create folder references</code></p><p>运行，然后你就会发现一片空白…</p><p>原因是原生应用加载文件用的是相对路径，编译后的 react app，看一下<code>index.html</code>，都是从<code>/</code>开始的</p><p>所以先暂时手工把<code>/</code>去掉，应用正常运行</p><h2 id="总结-3">总结</h2><p>本来就只有这些东西，所以真的用不上<code>electron</code>，虽然麻烦点</p><p>打包后的包体积着实惊讶：前端部分 500k，整个应用 600k。不过这个有个问题：与<code>tauri</code>遇到的兼容性差不多 —— 这里的 webview 就是 safari，而 safari 还有很多 api 的支持做得并不好</p><p>同时也算是圆了三年前的想法，当时想用 iOS 验证。原因是小程序的盛行，我在猜是不是通过这种方式 —— 通过约定的方式让前端调用指定的方法，来达到使用硬件与系统 API，又因为是直接通过微信本体通讯，所以不存在类似于跨域这种烦到死的限制</p><p>本来这次的验证是因为想快速写个工具，想到这个一直搁置的想法。结果是在印证：花了 3 天时间来解决如何节省 3 分钟的问题…</p><h2 id="相关阅读">相关阅读</h2><ul><li><a target="_blank" rel="noopener" href="https://juejin.im/post/6844903560686108679">iOS WKWebView 与 JS 交互</a></li><li><a target="_blank" rel="noopener" href="https://developer.apple.com/documentation/webkit/wkscriptmessagehandler">WKScriptMessageHandler | Apple Developer Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> swift </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 electron 爬图片</title>
      <link href="/blog/2020/06/21/electron-crawler/"/>
      <url>/blog/2020/06/21/electron-crawler/</url>
      
        <content type="html"><![CDATA[<p>有个做广告设计的朋友，自己开个小工作室，平时接些小广告设计维持生活。但总会遇到一些甲方拿着某个站点的图片，让他用这个图片给他做广告牌或者海报。就这样，作为老切图仔就一直在帮他「从网站里拿出图片」这种脏累活。想着是不是可以干脆送他个工具，这样他就可以自己玩了<br><strong>（不是很推荐这种操作，但是毕竟要恰饭要苟活，而且这种外包单，甲方是这样的）</strong></p><p>想了一下，切图仔唯一高效 GUI 的选型只有 <code>electron</code> 了，没得选。但是这次有点特别，因为 <code>electron</code> 的特殊性，我有了些想法</p><blockquote><p>electron = node + chromium，都有个完整浏览器了 484 不需要无头就可以加载 remote 然后直接获取资源？</p></blockquote><p>这里用的模板是之前实验服务一体化的模板 <a target="_blank" rel="noopener" href="https://github.com/colmugx/electron-react-koa-template">electron-react-koa-template</a>，然后删除了<code>server</code>…</p><p>删了<code>server</code>……</p><h2 id="TL-DR-4">TL;DR</h2><ul><li>webview</li><li>获取资源</li><li>提供下载</li></ul><span id="more"></span><h2 id="webview">webview</h2><p>这里还有一个方案，<code>BrowserWindow</code>，然后<code>&#123;show: false&#125;</code>让这个窗口不显示，用这个窗体当无头</p><p>不过在之前开发 hexo 编辑器的时候就有用过，当时用来做内嵌视图打开博客预览地址，还有切换线上地址用的，这里可以用用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const webview &#x3D; document.createElement(&#39;webview&#39;)&#x2F;&#x2F; 当页面加载完成之后会触发这个事件，可以继续做接下来的事情webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)</code></pre><p>于是封装一下变成</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  const webview &#x3D; document.createElement(&#39;webview&#39;)  &#x2F;&#x2F; 保险起见  webview.useragent    &#x3D; &#39;Mozilla&#x2F;5.0 (Macintosh; Intel Mac OS X 10_15_2) &#39;    + &#39;AppleWebKit&#x2F;537.36 (KHTML, like Gecko) &#39;    + &#39;Chrome&#x2F;81.0.4044.129 Safari&#x2F;537.36 Edg&#x2F;81.0.416.68&#39;  webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;&#125;)  document.body.appendChild(webview)  this.webview &#x3D; webview&#125;search(url) &#123;  this.webview.src &#x3D; url&#125;</code></pre><p>一套操作之后，你会发现什么都看不到……这个时候你会先怀疑你上面写的这个 <code>createElement</code>，是不是 electron 的 dom 不可以直接创建（匪夷所思），于是你将 <code>&lt;webview /&gt;</code> 直接放到 <code>render</code> 里，发现依然什么都没有</p><h3 id="坑：安全性">坑：安全性</h3><p>这里使用的是<code>electron@6</code>，查了一番之后，发现<code>electron@5</code>加了一个安全性设定：需要允许<code>webviewTag</code></p><p>于是在主窗体需要一行配置</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">mainWindow &#x3D; new BrowserWindow(&#123;  webPreferences: &#123;    &#x2F;&#x2F; 这里    webviewTag: true,    nodeIntegration: true,  &#125;,&#125;)</code></pre><p>然后你就能看到页面被加载</p><p>接着，确认能加载之后就可以大方的把 <code>webview</code> 隐藏起来了</p><h2 id="解析资源">解析资源</h2><p>这里计划是直接尝试获取 <code>webview</code> 的资源，但是没找到方法，只能退而求其次：爬tmd。那么这就需要一个拥有 80 年爬虫经验的工具：<code>cheerio</code></p><p>与现在普遍的互联网上某些技术社区所分享的「一小时精通 nodejs 爬虫」、「教你怎么用 nodejs 爬妹子图」等文章不同 —— <strong>他们对 SPA 一点办法都没有！</strong></p><p>我这不一样，我有浏览器，在 <code>dom-ready</code> 的时候也意味着真实结构已经加载到了（亲测！专门拿 SPA 试的！</p><h3 id="执行-JavaScript">执行 JavaScript</h3><p><code>webview</code> 有个方法 <code>&lt;webview&gt;.executeJavaScript(code[, userGesture])</code>，所以可以通过执行一段 js 把 html 拿出来，有股叉 ass ass 的味道</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then((html) &#x3D;&gt; &#123;  &#125;);</code></pre><p>这个时候<code>html</code>即一个完整的<code>html</code>，把执行放到<code>dom-ready</code>，接下来就交给 ipc 表演了</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">webview.addEventListener(&#39;dom-ready&#39;, () &#x3D;&gt; &#123;  webview  .executeJavaScript(    &#96;function gethtml () &#123; return new Promise(resolve &#x3D;&gt; resolve(document.documentElement.innerHTML)) &#125;; gethtml();&#96;,  )  .then(html &#x3D;&gt; &#123;    ipcRenderer.send(&#39;ganhuo&#39;, html)  &#125;);&#125;)</code></pre><h3 id="node-cheerio">node/cheerio</h3><p>主要是 <code>cheerio</code> 是一个 node 方的应用，依然是在 <code>main</code> 层操作更安心一些</p><p>准备一个 ipc 监听，刚刚那个是<code>ganhuo</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">ipcMain.on(&#39;ganhuo&#39;, (e, arg) &#x3D;&gt; &#123;  const $ &#x3D; cheerio.load(arg)  &#x2F;&#x2F; 各种教程都能看到的  &#x2F;&#x2F; 这里没多余操作，是个 img 就拿走  &#x2F;&#x2F; 接着 reply 回 renderer  const imgs &#x3D; $(&#39;body&#39;).find(&#39;img&#39;).map((idx, ele) &#x3D;&gt; $(ele).attr(&#39;src&#39;)).get()  e.reply(&#39;chuhuo&#39;, imgs)&#125;)</code></pre><p><code>renderer</code> 边准备一个接收，这波结束</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">componentDidMount() &#123;  ipcRenderer.on(&#39;chuhuo&#39;, (e, result) &#x3D;&gt; &#123;    this.setState(&#123;      imgs: result,    &#125;);  &#125;);&#125;</code></pre><h2 id="展示-下载">展示/下载</h2><p>UI库直接用 <code>antd</code>，依然是放心产品</p><p>这里草草带过：用 <code>form</code>、<code>input</code>、<code>button</code> 处理一个简单地址栏，用 <code>card</code> 展示图片，至于要不要<code>funcybox</code>之类的随缘</p><p>继续依赖 node 层就可以做到下载文件保存文件的操作，可以拿到图片信息(exif)，获取分辨率以及过滤分辨率啥的</p><h2 id="总结-2">总结</h2><p>到这里能发现个问题：爬取、加载，如果再算上图片信息解析等操作的话，图片妥妥的获取了三次。虽说因为图片资源都相同，可能有两次获取的是<code>disk cache</code></p><p>这里不开源了，一股 POC 味</p><h2 id="参考链接-2">参考链接</h2><ul><li><a target="_blank" rel="noopener" href="https://www.electronjs.org/docs/api/webview-tag">webview tag</a></li><li><a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Exif">Exif</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整一个家庭服务器记录</title>
      <link href="/blog/2020/06/07/home-server/"/>
      <url>/blog/2020/06/07/home-server/</url>
      
        <content type="html"><![CDATA[<h2 id="准备">准备</h2><p>我自己使用的是树莓派组，可以选择的有很多，x86的开发板、淘汰的笔记本。废物再生计划！</p><h3 id="系统选择">系统选择</h3><p>推荐三个：</p><ul><li><a target="_blank" rel="noopener" href="https://www.raspberrypi.org/downloads/raspbian/">raspbian</a>（树莓派）</li><li><a target="_blank" rel="noopener" href="https://clearlinux.org/">clear linux</a>（英特尔CPU）</li><li><a target="_blank" rel="noopener" href="https://www.debian.org/index.zh-cn.html">debian</a>（传统服务器系统）</li><li>……</li></ul><span id="more"></span><p>树莓派的话直接用 raspbian 就好了，无论是驱动（如果用到了GPIO）还是稳定性</p><p><code>clearlinux</code> 可以推荐，这里并不是只有英特尔平台才能运行，而是这个系统针对英特尔平台有特殊优化，默认会启动所有优化。除此之外这也是一个滚动型系统，并且定制性强，也很轻便，最小安装下体积非常小。亲测同样的功能项，配置下来后对比 <code>archlinux</code> 的体积会小一点。</p><p>最后就是传统一点同时寻求帮助比较方便的 debian，当然 centos 也行。只是自己已有一段时间就不接触RPM系linux而感到陌生了…（respbian 也是 debian 型）</p><h3 id="系统安装">系统安装</h3><p>这里选择的是最小安装，如果对桌面有需求的话可以默认安装</p><p>建议不需要桌面，服务器类型的东西，一旦配置都做完之后，桌面就只是一个占用性能的鸡肋了</p><h3 id="系统配置">系统配置</h3><p>大概有这么几点是最好完成的：</p><ul><li>连接网络（有线或者无线）</li><li>设置开机自动连接网络</li><li>固定ip</li><li>打开SSH</li></ul><p>无桌面的系统可能需要自己去安装一些必要的网络管理工具，这里可以寻找各系统的 wiki。但基本上没有桌面的网络设置辅助的话，手动设置网络都需要再自行设置开启自动连接这一操作，需要记得设置</p><p>一般家庭网络都是路由器通过DHCP分发 ip，如果作为服务器的主机 ip 不确定的话日后操作会比较麻烦，所以索性直接静态固定下来，只是为了方便</p><p>打开SSH只是为了以后配置和操作都可以直接用其他设备连接，不需要再去动服务器</p><h2 id="服务">服务</h2><h3 id="docker">docker</h3><p>安装方法可以直接阅读官方文档：<a target="_blank" rel="noopener" href="https://docs.docker.com/install/linux/docker-ce/debian/">Get Docker Engine - Community for Debian</a>，如果选择 clear linux 等其他系统，可以直接依据官方提供方案（如 clear linux 集市）</p><p>需要注意的是，你需要了解你的CPU指令类型 —— x64/86 或者 arm32/64 。例如树莓派 3b 使用的指令集是arm7l，属于 32 位处理器，那么接下来的工作都应该寻找 32 位 arm 处理器的解决方案</p><p>可以使用 <code>uname -m</code> 来查看目前平台使用的处理器类型</p><h3 id="portainer">portainer</h3><p>这是一个可以管理 docker 容器的控制面板，可以对容器进行图形化的管理，控制运行状态比如运行停止重启、容器配置、删除容器镜像、拉取镜像构建、重新构建容器等等</p><p>应用本身开源：<a target="_blank" rel="noopener" href="https://github.com/portainer/portainer">portainer/portainer: Making Docker management easy.</a></p><p>推荐安装方式：直接 docker 拉取安装，镜像为官方提供，也提供了 arm 版本：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/portainer/portainer/">https://hub.docker.com/r/portainer/portainer/</a>。使用单机版本就好了</p><h3 id="影音服务">影音服务</h3><p>一般来说需要两种东西：下载机 + 媒体服务器</p><h4 id="下载（aria2）">下载（aria2）</h4><p>如果是 linux 纯命令下载机应该非 aria2 莫属了</p><p>这里推荐一个项目：<a target="_blank" rel="noopener" href="https://github.com/wahyd4/aria2-ariang-docker">wahyd4/aria2-ariang-docker</a></p><p>这样下载机与在线文件管理就有了（网盘应用不喜欢可以换一个，比如 <code>Nextcloud</code>）</p><h4 id="媒体服务">媒体服务</h4><p>媒体服务有很多种协议，最后选择了 upnp dlna。原因很简单：</p><ul><li>通用性</li><li>综合来看 dlna 速度最快，相对稳定（亲测长时间观看情况下能把树莓派看挂…</li></ul><p>大多数电视厂商在自带媒体播放器也会内置 dlna 协议，所以综合来看 dlna 面对客户端也是麻烦最少的一种方式</p><p>那么服务应用就选择 minidlna 了，x86_64 可以直接使用这个镜像：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/vladgh/minidlna/">https://hub.docker.com/r/vladgh/minidlna/</a></p><p>可惜的是arm 的 minidlna 最好是自己构建镜像，如果嫌麻烦的话，这个镜像未尝不能接受：<a target="_blank" rel="noopener" href="https://hub.docker.com/r/fmartingr/minidlna-arm">https://hub.docker.com/r/fmartingr/minidlna-arm</a></p><p>这里的网络需要设置，默认下 docker 会使用 docker 网段，所以需要允许容器使用 <code>host</code>，这样方便家庭网络环境中的设备自动寻找，简单来说就是方便电视机主动发现。应用配置没有太多讲究，只需要保证所映射目录下有 <code>Movie</code> , <code>Music</code> , <code>Picture</code> 目录即可，dlna 服务会自动识别</p><p>至于播放器的话，其他平台支持 dlna 的播放器有很多，安卓可以使用 vlc，iOS可以使用 infuse 等等</p><h4 id="Plex">Plex</h4><p>媒体服务还有一个选择：Plex</p><p>可以说 Plex 才是专业的影音库，它可以对你的电影和音乐进行分类，电影可以自动获取电影信息、下载封面等。如果用过早期Windows Vista 或者 7 专业版，都会见到一个叫做 Windows Media Center 的应用，跟这个相似</p><p>具体可以查看官方站点：<a target="_blank" rel="noopener" href="https://www.plex.tv/zh/">https://www.plex.tv/zh/</a></p><h2 id="最后-2">最后</h2><p>总的来说，用 NAS 主要还是存储功能， webdav、time mechine 啥的都可以依赖 NAS 应用（可能）的服务</p><p>但是自己搭建独立服务器目的是「全可控」，例如我现在有些玩具（闹钟，永远滴神），就在依赖这个服务（websocket 拉满！</p><p>比较不推荐的是在家<strong>搭建 Git 服务器</strong>，我不知道普通人有什么样的代码是需要藏着的；还有 <strong>NPM 服务器</strong>，你不会用到几次的，各种镜像源很快，而且 npm 包会塞爆你服务器硬盘</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NAS </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我如何用 hammerspoon 实现剪贴板历史</title>
      <link href="/blog/2020/06/04/hammerspoon-clipboard/"/>
      <url>/blog/2020/06/04/hammerspoon-clipboard/</url>
      
        <content type="html"><![CDATA[<p>这应该是连载得最近的一次，书接上回：<a href="/blog/2020/06/02/hammerspoon-ts/">《或许可以用 TypeScript 编写 hammerspoon》</a>（也就是下面那篇）</p><p>这里只会描述通过 <code>TypeScript</code> 实现的过程</p><p>以下内容可能产生不适（因为<code>hammerspoon</code>的 <code>d.ts</code> 全是 <code>interface</code> 一把梭，编码不好看）</p><h2 id="TL-DR-7">TL;DR</h2><ul><li>创建界面</li><li>实现剪贴板读取</li><li>存储数据</li><li>绑定快捷键</li></ul><span id="more"></span><h2 id="创建界面">创建界面</h2><p><code>hammerspoon</code>有很多种交互接口，其中<code>chooser</code>就是某小黑帽那种对话式弹窗，用这个挺合适的</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">&#x2F;&#x2F; choice 就是当你对着选项按下 enter 之后，这个被选择对象的内容const completionFn &#x3D; choice &#x3D;&gt; &#123;  &#x2F;&#x2F; 一般来说这个判断不可省略，这样可以方便排除取消的情况  if (choice) &#123;&#125;&#125;const chooser &#x3D; hs.chooser.new(completionFn)</code></pre><p>这样<code>chooser</code>就是一个实例，可以使用相应的方法，例如显示或隐藏</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">chooser.show()chooser.hide()</code></pre><h2 id="剪贴板操作">剪贴板操作</h2><p>关于剪贴板的操作都已经封装在<code>hs.pasteboard</code>这个模块中，通过两个函数获取到我们对于剪贴板历史比较常用的两种内容类型</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.readString() &#x2F;&#x2F; 读取最后一次剪贴板的文本pasteboard.readImage() &#x2F;&#x2F; 读取最后一次剪贴板的图片数据</code></pre><p>如何得知我的剪贴板已经有新内容了？社区基本上的方案都是通过对比剪贴次数来判定更新的，如下</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">pasteboard.changeCount()</code></pre><p>所以操作大概是：使用定时器，在若干时间后检查一次次数，如发生改变即更新剪贴板历史</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const clipboard &#x3D; new Clipboard()&#x2F;&#x2F; 我选择 1s 检查一次export const clipWatcher &#x3D; hs.timer.new(1, () &#x3D;&gt; &#123;  const now &#x3D; hs.pasteboard.changeCount()  if (now !&#x3D;&#x3D; preCount) &#123;    pcall(clipboard.save.bind(clipboard))    preCount &#x3D; now  &#125;&#125;)clipWatcher.start()</code></pre><h2 id="操作数据">操作数据</h2><h3 id="识别数据">识别数据</h3><p>只要出现对比差异，就可以执行保存操作</p><p>日常使用中一般会复制到文本和图像（截图），先做到如何区分来源类型</p><p>通过苹果开发者文档关于 <a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">UTI</a>，可以得到大概文本就是<code>public.plain-text</code>，图像就是<code>public.&#123;pic format&#125;</code></p><p>我截图是<code>png</code>的，舍远求近直接只识别我自己使用的两种格式：<code>public.png</code>, <code>public.utf8-plain-text</code></p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">save() &#123;  const types &#x3D; hs.pasteboard.contentTypes&lt;ModelChoice[&#39;type&#39;]&gt;()  for (const type of types) &#123;    if (isImgType(type)) &#123;      this.saveImage(type)    &#125; else if (isTextType(type)) &#123;      this.saveText(type)    &#125;  &#125;&#125;</code></pre><h3 id="保存数据">保存数据</h3><p>对应的，当知道数据来源是什么类型之后就可以<a href="#%E5%89%AA%E8%B4%B4%E6%9D%BF%E6%93%8D%E4%BD%9C">相应操作</a>了</p><p>保存我采用了<code>sqlite</code>，因为 hammerspoon 带了数据库操作模块<code>hs.sqlite3</code>。主要原因：</p><ul><li>timer可能会崩溃导致不会继续捕获，重启服务数据丢失</li><li>数据库查询比较快</li><li>数据库我还另有其用，不亏</li></ul><p>这部分直接看 github</p><h2 id="启用">启用</h2><h3 id="绑定快捷键">绑定快捷键</h3><p>hammerspoon 的快捷键模块<code>hs.hotkey</code>，可以将快捷键绑定到具体操作上</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">hs.hotkey.bind(clipboardConf.hotkey[0], clipboardConf.hotkey[1], () &#x3D;&gt; &#123;  clipboard.show()&#125;)</code></pre><p>一套组合键，<code>chooser</code> 就可以显示了</p><h3 id="加载内容">加载内容</h3><p>一般来说，在显示对话框时再去加载数据可以保证数据是新的，所以使用<code>chooser.choices(choices)</code>加载数据，再<code>chooser.show()</code>展示</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">this.chooser!.choices(choices)this.chooser!.show()</code></pre><p>至于获取数据的形式，就是需要查询数据库，还是查询文件，还是另有其他方式而已</p><h2 id="参考连接">参考连接</h2><p><a target="_blank" rel="noopener" href="https://ahonn.me/blog/how-to-implement-clipboard-history-with-hammerspoon">《如何使用 Hammerspoon 实现剪贴板历史》 —— Ahonn</a><br><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/FileManagement/Conceptual/understanding_utis/understand_utis_conc/understand_utis_conc.html#//apple_ref/doc/uid/TP40001319-CH202-CHDHIJDE">Uniform Type Identifier Concepts</a></p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> hammerspoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>或许可以用 TypeScript 编写 hammerspoon</title>
      <link href="/blog/2020/06/02/hammerspoon-ts/"/>
      <url>/blog/2020/06/02/hammerspoon-ts/</url>
      
        <content type="html"><![CDATA[<p><code>lua</code> 这个语言真的有意思，它由 C 语言构成，又实现了 C 语言所没有的「对象」。早在不知道哪年搞 <code>cocos2d</code> 的时候，就接触了这个语言</p><p><code>hammerspoon</code> 也不是什么新鲜东西了，早在 18 年，公司内部一次「杂鱼分享会」就有人提到了这个工具 —— 快速将光标切到目标显示器以及窗口调整</p><p>早期是用过一段时间，写了一个代替小黑帽🎩的工具，后来不了了之。主要还是觉得现在不想用这个语言，太阴间了</p><p>当然还有其他方案，比如常见的用到了 <code>moonscript</code>，这是一个类 <code>coffeescript</code> 的语言，属于 lua 生态圈的东西。但用这个就意味着你需要在本机构建一个 lua 环境（luarock），这么一想那不想干了，现在不用 lua 了还留一个完全不用的开发环境</p><p>前些日子关注到有一个项目 <a target="_blank" rel="noopener" href="https://github.com/TypeScriptToLua/TypeScriptToLua">TypeScriptToLua / TypeScriptToLua</a>，一直没尝试，这波机会刚好。而且老前端了，谁还没有个 typescript/node 环境呢</p><span id="more"></span><h2 id="安装">安装</h2><p>虽然是个编译工具，但没必要全局安装，<code>npm init</code> 一个项目出来，直接用即可</p><pre class="line-numbers language-none"><code class="language-none">npm inityarn add typescript-to-lua --dev</code></pre><p>然后在 <code>package.json</code> 的 <code>script</code> 中加一行<code>build</code></p><pre class="line-numbers language-none"><code class="language-none">&quot;dev&quot;: &quot;tstl --watch&quot;,&quot;build&quot;: &quot;tstl&quot;</code></pre><p>也就能用了。建议是看一下<a target="_blank" rel="noopener" href="https://typescripttolua.github.io/docs/getting-started">这个文档</a>，有一些需要「通过类型文件也就是 d.ts 来控制产物」的文档，还是有必要读一下的</p><h2 id="梭">梭</h2><h3 id="类型文件">类型文件</h3><p>有需要的朋友可以看一下我的 <a target="_blank" rel="noopener" href="https://github.com/colmugx/dotfiles/blob/master/hammerspoon/src/typings.d.ts">typings.d.ts</a>，真的靠<code>interface</code>一把梭，不考虑程序设计，只求能 work</p><p>当然这个「不合理」是要解决的，择日解决完之后，发个包，封装一下</p><h3 id="注意点">注意点</h3><h3 id="函数、方法">函数、方法</h3><p>开发的这个过程是没有什么点，不要玩花，正常使用<code>typescript</code>即可。只是通过这次重构，我才领悟到「方法」和「函数」的区别…</p><p>hammerspoon docs 提到函数其实就是 <code>static</code>，表现是<code>.</code>连接的；而实例化之后所使用的方法，是<code>:</code>连接的。所以这里要注意的就是产物的<code>self</code>指向。函数的话需要在 d.ts 中写上<code>@noSelf</code>，不然编译时会被改成<code>:</code></p><h3 id="pcall">pcall</h3><p>一个执行函数的函数，这里有一个坑：被执行的函数需要指定一下<code>this</code>，也就是<code>xxx.bind(Cla)</code>，不然会因为<code>self</code>指向了全局而触发不到对应的方法</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
            <tag> hammerspoon </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>docker 容器内通信</title>
      <link href="/blog/2020/03/29/docker-container-bridge/"/>
      <url>/blog/2020/03/29/docker-container-bridge/</url>
      
        <content type="html"><![CDATA[<p>除了正常工作（特殊时期太搞人了，虽然我一直在 remote…），最近也在准备一个专栏，同时也在找文本存储或者说自己喜欢的笔记方案。我对数据的掌控性有些洁癖，不是很想用 Bear 这类东西，也摸不着头脑所以退而求其次有一段时间依赖 iCloud</p><p>最后整了一个本地 webdav 😆</p><p>当然商业网盘支持 WebDav 国内公司也有的，就曾四处安利过的坚果云</p><p>docker 好东西啊，一个宿主，一堆容器，互相隔离又互相吸引。自然 nextcloud 和数据库理所当然的处于两个容器。既然同 host 下，那容器应该内网连接就行了，这么一来人懵了</p><p>**两个容器不在一个网段内…**因为有一个容器是处于一个 stack 内的</p><p>所以，水一篇文，单纯记录一下</p><span id="more"></span><h2 id="解决方案">解决方案</h2><p>用 <code>--link</code> 参数确实可以让容器联系起来，但想着就觉得可能会出现无法维护的情况。而且 docker 是有 <code>network</code> 的，最好还是通过创建不同的「内网」使容器可以在「正确的网路」内相互通信</p><h3 id="创建网络">创建网络</h3><p>这类操作要的只是一个网桥，所以创建一个桥叫做<code>my-bridge</code></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker network create -d bridge my-bridge</code></pre><h3 id="连接容器">连接容器</h3><p>家庭服务我是上了 <code>dashboard(portianer)</code> 的，所以两个容器在 <code>network</code> 区分别下拉拿到网桥点击添加就完事了，谁愿意写命令啊毕竟在家装b没人看（X</p><p>用命令行的话也就是把控制台自动做的繁琐操作手动做了一遍 —— 关掉容器然后添加 <code>--network</code> 运行容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">docker run --network my_bridge [...]</code></pre><p>PS：吐槽一下自己的文章分类，是时候应该整理一下了，或者好几年前开个文章编辑器坑要填上了……</p><p>PPS：nextcloud 是 <code>php + apache</code> 产品…意思就是找替代品是板上钉钉……</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用 Context 传递多语言文本</title>
      <link href="/blog/2020/01/31/react-translate/"/>
      <url>/blog/2020/01/31/react-translate/</url>
      
        <content type="html"><![CDATA[<p>Gatsby 比 Hexo 更像一个通用框架，关于博客的工具真是全靠社区衬托。Nlvi 迁移遇到了标签云和分类等各种问题，还有一个多语言问题…</p><p>找了一圈插件，i18n 大多数方案都是「一个站点同时多语言」，这对一个博客来说没必要啊（相对来说我博文是不是也得写个几份…），想了一圈好像也没必要上<code>react-intl</code>，直接手作一个吧 —— 按照**「好看的皮囊千篇一律」**写一个</p><p>但是主题毕竟是要开源的，所以如果有好兄弟萌觉得 i18n 处理不行，自行替换成 <code>gatsby-plugin-i18n</code> 或者 <code>react-intl</code> 就可以了</p><span id="more"></span><h2 id="Context">Context</h2><p>直接从 react 分出 <code>createContext</code> 方法，直接用</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">import &#123; createContext &#125; from &#39;react&#39;const langContext &#x3D; createContext(&#123;&#125; as ContextInterface)&#x2F;&#x2F; 创建上下文后输出 Provider 和 Consumer 还是要的export const Provider &#x3D; langContext.Providerexport const Consumer &#x3D; langContext.Consumer&#x2F;&#x2F; ps: 其实 Consumer 用不上...</code></pre><h2 id="生成翻译">生成翻译</h2><p>hexo 版 nlvi 已经有语言文件，所以直接拿过来放到<code>lang</code>文件夹下，然后每个文件通过 yaml2json 转成<code>json</code>，简单一点就不上 yaml 了</p><p>大概思路就是：</p><ul><li>设定是通过主题的 <code>options</code> 传入 <code>lang</code> 属性，然后 <code>lang</code> 写到 <code>siteMetadata</code> 中</li><li>由 <code>layout</code> 读取语言，传入翻译生成文本，传入 <code>Provider</code></li><li>使用的地方使用 <code>formatMessage</code> 去接</li></ul><p>所以也就是接地气且极其简化啥都不考虑保证数据存在版的<code>react-intl</code>。方法可以这么写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const genTranslate &#x3D; (lang: string) &#x3D;&gt; &#123;  const _message &#x3D; require(&#96;@&#x2F;lang&#x2F;$&#123;lang&#125;.json&#96;)  if (!_message) &#123;    throw Error(&#96;$&#123;lang&#125; language json was not found.&#96;)  &#125;  const formatMessage &#x3D; (&#123; id, defaultMsg &#125;: FormatMessageType): string &#x3D;&gt;    &#x2F;&#x2F; _get 来自 lodash    _get(_message, id) || defaultMsg || &#39;&#39;  const formatter &#x3D; () &#x3D;&gt; (&#123; formatMessage, _message &#125;)  return formatter()&#125;</code></pre><h2 id="使用翻译">使用翻译</h2><p>直接用 <code>useContext</code> 去接，2020年该跟风用 hooks 了（大雾</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">export const useIntl &#x3D; (): ContextInterface &#x3D;&gt; useContext(langContext)</code></pre><p>所以这么写的话，只要在 <code>layout</code> 下的组件都可以用这个方式拿到翻译</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const &#123; formatMessage: t &#125; &#x3D; useIntl()</code></pre><p>这样一来其实跟使用 <code>react-intl</code> 是差不多的，就算日后要改也应该不用动业务代码</p><p>所以刚刚那句话还差一半来着？另一半应该是**「糜烂的灵魂（?）凑合对付」**！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> i18n </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>创建一个 rust web server</title>
      <link href="/blog/2019/12/29/try-actix/"/>
      <url>/blog/2019/12/29/try-actix/</url>
      
        <content type="html"><![CDATA[<p>玩了一段时间 Vapor，想不明白谁家会用 swift 跑生产，可能也就 <code>perfect</code> 维护者背后的公司会用，至少在拆哪应该还是要快(la)准(man)狠(kpi)的。<br>rust 社区中关注了 <code>rocket</code> 一段时间，后面发现 <code>actix-web</code> 在各方面更有优势，加上要好好点 rust 技能树，所以就选定这个了。</p><p>这里会以重构我的闹钟后端作为蓝本，逐步做个记录。</p><h2 id="TL-DR-12">TL;DR</h2><ul><li>直接用 <code>cargo</code> 创建应用</li><li>装载 <code>actix-web</code></li><li>写一个 api</li></ul><span id="more"></span><h2 id="创建应用-2">创建应用</h2><p>官方没有开箱即用的模板，所以还是从<code>cargo new</code>开始，这里定义了默认使用<code>git</code>作为版本控制</p><blockquote><p>&gt; cargo new --vcs git actix-demo</p></blockquote><p>在<code>Cargo.toml</code>中添加这些</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]actix-web &#x3D; &quot;2.0&quot;actix-rt &#x3D; &quot;1.0&quot;# envdotenv &#x3D; &quot;0.15.0&quot;log &#x3D; &quot;0.4.8&quot;env_logger &#x3D; &quot;0.7.1&quot;</code></pre><p>然后在<code>main.rs</code>创建启动函数</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use actix_web::&#123;App, HttpServer, get&#125;;#[get(&quot;&#x2F;&quot;)]fn index() -&gt; HttpResponse &#123;    HttpResponse::Ok().body(&quot;Hello World&quot;)&#125;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new().service(index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await&#125;</code></pre><p>一般来说这样就可以运行了</p><h2 id="配置应用">配置应用</h2><p>按照习惯，工程结构还是愿意设置成这样：</p><ul><li>controller</li><li>services</li><li>models</li><li>middleware</li></ul><p>所以目录先确定下来：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">+-- src| +-- controller| | +-- mod.rs| +-- services| | +-- mod.rs| +-- models| | +-- mod.rs| +-- middleware| | +-- mod.rs</code></pre><p>为什么每个目录下都需要<code>mod.rs</code>？原因是人家<code>rust</code>对模块就是这么处理的啊！</p><p>接着，<code>Cargo.toml</code>需要加点东西，比如<code>json</code>的支持（可是你用的不是 GraphQL 吗！）</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]# serdeserde &#x3D; &quot;1.0.104&quot;serde_derive &#x3D; &quot;1.0.104&quot;serde_json &#x3D; &quot;1.0.44&quot;json &#x3D; &quot;0.12.0&quot;</code></pre><p>接下来对代码作出一些改动，首先是一个通用的<code>json</code>结构体，创建 <code>models/payload</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use serde_derive::&#123;Serialize, Deserialize&#125;;#[derive(Serialize, Deserialize, Clone)]pub struct Payload&lt;T&gt; &#123;    pub code: isize,    pub message: String,    #[serde(skip_serializing_if &#x3D; &quot;Option::is_none&quot;, default)]    pub payload: Option&lt;T&gt;,&#125;</code></pre><p>接着，从<code>controller/index</code>开始</p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[derive(Deserialize)]struct Info &#123;    message: String&#125;#[get(&quot;&#x2F;&quot;)]pub async fn index(query: web::Query&lt;Info&gt;) -&gt; Result&lt;HttpResponse, Error&gt; &#123;    &#x2F;&#x2F; 在Query拿到与 Info 结构一样的参数    &#x2F;&#x2F; 如果你这么写，那么如果调用时如果不传 query 会报错，param 同理    &#x2F;&#x2F; rust 真严格..    let result &#x3D; crate::services::index::get_helloworld(query.message.clone());    Ok(HttpResponse::Ok().json(result))&#125;</code></pre><p>然后，<code>services/index</code>，暂时不用<code>middleware</code></p><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use crate::models::payload::Payload;&#x2F;&#x2F; 简单写一个服务pub fn get_helloworld(msg: String) -&gt; Payload&lt;()&gt; &#123;    Payload &#123;        code: 0,        message: msg.to_string(),        payload: None    &#125;&#125;</code></pre><p>最后改一下<code>main.rs</code></p><pre class="line-numbers language-diff" data-language="diff"><code class="language-diff">+mod controllers;+mod models;+mod services;#[actix_rt::main]async fn main() -&gt; io::Result&lt;()&gt; &#123;    let app &#x3D; || App::new()-        .service(index);+        .service(controllers::index::index);    info!(&quot;serving on localhost:7001&quot;);    HttpServer::new(app)        .bind(&quot;localhost:7001&quot;)?        .run()        .await</code></pre><p>测试一下，调用 <code>localhost:7001?message=helloworld</code>，就可以看到回复了！</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;    &quot;code&quot;: 0,    &quot;message&quot;: &quot;helloworld&quot;&#125;</code></pre><p>代码里我其实还用这些：</p><ul><li><code>router</code></li><li>写了一个配置的结构体用来封装 HOST, PORT 和数据库地址</li><li>环境变量配置</li></ul><p>文章就不写了，大概就那样。</p><h2 id="后记">后记</h2><ul><li>建议用 CLion，VSCode 和 VIM 实在是太… IDE 也好，数据库分步调试什么的很方便</li><li>没 key 怎么办，找一个长期维护的开源项目，嫖就完事儿了</li><li>前端本来也想用<code>rust(yew)</code>的，可是在<code>raspbian</code>运行，不清楚结果。也不清楚其他选型，所以只能继续<code>electron + react</code>了，可能会去掉<code>umi</code></li></ul><p>下一期整数据库连接</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> actix </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如果我把 Rust 用在网页呢</title>
      <link href="/blog/2019/10/13/try-wasm/"/>
      <url>/blog/2019/10/13/try-wasm/</url>
      
        <content type="html"><![CDATA[<p>已知<code>Rust</code>是个很硬核的编程语言</p><p>又已知<code>JavaScript</code>或者说在浏览器上的<code>JavaScript</code>在某种情况无法胜任工作。</p><p>So？</p><blockquote><p>🦀 Rust + 🕸 Wasm = ❤</p></blockquote><p>但是，单纯把教程或者 tutorial 拿出来复述是没意思的。So，搞点事情</p><p>那么前提是，你已经弄清楚了 <code>wasm-pack</code> 是怎么回事了</p><span id="more"></span><h2 id="题干？">题干？</h2><p>最近着手一个项目，使用浏览器的<code>crypto</code>实现了加解密，加解密都需要在浏览器处理。但毕竟解释型，最多只是混淆。即使我在编写时已经使用了花里胡哨的东西，就差整上钓鱼的那套手段了。不过，毕竟二进制的东西，总比混淆型更不容易肉眼解析，人脑编译</p><p>这里倒是可以交代，我用到了<code>aes-256-cfb</code>，所以我们大概需要这些东西</p><h2 id="板条箱？">板条箱？</h2><p>毕竟是 Rust，注定是“简陋”的，所以我决定直接去找现有的密码学类库。目前已经亲测的密码学库有：</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/DaGenix/rust-crypto">DaGenix/rust-crypto</a></li><li><a target="_blank" rel="noopener" href="https://github.com/RustCrypto">RustCrypto 系列</a></li></ul><p>如果运行在 <code>wasm</code>，第一个库需要使用另外一个有针对适应的</p><ul><li><a target="_blank" rel="noopener" href="https://github.com/buttercup/rust-crypto-wasm">buttercup/rust-crypto-wasm</a></li></ul><p>在写文章前我已经都“绕”过一遍了…在这之间反复横跳。刚开始以为这些库无法适用<code>wasm</code>（报错无法定位），后来觉得用起来好难（写得很绕），再后来发现是我写错了…</p><p>接着，可能需要一个随机数库，只能是<code>rand</code>了，而且也是<code>crates.io</code>下载量最多的（为什么…）</p><h2 id="创建？">创建？</h2><blockquote><p>&gt; cargo generate --git <a target="_blank" rel="noopener" href="https://github.com/rustwasm/wasm-pack-template">https://github.com/rustwasm/wasm-pack-template</a></p></blockquote><p>接着，安排上依赖</p><pre class="line-numbers language-toml" data-language="toml"><code class="language-toml">[dependencies]wasm-bindgen &#x3D; &quot;0.2&quot; # 核心rand &#x3D; &quot;0.7.2&quot; # 但接下来用不上aes &#x3D; &quot;0.3.2&quot; # 添加这个只是为了分组依赖与类型cfb-mode &#x3D; &quot;0.3.2&quot; # 这个才是加密核心</code></pre><p>然后运行一遍<code>cargo build</code>或者<code>wasm-pack build</code>，因为<code>rust</code>在编译时会检查依赖情况，所以索性我就直接通过这种方式安装依赖了，就像写<code>swift</code>随手<code>cmd + b</code></p><h2 id="食用？">食用？</h2><h3 id="编译源码">编译源码</h3><ol><li>加载 crate（上板条！）</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">extern crate aes;extern crate cfb_mode;</code></pre><ol start="2"><li>声明依赖，或者说<code>import</code></li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">use aes::Aes256; &#x2F;&#x2F; 使用 256use cfb_mode::stream_cipher::&#123;NewStreamCipher, StreamCipher&#125;; &#x2F;&#x2F; cfb是基于流加密其中一种use cfb_mode::Cfb; &#x2F;&#x2F; 需要用这个结构体</code></pre><ol start="3"><li>声明一个类型别名，方便使用<br>Rust 可以声明类型别名。为了后面方便实用，定义一个</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">&#x2F;&#x2F; 使用 Cfb 结构体作为加密类型，Cfb 本身又需要一个类型…使用 Aes256 结构体声明长度type AesCfb &#x3D; Cfb&lt;Aes256&gt;;</code></pre><ol start="4"><li>随便写个加密</li></ol><pre class="line-numbers language-rust" data-language="rust"><code class="language-rust">#[wasm_bindgen]pub fn test() -&gt; Vec&lt;u8&gt; &#123;  let key: &amp;[u8; 32] &#x3D; b&quot;nashizhendeniup,,nashizhendeniup&quot;;  let iv: &amp;[u8; 16]  &#x3D; b&quot;unique,un,unique&quot;;  let msg &#x3D; &quot;那你是真的牛皮&quot;;  let mut buffer &#x3D; msg.as_bytes().to_vec();  AesCfb::new_var(key, iv).unwrap().encrypt(&amp;mut buffer);  buffer&#125;</code></pre><h3 id="到前端使用">到前端使用</h3><p>经过编译<code>wasm-pack build</code>，可以得到一个<code>pkg</code>目录。目录下的文件就很熟悉了！</p><ul><li>package.json</li><li>&lt;xxx&gt;.wasm</li><li>&lt;xxx&gt;.d.ts</li><li>……</li></ul><p>你甚至可以直接把这个包上到<code>npm</code>，让更多人可以使用。这里我们就只是<code>yarn link</code>，然后创建一个前端项目</p><blockquote><p>&gt; npm init wasm-app www</p></blockquote><p>接着，有着 50 年前端经验的老前端应该都会接下来的步骤了：<code>yarn</code> -&gt; <code>yarn link &lt;xxx&gt;</code></p><p>然后，把<code>JavaScript</code>的代码改改</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">import &#123;test&#125; from &#39;crypto-test&#39;console.log(test())</code></pre><p>因为 <code>Rust</code> 是强类型的语言，所以在类型推断不会有太多麻烦。同时，在通过工具编译到<code>wasm</code>时会多编译一个<code>d.ts</code>文件。这样，就算暴露给<code>JavaScript</code>的代码再复杂，只要使用 VSCode 或者支持 TS 的 Language Server 也没有太大压力</p><p>所以这样我就得到一个加密数据集合，<code>Vec&lt;u8&gt;</code>到<code>JavaScript</code>那边会直接变成<code>UTF8</code>类型数组，所以我们会打印出这东西</p><pre class="line-numbers language-none"><code class="language-none">Uint8Array(21) [230, 156, 59, 211, 78, 162, 142, 118, 193, 154, 45, 255, 203, 56, 123, 8, 143, 173, 46, 120, 25]</code></pre><p>用<code>node</code>的话，一般会把加密数据转成字符串保存（比如我提到的我在做的项目），这里就先裸着吧</p><p>那<code>wasm</code>画风是怎样的呢？给个节选参考一下</p><pre class="line-numbers language-none"><code class="language-none">  get_local $p0  i32.load  get_local $p1  call $core::fmt::Write::write_char::h90a3bac002e2aa8d)(func $&lt;&amp;T_as_core::fmt::Debug&gt;::fmt::h110ce52a73dd639b (type $t6) (param $p0 i32) (param $p1 i32) (result i32)  get_local $p0  i32.load  get_local $p1  call $core::fmt::num::&lt;impl_core::fmt::Debug_for_usize&gt;::fmt::hf84d386a4f5a1afb)(func $__rdl_dealloc (type $t7) (param $p0 i32) (param $p1 i32) (param $p2 i32)  i32.const 1056732  get_local $p0</code></pre><p>看得我都有女装的冲动了（大雾</p><h2 id="结束？">结束？</h2><p>文章的目标只有两个：</p><ul><li>体验<code>rust + wasm</code></li><li>干一手加密，看看是否能取代浏览器的<code>crypto</code>，不考虑性能</li></ul><p>因为<code>Rust</code>的发展快接近完整了，这个时候入坑应该挺合适。所以接下来我就指望靠这个语言接近计科的世界了</p><p>最后，有一点需要注意，所选择的<code>AES</code>长度不同，会影响你需要的秘钥长度。所以，这个时候可以唠唠加密？</p><h2 id="（附加资料）加密？">（附加资料）加密？</h2><h3 id="分组密码">分组密码</h3><p>分组密码将明文分成多个等长的模块（block），使用确定的算法和对称密钥对每组分别加密解密。所以，这种加密方式带来的问题就是：对越长的字符串进行加密，代价越大</p><h3 id="AES">AES</h3><p>对称加密的一种（对称加密就不解释了），也是目前最流行的对称加密算法之一。该算法属于分组加密算法。</p><p>AES的区块长度固定为128比特，密钥长度则可以是128，192或256比特。</p><p>加密方式也有很多模式：ecb, cfb, gcm, cbc。其中 ecb 没有 iv</p><p>我们在使用密码库的时候，都会接触到 <code>key</code>, <code>iv</code> 还有可能需要<code>padding</code></p><h4 id="iv">iv?</h4><p>初始化向量（IV，Initialization Vector）是许多任务作模式中用于将加密随机化的一个位块，由此即使同样的明文被多次加密也会产生不同的密文，避免了较慢的重新产生密钥的过程。</p><p>在大多数情况中，不应当在使用同一密钥的情况下两次使用同一个IV。对于CBC和CFB，重用IV会导致泄露明文首个块的某些信息，亦包括两个不同消息中相同的前缀。对于OFB和CTR而言，重用IV会导致完全失去安全性。</p><p>一般来说，向量用于分组加密中其中第一个块的加密，其他块均为自动生成（就是提供向量）</p><h4 id="key">key?</h4><p>加密密钥，对于 aes 来说就是每个块使用到的加密密钥</p><h4 id="padding">padding?</h4><p>padding 是用来填充最后一块使得变成一整块，所以对于加密解密两端需要使用同一的 PADDING 模式，大部分 PADDING 模式为PKCS5, PKCS7, NOPADDING。</p><h3 id="AES256-128">AES256? 128?</h3><p>其中，<code>iv</code>肯定是 16 位。因为加密块的长度就是这么限制的</p><p>区别在于密钥长度，<code>Aes128</code> 的密钥长度需要 16 位，而 <code>Aes256</code> 需要的密钥长度是 32 位</p><p>为什么呢？算一下不就知道了</p><h3 id="AES256CFB">AES256CFB?</h3><p>就是使用 aes，长度 256，那么 cfb 呢？</p><p>密文反馈（CFB，Cipher feedback），可以理解是反向 CBC，因为 CFB 的解密过程几乎就是颠倒的CBC的加密过程</p><p>那，也不用想太多，就是使用 AES 加密，长度使用 256，模式使用 cfb</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> rust </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自 swift 的跨界执法（一） —— Vapor</title>
      <link href="/blog/2019/06/23/try-vapor-0/"/>
      <url>/blog/2019/06/23/try-vapor-0/</url>
      
        <content type="html"><![CDATA[<p>Vapor 应该是目前比较成熟的服务器应用框架了，更新快，社区“繁荣”</p><p>所以，直接干吧</p><span id="more"></span><h2 id="安装-3">安装</h2><p>直接装个工具集吧</p><pre class="line-numbers language-none"><code class="language-none">brew tap vapor&#x2F;tapbrew install vapor&#x2F;tap&#x2F;vapor</code></pre><h2 id="生成应用">生成应用</h2><pre class="line-numbers language-none"><code class="language-none">vapor new Hello</code></pre><p>等待一会，出现水滴图案时就初始化完成了</p><p>接着进目录，生成<code>xcode</code>可以使用的工程文件</p><pre class="line-numbers language-none"><code class="language-none">.&#x2F;Hellovapor xcode</code></pre><p>依然是等待一会之后，<code>cmd</code>会询问你是否打开<code>XCode</code>，打开便是</p><h2 id="编写体验-2">编写体验</h2><p>vapor 默认会给几种方案，如果直接 new 的话默认是<code>api</code>方案，也就是“接口服务器”。</p><p>所以一打开，就能看到工程已经被“安排好了”：一般所需要的目录结构，以及默认使用<code>SQLite3</code>数据库（运行在内存）</p><p>本来我打算通过<code>Todos</code>练练手，现在看起来好像参考答案已经给出来了…默认情况下也不需要怎么去补充，按照自己的编程习惯直接用就行了。</p><p>但这里用内存数据库属实8合适，所以改一下数据库存储方式</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">&#x2F;&#x2F; DirectoryConfig.detect().workDir 项目绝对路径let storePath &#x3D; DirectoryConfig.detect().workDir + &quot;Db&#x2F;store.db&quot;let sqlite &#x3D; try SQLiteDatabase(storage: .file(path: storePath))</code></pre><p>这样一来就把数据库位置移动到工程中<code>Db</code>目录下了，第一次运行就会直接创建数据库</p><p>对了，Vapor 自己带一个 ORM <code>Fluent</code>，所以关系型数据库操作不会太操蛋</p><p>所以下一篇应该是讨论一个更合适的<code>restful</code>写法？或者是用上<code>gRPC</code>？</p><h2 id="相关信息">相关信息</h2><p>Vapor 自己提供一个<a target="_blank" rel="noopener" href="http://vapor.university/">「大学」</a>，这里都是组织自己录的教学视频，基本点都涵盖到了</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> vapor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来自 swift 的跨界执法（零） —— Perfect</title>
      <link href="/blog/2019/06/07/try-swift-perfect/"/>
      <url>/blog/2019/06/07/try-swift-perfect/</url>
      
        <content type="html"><![CDATA[<p>因为不可抗力没上班，看着新<code>swift</code>和<code>swiftUI</code>发布，决定搞<code>Perfect</code>。</p><p>这个框架可是听说很久了，匆忙看了两眼就没有下文。当时来说是最强 Server-site 框架（为什么要说当时？）</p><p>篇幅不长，仅做一个尝试和介绍，原因在最后。</p><h2 id="安装-2">安装</h2><p>安装还是相当容易，官方编译器起一个可执行类型项目</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift package init --type&#x3D;executable</code></pre><span id="more"></span><p>其次，在<code>Package.swift</code>中添加依赖</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">dependencies: [    .package(url: &quot;https:&#x2F;&#x2F;github.com&#x2F;PerfectlySoft&#x2F;Perfect-HTTPServer.git&quot;, from: &quot;3.0.0&quot;)],</code></pre><p>接着，编译即安装依赖（熟悉啊！）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift build</code></pre><p>最后，生成<code>xcodeproj</code>文件以<code>xcode</code>打开，接下来工作交还给<code>xcode</code></p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">swift package generate-xcodeproj</code></pre><p>不得不说，你果<code>XCode</code>到从系统<code>10.10</code>开始那会到如今 9102 年了，体验还是这么糟糕。然而苹果家的两个语言，不用<code>XCode</code>体验更糟…</p><h2 id="编写体验">编写体验</h2><p>初始化项目什么目录都没有，作为一个毫无后端经验的 API 拼装师，只能假把式创建<code>controllers</code>与<code>models</code>目录，加上习惯加一个<code>constant</code>目录。</p><p><s>后来发现，我好像用不上</s></p><p>按照习惯创建了一个结构体用来存放配置内容</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">struct GlobalConfig &#123;    let baseRoute &#x3D; &quot;&#x2F;api&#x2F;v1&quot;    let httpPort &#x3D; 8081&#125;</code></pre><p>接着，清空<code>main.swift</code>，根据<code>swift</code>的逻辑：只有库需要引用，业务文件同一项目下不需要<code>import</code>。所以引入<code>perfect</code>，并初始化</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">import PerfectHTTPimport PerfectHTTPServer&#x2F;&#x2F; 字典不是JSON，使用库中方法得以把字典转为JSONimport PerfectLiblet config &#x3D; GlobalConfig()let server &#x3D; HTTPServer()var routes &#x3D; Routes(baseUri: config.baseRoute)</code></pre><p>然后制定一个<code>restful</code>类型路由（原本写在<code>Router.swift</code>）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">let list: [[String: Any]] &#x3D; [    [&quot;name&quot;: &quot;index&quot;, &quot;url&quot;: &quot;&#x2F;home&quot;, &quot;method&quot;: HTTPMethod.get],    [&quot;name&quot;: &quot;show&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.get],    [&quot;name&quot;: &quot;create&quot;, &quot;url&quot;: &quot;&#x2F;home&quot;, &quot;method&quot;: HTTPMethod.post],    [&quot;name&quot;: &quot;update&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.put],    [&quot;name&quot;: &quot;delete&quot;, &quot;url&quot;: &quot;&#x2F;home&#x2F;&#123;id&#125;&quot;, &quot;method&quot;: HTTPMethod.delete]]</code></pre><p>接着，通过<code>swift</code>的<code>map</code>（不是很合适）随便载入一套路由（有时候真的恨<code>swift</code>的类型安全）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">RoutesConfig().list.map &#123;    routes.add(method: $0[&quot;method&quot;] as! HTTPMethod, uri: $0[&quot;url&quot;] as! String, handler: &#123; (request, response) in        let json: [String: Any] &#x3D; [&quot;code&quot;: 0, &quot;message&quot;: &quot;success&quot;]        let variables &#x3D; request.urlVariables        var newJson &#x3D; json        if (!variables.isEmpty) &#123;            for e in variables &#123;                newJson[e.key] &#x3D; variables[e.key]            &#125;        &#125;        let output &#x3D; try! newJson   &#x2F;&#x2F; 因都是字面量，所以必有值（真nm安全，业务尽量不要这么搞）            .jsonEncodedString()        response            .setHeader(.contentType, value: &quot;application&#x2F;json&quot;)            .appendBody(string: output)            .completed()    &#125;)&#125;</code></pre><p>路由载入服务并指定端口（直接执行会默认<code>0.0.0.0:8081</code>）</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">server.addRoutes(routes)server.serverPort &#x3D; UInt16(config.httpPort)</code></pre><p>最后（简单）执行</p><pre class="line-numbers language-swift" data-language="swift"><code class="language-swift">do &#123;    try server.start()&#125; catch &#123;    fatalError(&quot;\(error)&quot;)&#125;</code></pre><h2 id="原因">原因</h2><ul><li>文档虽是详细，但是周边很少，社区冷淡（都不知道有没有）。而且资料很少，很难查到关于这个框架的讨论或者内容。</li><li>Star 虽然证明不了什么，但是从昔日第一，到现在第二，距离第一也有很大差距。又语言关系，并不会有像某些库那样的宗教化。故必有某些原因。</li></ul><p>所以，你好<code>Vapor</code>！这可能是目前<code>swift server side</code>最优解决方案。并且这也是标题从“零”开始的原因。</p><p>并且在文章提交之前，发现<code>Vapor</code>已经支持<code>Swift 5.1</code>，本体也更新频繁，大概知道为什么<code>Perfect</code>为什么会没落了。</p><p>不过，我觉得可以先尝试<code>Vapor</code>，再看看哪个使用手感更适合我。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> swift </tag>
            
            <tag> perfect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>react函数级写法和继承写法有什么区别？</title>
      <link href="/blog/2019/05/28/react-component-method/"/>
      <url>/blog/2019/05/28/react-component-method/</url>
      
        <content type="html"><![CDATA[<p>这问题真的是土到我了，立刻就发了一个知乎想法。但后来我发现，他会不会想问的是几百年前，在盘古开天辟地之后的<code>react 0.x</code>时代，于是我默默把想法干掉了。</p><p>如果是<code>createClass</code>和<code>extends React.Component</code>，还有点意思。如果是<code>functional component</code>，那您怎么不用同样很「渐进式」同时又更牛逼的<code>vue</code>呢？</p><p>简单对比：</p><table><thead><tr><th style="text-align:center">createClass</th><th style="text-align:center">Component/PureComponent</th></tr></thead><tbody><tr><td style="text-align:center">ES5</td><td style="text-align:center">ES6</td></tr><tr><td style="text-align:center">propTypes/getDefaultProp</td><td style="text-align:center">Component.defaultProps/Component.propType</td></tr><tr><td style="text-align:center">this 已被指定</td><td style="text-align:center">属性 this 不默认指向组件（实例）</td></tr><tr><td style="text-align:center">mixin</td><td style="text-align:center">mixin（被取消，不建议，做不到，HOC）</td></tr></tbody></table><p>其中对我来说，这两个的区别可能<code>mixin</code>最有意思</p><span id="more"></span><h2 id="编写风格">编写风格</h2><p><code>createClass</code> 用的是给函数传递一个对象的方式创建组件，风格很像<code>vue</code>，<code>Component</code>用的是对象继承的方式创建组件。好像没什么好说的。</p><h2 id="default-props">default props</h2><p><code>createClass</code>依然跟现在的<code>vue</code>写法很像，不过从<code>vue</code>中<code>props[xxx].default</code>变成<code>getDefaultProp</code>方法，同时对象内通过<code>propTypes</code>做接口类型检查。</p><p><code>classes</code>型的默认接口和接口检查都是来源于对象两个静态对象。</p><h2 id="this">this</h2><p><code>createClass</code>同样与<code>vue</code>差不多，<code>this</code>会指向到组件上，应该还是处于同一对象中的原因。<code>classes</code>类型的可没那么顺利，<code>this</code>会指向到类上，所以写<code>react</code>的时候，方法难免还要在构造函数中<code>bind</code>一次，当然如果方法是箭头函数的话麻烦少很多。</p><h2 id="mixin">mixin</h2><p><code>createClass</code>依然与<code>vue</code>的差不多（<code>vue</code>抄得妙啊），遗憾<code>classes</code>不支持<code>mixin</code>了。</p><p>我也不喜欢<code>mixin</code>，也觉得这东西不适合<code>react</code>的理念。<code>mixin</code>是把一个对象的内容与另一个对象的内容合并，看起来复用性利用率很高（别bb抽就完事儿了嗷），但，同名函数怎么办？改动怎么办？东西一多就沉浸在不断重写<s>与复读</s>，造成副作用，牵一发而动全身的情况。</p><p>高阶函数多好，编写一个可复用函数，把计划使用复用内容的函数或对象以参数形式传入，在使用组件或者函数的同时又把复用内容执行完。首先<code>HOC</code>可以想象成是「悠米」——它挂在你身上，加盾，加速，加血，加自适应。它挂在谁身上都一样，不受干扰。</p><blockquote><p>只要我的队友还活着，我就不会遭受苦难 —— 悠米</p></blockquote><p>而每次经过高阶函数之后又是一个新的函数，每个新函数相对独立，不存在副作用。</p><p>但<code>HOC</code>写起来还是有两种，以<code>react</code>返回<code>Component</code>来说，返回的对象又会有两种。</p><ul><li>返回的<code>Component</code>继承于全新的<code>React.Component</code>(react-redux:connect)</li><li>返回的<code>Component</code>继承于参数的<code>Component</code>(反向继承)(reabit:inject)</li></ul><p>第一种最后的结果是<code>render</code>时以组件的形式调用参数，第二种则是通过<code>super</code>在各种地方执行（整个方法执行直接在构造函数执行<code>super([传入适用原组件props])</code>），各有利弊。</p><p>而因为反向继承的关系，我可以获得组件很多内容，所以某种意义上可以当做<code>mixin</code>使用。</p><p>不过毕竟<code>HOC</code>，有一个问题：原组件如果存在<code>static</code>方法将不能被使用。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
            <tag> react </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>defineProperty? Proxy?</title>
      <link href="/blog/2019/04/20/why-vue-proxy/"/>
      <url>/blog/2019/04/20/why-vue-proxy/</url>
      
        <content type="html"><![CDATA[<blockquote><p>听说 Vue3 数据绑定要切换到 Proxy，为什么？</p></blockquote><p>这就是这篇文章的原因，来源于某个牛逼公司的面试。<s>我真的应该学会怎么清楚表达观点…</s></p><p><code>defineProperty</code> 和 <code>Proxy</code> 使用方式和效果看起来是差不多的，但如果翻译成中文的话，一个是定义属性，一个是代理，并且 MDN 上描述有所不同。</p><blockquote><p>Object.defineProperty() 方法会直接在一个对象上定义一个新属性，或者修改一个对象的现有属性， 并返回这个对象。 —— MDN</p></blockquote><blockquote><p>Proxy 对象用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。  —— MDN</p></blockquote><h2 id="defineProperty">defineProperty</h2><p>这是一个 <code>ES5</code> 的方法。一个 <code>defineProperty</code> 需要三个参数，都是 <code>require</code></p><span id="more"></span><blockquote><p>Object.defineProperty(obj, prop, descriptor)<br>obj: object, 定义的对象（我理解为附着于哪个对象）<br>prop: 定义的对象名称(key)<br>descriptor: 将被定义或修改的属性描述符。</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123;&#125;Object.defineProperty(obj, &#39;name&#39;, &#123;  value: &#39;colmugx&#39;,&#125;);</code></pre><p><code>descriptor</code> 存在可选项：</p><table><thead><tr><th style="text-align:left">key</th><th style="text-align:left">value</th></tr></thead><tbody><tr><td style="text-align:left">configurable</td><td style="text-align:left">该属性为 true 时，该属性描述符才能够被改变，同时该属性也能从对应的对象上被删除。默认为 false。</td></tr><tr><td style="text-align:left">enumerable</td><td style="text-align:left">该属性为 true 时，该属性才能够出现在对象的枚举属性中。默认为 false。</td></tr><tr><td style="text-align:left">value</td><td style="text-align:left">该属性对应的值。</td></tr><tr><td style="text-align:left">writable</td><td style="text-align:left">该属性为 true 时，value才能被赋值运算符改变。默认为 false。</td></tr><tr><td style="text-align:left">get</td><td style="text-align:left">getter 方法</td></tr><tr><td style="text-align:left">set</td><td style="text-align:left">setter 方法</td></tr></tbody></table><p>除了 <code>boolean</code> 类型，值都默认为 <code>undefined</code></p><h2 id="Proxy">Proxy</h2><p>这是一个 <code>ES6</code> 的方法，<code>Proxy</code> 参数比较简单</p><blockquote><p>new Proxy(target, handler)<br>target: 目标对象<br>handler: 属性/操作对象，当执行一个操作时定义代理的行为的函数</p></blockquote><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;&#125;, &#123;  get(target, name) &#123;    return name in target ? target[name] : target  &#125;&#125;)</code></pre><h2 id="？">？</h2><h3 id="数据拦截">数据拦截</h3><p>先看看 <code>Vue</code> 那种数据拦截是怎样的，做一个简单实现。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123;&#125;let value &#x3D; undefinedObject.defineProperty(obj, &#39;key&#39;, &#123;  get() &#123;    return value  &#125;  set(val) &#123;    value &#x3D; val  &#125;&#125;)</code></pre><p>很明显，我可以劫持一个对象的 <code>getter</code> 和 <code>setter</code>，同时也很明显，貌似需要一个缓存量。</p><p>如果说和 <code>Proxy</code> 比较呢？因为 <code>Proxy</code> 实现的是代理下整个对象，那么</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;key: undefined&#125;, &#123;  get(target, prop) &#123;    &#x2F;&#x2F; 由于代理了所有操作，那么返回 404 纯属意愿    return prop in target ? target[prop] : &#39;404 Not Found&#39;  &#125;  set(val) &#123;    target[prop] &#x3D; val  &#125;&#125;)</code></pre><p>写法有点像<code>computed</code></p><p>那么，为什么<code>defineProperty</code>不直接<code>target[prop] = val</code>？因为劫持关系，你会看到狗咬尾巴的奇观。也就是说，<code>defineProperty</code> 对原对象操作就会触发劫持，而<code>Proxy</code>操作的是实例对象，每个实例对象相对独立。</p><p>所以通过两次面试，闭环了这个知识。另外一篇：<a href="/blog/2018/03/16/vue-watcher">vue watch存在永动吗？</a></p><p>然而<code>Vue</code>换方式，显然不止因为这个，或许连这个都谈不上。</p><h3 id="只需要-defineProperty？怎么可能？">只需要 defineProperty？怎么可能？</h3><p>首先，上面例子这种方式可以看出，我每次操作都只能监听一个值，但一个应用不可能只有一个属性，而且没办法及时知道哪一个属性获得了更新。在深入了解之后，<code>Vue</code>好像用了订阅的方式在做这些事情。</p><p><a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8/src/core/observer/index.js#L109">vue/src/core/observer/index.js#L109</a></p><p>除了简单（没有深度）数据，其他一概遍历进观察者。</p><h3 id="为什么-Proxy？">为什么 Proxy？</h3><ol><li><code>defineProperty</code> 对数组有硬伤</li></ol><p>因为设定关系，<code>defineProperty</code>不能观察到数组内部，如果直接修改数组而不是返回新数组的话，无法触发劫持。<code>Vue</code>文档以一个简单的方式解释了<a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/guide/list.html#%E6%95%B0%E7%BB%84%E6%9B%B4%E6%96%B0%E6%A3%80%E6%B5%8B">这个问题</a>，解决这个问题的方法有点骚，<a target="_blank" rel="noopener" href="https://github.com/vuejs/vue/blob/52719ccab8fccffbdf497b96d3731dc86f04c1ce/src/core/observer/array.js#L11">相关源码位置</a>。但这只是让数组方法可以“正常使用”，万一有人<code>arr[0] = 0</code>呢？</p><ol start="2"><li>一个方法只能监听一个属性</li></ol><p>如果我需要监听这个对象里所有键，我需要把所有键都<code>defineProperty</code>一次。需要创建一个缓存变量倒不是什么“难事”，封装成一个方法就成了，但：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; &#123; a: &#123; b: &#123; c: &#123; d: &#123; e: &#39;???&#39; &#125;&#125;&#125;&#125;&#125;  &#x2F;&#x2F; ???</code></pre><ol start="3"><li><code>Proxy</code> 可以做到上面所有事情</li></ol><p>上面提到，<code>Proxy</code>是代理了整个对象，而且是以根据 target 创建实例来进行接下来的工作，每一个都相对独立。</p><p>第一个问题，因为我们有这个“对象”的所有操作权，而且每次<code>set</code>都能返回新的“对象”，并且我们可以自己定义“数据如何改变”</p><p>第二个问题，因为<code>Proxy</code>实现的是观察到整个对象而不是对象属性，那自然不存在这个问题了。</p><ol start="4"><li>除了 <code>getter</code>, <code>setter</code>，<code>Proxy</code>还有其他用法</li></ol><p>比如<code>apply</code>，可以劫持对象的函数（我的理解是把对象可以执行，当然JavaScript中，一切都是对象）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const obj &#x3D; new Proxy(&#123;&#125;, &#123;  apply(target, context, args) &#123;&#125;&#125;)</code></pre><p>所以你可以执行一些东西，甚至是通过方法创建/改变得到一个对象（对 target 直接修改）</p><p>感觉，如果<code>Vue3</code>用<code>Proxy</code>改写之后，代码会简洁非常多。而且性能可能会比现在提高好几倍（？），毕竟看目前得到的信息，对每一个数据创建<code>Observer</code> + <code>defineProperty</code>，性能挺要命的……</p><h3 id="补充">补充</h3><p><code>Proxy</code>在这里的用法只能说是「能当对象使用的对象」吧，毕竟它还是一个实例(Proxy(…)，而<code>defineProperty</code>操作的是意义上的对象。</p><p>而且我本以为我应该会先读<code>React</code>的源码，没想到…</p><h2 id="为什么-Vue2-不直接用-Proxy">为什么 Vue2 不直接用 Proxy</h2><p><code>Vue</code> 最早出现于 2013 年，<code>ES2015</code> 规范确定于 2015年，目前找不到 <code>Vue2</code> 第一个 commit 是什么时候（懒），推算了一下，不应该是赶不上，所以有第二种猜想：兼容性问题。</p><p><code>Vue</code>可以支持到 IE9+，目前的兼容性是 IE10+。首先<code>Proxy</code>就已经把 IE 完整的抛弃掉了，一点点都不支持。就算上 <code>polyfill</code>，也仅可以使用<code>get</code>, <code>set</code>, <code>apply</code>, <code>construct</code>，而 <code>Proxy</code> 的钩子(陷阱)达到十几种，显然物尽其能是不可能。</p><p>时代不同了，现在是现代浏览器时代，IE 淡出，连 Edge 都投靠敌台了。话说我最喜欢的就是最后一代斯巴达，渲染很快又开始支持插件。</p><h2 id="Vue-React">Vue &amp; React</h2><p>18 年我经常说的就是，如果技术参差不齐的团队，显然<code>Vue</code>更合适。反正你照着说明书一行一行抄肯定不会抄出问题。<strong>所以我不喜欢 Vue 就是因为不够自由，但如果无法驾驭自由，React 性能会更差。</strong></p><p>其中一个原因就是 <code>Vue</code> 跟 <code>React</code> 对数据的操作是不一样的。<code>React</code>单向，通过对比来更新数据，所以今日会有两种组件创建方式：<code>Component</code>, <code>PureComponent</code>。</p><blockquote><p>为什么 React 不学 Vue 搞这手，表单验证之类工作不是很好实现</p></blockquote><p>大家的想法都不一样为什么要强比较？所以我的回答是：</p><blockquote><p>这是 React 的设计原因，React 的做法是数据流单向，利用函数式的思想，像管道一样的操作使得副作用更加可控。</p></blockquote><p>只是回答得不完美，我有面试就紧张的坏心态。我的本意是我可以清楚数据的流向，同时采用数据不可变，这样根本不用担心数据在中途突然被什么做了修改。因为前面的原因，第二个问题忘记回答了：因为用函数式的思想，那么表单验证我可以用高阶函数呀。</p><p>但并不是说<code>Vue</code>的做法不是高阶函数，其实也是的。只是我们在用<code>React</code>的时候，感觉<code>React</code>只提供了把代码转成视图的功能，就没了，什么都没有什么都是自己实现。而<code>Vue</code>已经实装了非常多的操作使得开发过程不用想多一些问题。举一个小栗子：<code>React</code>渲染一个列表，靠的是自己用<code>JavaScript</code>的方法生成一个装着<code>ReactNode</code>的数组，而<code>Vue</code>只需要在模板中标记列表数据和在哪个节点渲染，把要渲染的内容写在其中即可。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 Nlvi 「添加到桌面」</title>
      <link href="/blog/2019/04/17/about-nlvi-pwa/"/>
      <url>/blog/2019/04/17/about-nlvi-pwa/</url>
      
        <content type="html"><![CDATA[<p>其实这个功能早在 2.x 版本就加入了，那时候对 PWA 并没有什么概念。<s>好想换 iPad Mini (new)</s></p><p><img src="/blog/Image/nlvi-ios-desktop.gif" alt="nlvi-ios-desktop"></p><p>目前 3.x 只改了启动图，适配了 iPad 横屏和 iPhone 全面屏（普通屏和plus后续加）。之前看到苹果对 PWA 持拒绝态度我是震惊的，你 tm 早就给 safari 加入了这个功能，也有相关<code>meta</code>配置（包括”识别为<code>WebApp</code>“），然后你告诉我这东西不是 PWA？</p><p>本来确实想支持 PWA 的，想到除了要 <code>manifest.json</code>，还要搞定对应生成 <code>service worker</code>，使用不是很友好，所以取消计划。这部分添加功能就是一个尝试的甜点，所以也没有拿出来说。目前 3.x 开启 <code>pjax</code> 然后添加到桌面，阅读体验还是挺好的。</p><p>所以这次打算讲讲「苹果式网页应用安装」，其实挺简单的。</p><span id="more"></span><h2 id="meta">meta</h2><p>这里没有列出所有关于 safari 支持的 meta，只针对这个功能部分。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;meta name&#x3D;&quot;apple-touch-fullscreen&quot; content&#x3D;&quot;yes&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-capable&quot; content&#x3D;&quot;yes&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-title&quot; content&#x3D;&quot;Colmugx&#39;s Blog&quot;&gt;&lt;meta name&#x3D;&quot;apple-mobile-web-app-status-bar-style&quot; content&#x3D;&quot;default&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-icon&quot;  sizes&#x3D;&quot;72x72&quot;  href&#x3D;&quot;icon.ico&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-icon-precomposed&quot;  sizes&#x3D;&quot;72x72&quot;  href&#x3D;&quot;icon.ico&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; media&#x3D;&quot;(device-width: 375px)&quot; href&#x3D;&quot;apple-launch-1125x2436.png&quot;&gt;&lt;link rel&#x3D;&quot;apple-touch-startup-image&quot; media&#x3D;&quot;(orientation: landscape)&quot; href&#x3D;&quot;apple-touch-startup-image-2048x1496.png&quot;&gt;</code></pre><p>从上到下分别是：</p><ul><li>添加到主屏幕后，是否全屏显示</li><li>是否显示 safari 菜单</li><li>应用默认名称（在添加的时候可以修改）</li><li>打开时，顶上状态栏应该呈现什么颜色（白色，黑色，透明）</li><li>设置 icon (72x72, 114x114)，图标在「书签」也可适用</li><li>设置启动画面（这里只设置了手机与平板横置）</li></ul><h2 id="apple-touch-startup-image">apple-touch-startup-image</h2><p>其他的没什么坑点，只是<code>apple-touch-startup-image</code>会复杂一些。它分成很多分辨率，设置不清楚的话就不会显示。而且它不能像图标一样设置<code>size</code>。只能用<code>media</code>一行一行写。</p><p>比如 iPad，设置倒是不需要跟手机一样那么多图片，只需要准备一张垂直一张水平。垂直 <code>768x1024</code>，水平<code>748x1024</code>，水平图也需要摆成垂直的，也就是<code>1024x748</code>，当然内容也是横直，相当于顺时针 90°。接着就考虑一下屏幕用的是二倍图还是三倍图了。</p><p>参考文章：<a target="_blank" rel="noopener" href="https://medium.com/appscope/adding-custom-ios-splash-screens-to-your-progressive-web-app-41a9b18bdca3">Adding Custom iOS Splash Screens To Your Progressive Web App</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nlvi </tag>
            
            <tag> PWA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我今天给 let 安排了</title>
      <link href="/blog/2019/03/27/you-dont-know-let/"/>
      <url>/blog/2019/03/27/you-dont-know-let/</url>
      
        <content type="html"><![CDATA[<h3 id="Round-1">Round 1</h3><blockquote><p>- 我现在把所有东西都注释掉，改成这样<br>function a() {<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 那就应该 undefined 了，反正后面不执行</p></blockquote><p>自信的不行，出了门掏出全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>inner is not defined</p></blockquote><p>确实是不执行，但好像不是 <code>undefined</code> 啊╭(*ﾟДﾟ*)╮</p><h3 id="Round-2">Round 2</h3><blockquote><p>- 如果改成这样呢<br>function a() {<br>function inner() {}<br>return inner;<br>let inner;<br>}<br>返回什么？</p><p>- 返回方法</p></blockquote><p>自信的不行，同样用全世界最牛逼的千元机<strong>坚果 Pro 2S</strong>，验证了一下。</p><blockquote><p>Identifier ‘inner’ has already been declared</p></blockquote><p>(ﾟДﾟ≡ﾟдﾟ)!? 你在返回你🐴呢？</p><span id="more"></span><h2 id="Why">Why?</h2><p>原本我以为只有 <code>var</code> 会变量提升，实际上错了，<code>var/let/const</code>都会。</p><p><code>var</code> 和 <code>let</code> 在某种时候是相似的，他们都会提升，但 <code>let</code> 少了初始化的过程。MDN 对 <code>let</code> 死区是这么解释的</p><blockquote><p>在 ECMAScript 2015 中，let 绑定不受变量提升的约束，这意味着 let  声明不会被提升到当前执行上下文的顶部。在块中的变量初始化之前，引用它将会导致 ReferenceError（而使用 var 声明变量则恰恰相反，该变量的值是 undefined ）。这个变量处于从块开始到 let 初始化处理的”暂存死区“之中。 —— MDN</p></blockquote><p>暂存死区又有这么个说法，用一个代码块解释一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function () &#123;  a &#x3D; &#39;caonima&#39; &#x2F;&#x2F; 下面有 let，a 直接被该块锁定，这里报错  let a &#x2F;&#x2F; 到这里才完成初始化，变量开始正常使用，但变量早已提升  console.log(a) &#x2F;&#x2F; 这里不是 caonima 而是 undefined  a &#x3D; &#39;woshinidie&#39;  console.log(a) &#x2F;&#x2F; woshinidie&#125;</code></pre><p><a target="_blank" rel="noopener" href="https://github.com/getify/You-Dont-Know-JS/issues/767">You-Dont-Know-JS#767</a> 讨论了这个问题, creeperyang 总结了四点</p><blockquote><ol><li>Hoisting includes both declare and initialize.</li><li>Only initialized variable can be used in a scope.</li><li>var do both declare and initialize, the two cannot be split for var.</li><li>let do firstly declare in the top of the scope, and do initialize when encounter the let xxx statements.<br>—— @creeperyang</li></ol></blockquote><p>另外，方应杭在知乎专栏的文章<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/28140450">《我用了两个月的时间才理解 let》</a>也总结出</p><blockquote><ol><li>let 的「创建」过程被提升了，但是初始化没有提升。</li><li>var 的「创建」和「初始化」都被提升了。</li><li>function 的「创建」「初始化」和「赋值」都被提升了。<br>—— <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/zhihusucks">@方应杭</a></li></ol></blockquote><p>理论上 <code>const</code> 应该是 <code>let</code> 的不可修改版本，所以应该是类似的。但也仅限提升原理相同，因为 <code>const</code> 只能初始化时赋值一次。</p><p>不过，阮一峰的《ECMAScript 6 入门》是什么意思？在 let 有单独一小节讲 <a target="_blank" rel="noopener" href="http://es6.ruanyifeng.com/#docs/let#%E4%B8%8D%E5%AD%98%E5%9C%A8%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87">不存在变量提升</a>，虽然后面解释了暂时性死区，但……</p><p>总结：被安排明白了。根据 @Ahonn 所说，这个问题在高程有讲过，书读少了读少了</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最后的 Nlvi</title>
      <link href="/blog/2019/03/25/bye-nlvi/"/>
      <url>/blog/2019/03/25/bye-nlvi/</url>
      
        <content type="html"><![CDATA[<p><code>Nlvi</code> 可以说起源于正准备上班和刚上班工作不饱和(大雾。为了练习自己对语义化 HTML 理解和 CSS 的渐进式学习而诞生的，到现在已经 2 年了。</p><p>那个时候还用 iPad 画草图然后慢慢写起来，而且当时编程能力确实还挺弱，hexo 很多都弄不清楚。现在对 hexo 就熟悉很多了，设计稿也从随便画画变成了用 sketch，但也是杀鸡用牛刀。</p><p>过程中也是各种骚想法，比如用 Vue/React 改写啊；脱离 jQuery 啊；用 pjax 啊；用更复杂的动画啊……不过我现在想的是：新版本(我博客正在用的半成品)做完之后，就不想迭代了。</p><p>为什么？因为一旦工作太忙没时间，又想到这个东西，好累啊……</p><p>但，我的意思是，<strong>我不想维护 hexo 版本的 Nlvi 了</strong>，我的意思是，诶嘿嘿嘿嘿嘿！</p><span id="more"></span><p>所以 3.0 到 4.0 大概的改动会是：</p><ul><li>根据我对统一风格的想法，(又)变动部分设计风格</li><li>根据我对统一风格的想法，调整部分部件展示形式</li><li>根据我对统一风格的想法，对颜色变量重新管理</li><li>去掉以前的标签云，重写一个</li><li>去掉以前的搜索框，重写一个</li><li>变动部分不成熟动画，改动动画曲线</li><li><strong>加入渐变色的设定！(Maybe)</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> 日常 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Nlvi </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>做不完的题目</title>
      <link href="/blog/2019/03/23/last-test-questions/"/>
      <url>/blog/2019/03/23/last-test-questions/</url>
      
        <content type="html"><![CDATA[<p>又在「杂乱的工作台上」完成文章……</p><p>没错又错过一个非常好的机会。与其说是因为时间不够做不完，还不如说是因为陷入斐波那契思考导致做不完。</p><p>不留遗憾，把它搞完。题源就不说了。</p><span id="more"></span><h2 id="1-现有-a-b-c-d-四个接口，找出最快的那个。异步用-setTimeout-模拟">1. 现有 /a, /b, /c, /d 四个接口，找出最快的那个。异步用 setTimeout 模拟</h2><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">const requests: Promise&lt;string&gt;[]  &#x3D; [&#39;&#x2F;a&#39;, &#39;&#x2F;b&#39;, &#39;&#x2F;c&#39;, &#39;&#x2F;d&#39;]  .map(v &#x3D;&gt; new Promise(resolve &#x3D;&gt; &#123;    const time &#x3D; Math.floor(Math.random()*1000)    setTimeout(() &#x3D;&gt; &#123;      resolve(&#96;$&#123;v&#125; spent $&#123;time&#125;&#96;)    &#125;, time);  &#125;))Promise.race(requests).then(console.log)</code></pre><h2 id="2-使用你擅长的方式实现-Dialog">2. 使用你擅长的方式实现 Dialog</h2><p>这个一直在暗示可以使用 <code>vue</code> 或者 <code>react</code>，但是我有些紧张，一时半会只能想到只能用原生的方式</p><p>最后只能说是搬石头砸自己的脚，没写过一时没思路，导致写不完</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;body&gt;  &lt;div&gt;    &lt;button id&#x3D;&quot;dialog&quot;&gt;直视我！栽种！&lt;&#x2F;button&gt;  &lt;&#x2F;div&gt;  &lt;style&gt;    .dialog &#123;      display: none;      position: fixed;      top: 50%;      left: 50%;      transform: translate(-50%, -50%);      background: #fff;      box-shadow: 1px 2px 8px 0 #c0c0c0;      color: #666;    &#125;    .mask &#123;      z-index: 1;      position: fixed;      top: 0;      left: 0;      background: rgba(0, 0, 0, 0.65);      filter: blur(80%);    &#125;    .dialog-header &#123;      width: 100%;      height: 45px;      margin: 8px 16px;    &#125;    .isShow &#123;      display: block;    &#125;    .footer &#123;      position: absolute;      bottom: 0;      left: 0;      right: 0;      height: 50px;      display: flex;      flex-flow: row nowrap;      justify-content: flex-end;      align-items: center;      margin: 0 16px;    &#125;    .cancel-btn &#123;      outline: 0;      border: 2px solid #ccc;      color: #999;      display: flex;      justify-content: center;      align-items: center;      padding: 8px;      border-radius: 8px;    &#125;  &lt;&#x2F;style&gt;  &lt;script&gt;    class TheDialog &#123;      constructor(id) &#123;        this.btn &#x3D; document.querySelector(&#39;#dialog&#39;)        this.width &#x3D; 500        this.height &#x3D; 300        this.template()        this.listener()        document.body.appendChild(this.container)      &#125;      template() &#123;        const container &#x3D; document.createElement(&#39;div&#39;)        container.style.width &#x3D; this.width + &#39;px&#39;        container.style.height &#x3D; this.height + &#39;px&#39;        container.classList.add(&#39;dialog&#39;)        container.appendChild(this.headerTem())        container.appendChild(this.bodyTem())        container.appendChild(this.footerTem())        this.container &#x3D; container      &#125;      bodyTem() &#123;        const body &#x3D; document.createElement(&#39;div&#39;)        body.innerHTML &#x3D; &#39;Hello World&#39;        body.style.margin &#x3D; &#39;16px&#39;        body.style.color &#x3D; &#39;#333&#39;        body.style.fontSize &#x3D; &#39;24px&#39;        return body      &#125;      headerTem() &#123;        const header &#x3D; document.createElement(&#39;div&#39;)        header.classList.add(&#39;dialog-header&#39;)        const title &#x3D; document.createElement(&#39;div&#39;)        title.innerHTML &#x3D; &#39;Dialog&#39;        header.appendChild(title)        return header      &#125;      footerTem() &#123;        const footer &#x3D; document.createElement(&#39;div&#39;)        const btn &#x3D; document.createElement(&#39;button&#39;)        footer.classList.add(&#39;footer&#39;)        btn.classList.add(&#39;cancel-btn&#39;)        btn.innerHTML &#x3D; &#39;CANCEL&#39;        btn.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;          e.stopPropagation()          this.close()        &#125;)        footer.appendChild(btn)        return footer      &#125;      listener() &#123;        this.btn.addEventListener(&#39;click&#39;, e &#x3D;&gt; &#123;          e.stopPropagation()          this.toggle()        &#125;)      &#125;      toggle() &#123;        const isShow &#x3D; this.container.classList.contains(&#39;isShow&#39;)        if (isShow) &#123;          this.close()        &#125; else &#123;          this.container.classList.add(&#39;isShow&#39;)          document.body.classList.add(&#39;mask&#39;)        &#125;      &#125;      close() &#123;        this.container.classList.remove(&#39;isShow&#39;)        document.body.classList.remove(&#39;mask&#39;)      &#125;    &#125;    (() &#x3D;&gt; &#123;      const theDialog &#x3D; new TheDialog()      window.dialog &#x3D; theDialog    &#125;)()  &lt;&#x2F;script&gt;&lt;&#x2F;body&gt;</code></pre><p>这样凑合能用</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redux —— combineReducers</title>
      <link href="/blog/2019/03/08/redux-combinereducers/"/>
      <url>/blog/2019/03/08/redux-combinereducers/</url>
      
        <content type="html"><![CDATA[<p>事出有因，写 <code>rabbit</code> 的时候，一条单测出了问题</p><blockquote><p>Reducer _object returned undefined during initialization.</p></blockquote><p>想来必然是 <code>reducer</code> 缺少默认的 <code>state</code> 所致，<s>但是我的单测是从 <code>dva</code> 直接拿过来改改就用的，应该不会出现问题，所以一定是哪里出了差错。后面发现了，虽然 <code>dva</code> 可以接受 <code>reducers</code> 是空对象，但应用运行起来有一样问题。</s></p><p>主要是这个问题无伤大雅，<code>model</code> 不会出现只有 <code>reducers</code> 这种情况。我也给出了解决：构建 <code>reducer</code> 给一个默认 <code>state</code> 顶着（但我认为一个 <code>model</code> 应该强制存在 <code>state</code>）</p><p>显然这次并不想讲这个，而是想理解 <code>combineReducers</code></p><span id="more"></span><p><code>combineReducers</code> 一共有 4 个方法：</p><ul><li><code>getUndefinedStateErrorMessage</code></li><li><code>getUnexpectedStateShapeWarningMessage</code></li><li><code>assertReducerShape</code></li><li>(主要方法) <code>combineReducers</code></li></ul><h2 id="getUndefinedStateErrorMessage">getUndefinedStateErrorMessage</h2><p>很明显，这是一个生成错误信息的方法。主要是限制 <code>reducer</code> 必须返回 <code>state</code></p><h2 id="assertReducerShape">assertReducerShape</h2><p>这是一个检查 <code>reducer</code> 是否合规的方法。</p><p>首先接受一个集合所有 <code>reducer</code> 的对象进行遍历，每一个抽出来检验，做一次运行尝试，看是否能得到 <code>state</code>。如果得到的 <code>state</code> 为  <code>undefined</code> 则该 <code>reducer</code> 是非法的。</p><p>文中开头提到的问题正是由这里报出，因为我们给出的 <code>reducers</code> 为空对象，且 <code>state</code> 为 <code>undefined</code>，所以自然会报错。<code>dva</code> 的单测只检查 <code>model</code> 的合理性，且 <code>state</code> 允许任何内容和 <code>reducers</code> 允许空对象，并没有考虑一个 <code>model</code> 同时不存在这两者的情况，不过显然没意义，所以目前是不清楚 <code>dva</code> 团队是没想到还是也觉得无所谓。</p><h2 id="combineReducers">combineReducers</h2><p>这是这组方法中的核心，该方法也作为默认方法导出。这组方法的目的是把一群 <code>reducer</code> 合并为一个方法供 <code>createStore</code> 使用。</p><p>上来是两组变量：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 提取对象中所有字段名，一个 key 对应一个 reducer 方法const reducerKeys &#x3D; Object.keys(reducers)&#x2F;&#x2F; 由下面可得，该变量用来暂存基本合理（reducer 是一个方法）的 reducer 方法。const finalReducers &#x3D; &#123;&#125;&#x2F;&#x2F;...if (typeof reducers[key] &#x3D;&#x3D;&#x3D; &#39;function&#39;) &#123;  finalReducers[key] &#x3D; reducers[key]&#125;&#x2F;&#x2F; 如果在非生产环境中，还会提示仅有 key 没有方法的值以方便我们修改调试&#x2F;&#x2F; 再把初步验证过的 reducer 取出const finalReducerKeys &#x3D; Object.keys(finalReducers)&#x2F;&#x2F;...let shapeAssertionError&#x2F;&#x2F; 放入刚刚用来验证 reducer 合规的方法进行第二次验证，并做错误处理try &#123;  assertReducerShape(finalReducers)&#125; catch (e) &#123;  shapeAssertionError &#x3D; e&#125;</code></pre><p>接着是返回一个新的 <code>reducer</code>，并对所有传入的合规的 <code>reducer</code> 进行 diff。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 创建一个对比记录变量以及新 statelet hasChanged &#x3D; falseconst nextState &#x3D; &#123;&#125;&#x2F;&#x2F; 遍历刚刚验证完的 reducer key 数组for (let i &#x3D; 0; i &lt; finalReducerKeys.length; i++) &#123;  const key &#x3D; finalReducerKeys[i]  const reducer &#x3D; finalReducers[key]  &#x2F;&#x2F; 获取当前 state  const previousStateForKey &#x3D; state[key]  &#x2F;&#x2F; 通过执行 reducer 得到新的 state  const nextStateForKey &#x3D; reducer(previousStateForKey, action)  if (typeof nextStateForKey &#x3D;&#x3D;&#x3D; &#39;undefined&#39;) &#123;    const errorMessage &#x3D; getUndefinedStateErrorMessage(key, action)    throw new Error(errorMessage)  &#125;  &#x2F;&#x2F; 并将新 reducer 产物绑定到 nextState，key 不变。（方便对比）  nextState[key] &#x3D; nextStateForKey  &#x2F;&#x2F; 右式第一个 hasChanged 表达：如果已经为 true 那么就肯定 true，没必要再去对比验证  hasChanged &#x3D; hasChanged || nextStateForKey !&#x3D;&#x3D; previousStateForKey&#125;&#x2F;&#x2F; 返回：有改变的返回新的，无改变返回原 state。return hasChanged ? nextState : state</code></pre><p>所以这组方法目的就是把所有复杂的 <code>reducer</code> 和 <code>state</code> 组成新的状态树，统一管理。业务开发时可以根据需求拆分多个 <code>reducer</code> 和 <code>state</code>，便于开发和组织。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> react </tag>
            
            <tag> redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>看过 Redux 之后，我写了一个不负责任的状态管理</title>
      <link href="/blog/2019/03/02/about-redux/"/>
      <url>/blog/2019/03/02/about-redux/</url>
      
        <content type="html"><![CDATA[<p>我们现在小程序需要使用状态管理，但因为项目体量实在很小又没必要使用 redux 或者 mobx。所以我打算不负责任的写一个。</p><h2 id="createStore">createStore</h2><p>Redux 最核心的部分，提供基础的功能。<code>createStore</code>接受三个参数：<code>reducer</code>, <code>initialState</code>, <code>enhancer</code>。前两个比较好理解，<code>enhancer</code>主要用在接受中间件中。返回产物我们主要使用三个方法：<code>getState</code>, <code>dispatch</code>, <code>subscribe</code>。</p><ul><li><code>getState</code>：获取当前 state 值</li><li><code>subscribe</code>：接受监听，存入 <code>listeners</code> 池中</li><li><code>dispatch</code>：处理 <code>reducer</code> 操作，触发 <code>listeners</code> 方法</li></ul><span id="more"></span><p>所有我们需要的东西都了解清楚了，其他的功能和边缘保护先不考虑，这也是为什么说是不负责任的状态管理(逃</p><h2 id="copy">copy</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function store(state) &#123;  let currentState &#x3D; state || &#123;&#125;  let listeners &#x3D; []  return &#123; getState, dispatch, subscribe &#125;  function getState() &#123;    return currentState  &#125;  function subscribe(listener) &#123;    listeners.push(listener)  &#125;  function dispatch(action) &#123;    action.call(this, currentState)    listeners.forEach(f &#x3D;&gt; f.call(null))    return currentState  &#125;&#125;</code></pre><p>这里修改了一些：订阅没有返回取消订阅操作。原因是懒。。<code>dispatch</code> 并不是接受一个纯函数进行数据更新，而是直接由业务修改状态然后通知更新，所以这其实不能算是一个 redux 产物，并且这很不可控。所以这更像是为了利用<code>react-redux</code>或者<code>taro-redux</code>而产生的一种状态保存方式。</p><p>原因还是业务比较简单，就是为了存几个不是很关键的数据但不想使用小程序的 <code>storage</code> 去管理而产生的方法。现在不仅满足业务，压缩后也只有 <code>270b</code> 左右，省点空间给小程序代码，有点赚的实际上。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一位赌狗前端的自我修养</title>
      <link href="/blog/2018/11/19/gamble-fn/"/>
      <url>/blog/2018/11/19/gamble-fn/</url>
      
        <content type="html"><![CDATA[<p>这两个月工作巨多，直到今天才有时间写点骚东西。</p><p>可是要写点什么比较好呢？这时候看到了隔壁桌面上放着一张福彩，我脑子里有画面了。（所以这位赌狗不是我，我不买彩票）</p><p>为了方便以后支持更多的彩票，直接搞个类</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Gamble &#123;    static dualColor(red: number &#x3D; 6, blue: number &#x3D; 1) &#123;        const reds: [number, number] &#x3D; [1, 33];        const blues: [number, number] &#x3D; [1, 16];        return [this.randomVal(reds, red), this.randomVal(blues, blue)];    &#125;    private static randomVal(        fromto: number[],        total: number,        temp: number[] &#x3D; [],    ): number[] &#123;        const [head, ...body] &#x3D; (!temp.length            ? [...Array(fromto[1]).keys()]                  .map(item &#x3D;&gt; item + 1)                  .splice(fromto[0] - 1)            : fromto        ).sort(() &#x3D;&gt; Math.random() - 0.5);        return !total            ? temp            : this.randomVal(body, total - 1, temp.concat(head));    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>记在NPM抢空包名的经历</title>
      <link href="/blog/2018/07/12/kill-orphan-on-npm/"/>
      <url>/blog/2018/07/12/kill-orphan-on-npm/</url>
      
        <content type="html"><![CDATA[<p>年前想搞定<code>React</code>的时候想了个骚操作：尝试用<code>React</code>的思路去做<code>Vue</code>的事情。又诞生了「Vue生态统一可以聚合」的骚想法，开始产生做<code>Ahri</code>的念头。想着那得搞个 npm 包吧，孤儿上线了。</p><p>嘛，在 npm 拿《英雄联盟》英雄名字抢注包名的做法都很弱智了，还“大义凛然”的在描述里写着：<code>League of Legends hero.</code></p><p>关于第一次遇到它的时候，我就想算了，重新找合适的名字吧，但后来因为其他原因就搁置了。现在重新回坑，依然遇到这个问题，这次我不忍了，我打算找 npm 肛他！</p><span id="more"></span><h2 id="寻找入口">寻找入口</h2><p>首先看了<code>profile</code>页，发现没有举报入口。（从这里进了Twitter，让人感觉这是一个为了装逼而活着的人。</p><p>看看 npm 本身页面有没有什么入口，比如“联系我们”之类的邮箱总有吧，最后在最下面找到了<code>Reporting Abuse</code>。</p><p>不得不说 npm 连“因为名字打起来”的可能都想到了，那“因为孤儿操作”应该也会列入其中吧，果不其然。在骚扰举报一栏找到了控空包的情况：如果有用户注册无用空包，或者利用包进行乱七八糟的活动，可能有两种措施：ban 了这个用户；清除这些东西。</p><p>我一看到可以 ban 了他我就可兴奋了，于是，发邮件走起。</p><h2 id="采取行动">采取行动</h2><p>操起我400分的4级水平英语，就开始写。</p><blockquote><p>hi,<br>here a profile page: xxxxxx.</p><p>this account keep a lot of empty packages which name as a role name in a game, it cause difficulty for me.</p><p>I NEED HELP! THANK YOU!</p></blockquote><p>过了一会收到回信：</p><blockquote><p>Our support hours are Monday through Friday, 9:00AM - 6:00PM PST, excluding US holidays.</p><p>Your request is being reviewed by our support staff and we’ll be responding soon.</p><p>To add additional comments, reply to this email.</p></blockquote><p>噢，没在工作时间还行。过了几秒又收到一封邮件：</p><blockquote><p>Hey there,</p><p>Thank you for reaching out. We hope you’re having a great week thus far, and are looking forward to responding to your request.</p><p>The npm support staff will be off on Wednesday, July 4th in observance of Independence Day. Due to this, you may experience some delay in expected reply times.</p><p>Thanks for your patience.</p></blockquote><p>狗屎还带放假的？美国员工真的舒服啊，不加班，节假日放满。像我们这种997节假日还放不满的简直受到了6把无尽的暴击。</p><p>等了几天发现不对，没理我，再按照第一封发了一次，这次过了半天多才回。这次差点就怕我气到了，大概的意思就是你上次的 ticket 还没解决，如果你没问题了我们就关了。。。美国人上班都这么摸的？</p><p>又过了半天收到一封邮件，这次是技术客服（邮件是有人名的大佬）发来的：</p><blockquote><p>Thanks for reaching out.</p><p>I was not able to find an account associated with (我发信的邮箱). Was there a specific one of these user’s package names you are interested in for a project?</p><p>If so, we may assist you with a transfer request or granting access to that package, depending on the package and contents.</p></blockquote><p>有点着急，看了第一句之后，下面没仔细看，就有点想搞他，我就回信了。信的内容大概是这样：谢谢你的回复。这是我的项目名字（发了<code>Ahri</code>的GitHub Repo），这是我的 npm 账号（意识到发信的账号不对）。我对<code>Ahri</code>有兴趣，但他是个空的而且被占用了，我没办法使用，对吧？还有这个 B 恶意占用了大量的空包（跟上孤儿账号），他是不是同时违反了规则，是不是应该有所动作？</p><p>第二天（有时差），收到了回信，说包名已经转移到我的账号上：</p><blockquote><p>Thanks for getting back to me with that information.</p><p>It’s all yours now, but you won’t be able to re-use any version numbers used by the previous author. In fact, I’d suggest publishing your first update as a major release, i.e., v1.0.0. Please publish an update to the package as soon as possible with your code.</p></blockquote><p>我上了我的 npm 看了一眼，惊了…这就拿到了…</p><p>但并没有解放其他的空包和 <strong>ban 了他</strong>，这点我有点失望。总之，要到想要的包，这才是想要的结果。</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NPM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我就写个方法，这么麻烦？</title>
      <link href="/blog/2018/07/04/different-function/"/>
      <url>/blog/2018/07/04/different-function/</url>
      
        <content type="html"><![CDATA[<p>最近想到一个问题：为什么JavaScript定义一个函数有那么多种形式，是历史残留还是为了装逼？研究了一下发现还是有区别的。</p><p>JavaScript中定义一个方法主要可以分成两种形式：</p><ul><li>函数声明</li><li>函数表达式</li></ul><span id="more"></span><h2 id="函数声明">函数声明</h2><p>声明体是最普通的，其他语言也相近的一种方式。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a, b) &#123;  return a + b&#125;func(1, 2) &#x2F;&#x2F; 3</code></pre><p>不过，毕竟是「函数就是爸爸」的JavaScript！它有一个特性：函数提升。</p><blockquote><p>函数提升：把所有函数提升到当前作用域上，从而做到了可以“未声明先调用”。</p></blockquote><h2 id="函数表达式">函数表达式</h2><p>这可能是目前用的最多的声明方式，因为可以搭配箭头函数假装自己用的是函数式编程。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function(a, b) &#123;  return a + b&#125;&#x2F;&#x2F; 箭头函数版本const funcA &#x3D; (a, b) &#x3D;&gt; a + bfunc(1,2) &#x2F;&#x2F; 3</code></pre><p>但变量受作用域影响，所以<code>const</code>和<code>let</code>并没有变量提升的能力。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">funcA(1) &#x2F;&#x2F; ReferenceError: funcA is not definedconst funcA &#x3D; a &#x3D;&gt; a</code></pre><p>燃鹅，这才刚刚开始……</p><h2 id="匿名-具名">匿名 &amp; 具名</h2><p>匿名就是上面那种，具名就是给函数本体再起一个名字。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function funcName() &#123;&#125;</code></pre><p>这样有什么区别？后面那个名字又不能用！答案还是有区别的。</p><p>首先有一个函数名推断，比如上面这个函数，那么<code>func.name</code>会返回<code>funcName</code>。如果匿名函数的话<code>[fn].name</code>会返回<code>''</code>。其次这个名字可以在函数内部使用。当然了指代的就是自己了。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; function funcName(a, b) &#123;  return a &lt; 0 ? b : funcName(a+1-b, a)&#125;func(431, 151) &#x2F;&#x2F; 281funcName(431, 151) &#x2F;&#x2F; ReferenceError: funcName is not definedconsole.log(func.name) &#x2F;&#x2F; funcNametypeof funcName &#x3D;&#x3D;&#x3D; &#39;function&#39; &#x2F;&#x2F; false</code></pre><p>所以这种方式最适合递归函数了。</p><h2 id="函数表达式依然是个常-变量">函数表达式依然是个常/变量</h2><p>把它当做一个“方程”来看吧，关键词已经决定了这个“量”会以什么形式存在，比如<code>var</code>和<code>let</code>是变量，<code>const</code>是常量，并且<code>let</code>还有作用域范围。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const funcA &#x3D; () &#x3D;&gt; console.log(&#39;A&#39;)funcA() &#x2F;&#x2F; AfuncA &#x3D; () &#x3D;&gt; console.log(&#39;AA&#39;) &#x2F;&#x2F; TypeError: Assignment to constant variable.var funcB &#x3D; () &#x3D;&gt; console.log(&#39;B&#39;)funcB() &#x2F;&#x2F; BfuncB &#x3D; () &#x3D;&gt; console.log(&#39;BB&#39;)funcB() &#x2F;&#x2F; BB</code></pre><p>题外话：那么就有个老生常谈的问题了，函数表达式按道理来讲是“灵活的”，那么下面这个函数会是什么结果？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function funcB() &#123;  console.log(&#39;B&#39;)&#125;funcB() &#x2F;&#x2F; BBfunction funcB() &#123;  console.log(&#39;BB&#39;)&#125;funcB() &#x2F;&#x2F; BB</code></pre><p>为什么？还是那句话：JavaScript世界中，函数是你爹！</p><h2 id="箭头函数">箭头函数</h2><p>又到了大家最最喜欢的箭头函数环节，现在还有谁是不愿意写箭头函数的？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; a &#x3D;&gt; b &#x3D;&gt; a + bfunc(1)(2) &#x2F;&#x2F; 3</code></pre><p>在这篇文章：<a href="/blog/2017/03/03/js-this/">《关于JavaScript的this》</a>已经被安排的明明白白了。</p><p>实际上现在看这篇文章也有点问题，年轻的时候牛批吹多了。总结箭头函数两个特点就是：</p><ul><li>不会创造上下文（自身无this）</li><li>必然是个匿名函数</li><li>没有 <code>arguments</code></li></ul><p>不是两个吗？怎么变成三个了？此时你可能会回去检查刚刚那句话，然后我现在悄悄告诉你，（第三点是送的）。</p><h2 id="计算属性函数名">计算属性函数名</h2><p>这个应该是在“对象”的环境中存在，毕竟对象可以指代很多种只要是对象的情况。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const object &#x3D; &#123;  [&#39;a&#39; + &#39;b&#39;](a, b) &#123;    return a + b  &#125;&#125;object.ab(1, 3) &#x2F;&#x2F; 3</code></pre><p>这就实现了“函数名可以暂时不知道是什么”的情况，通过计算来得到这个函数。</p><h2 id="Other">Other</h2><h2 id="new-Function">new Function</h2><p>这是一个不知道哪里可以用得上但是就是可以用的方式：通过对象创建</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;)func(1, 2) &#x2F;&#x2F; 3</code></pre><h2 id="函数参数初始值">函数参数初始值</h2><p>可能有一定需求，但可能没有</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function func(a &#x3D; 1, b &#x3D; 2) &#123;  return a + b&#125;func() &#x2F;&#x2F; 3</code></pre><p>可能我们更常用的有这些</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const funcA &#x3D; (obj &#x3D; &#123;&#125;) &#x3D;&gt; objconst funcB &#x3D; (arr &#x3D; []) &#x3D;&gt; arr</code></pre><p>但JavaScript毕竟是「函数是第一公民」的语言，有机会会写到很多高阶函数。所以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const func &#x3D; (fn &#x3D; () &#x3D;&gt; &#39;💉💧🐮🍺&#39;) &#x3D;&gt; fn.call(null)</code></pre><p>凭什么函数作为参数就不能有初始值呢？当然是可以的呀！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于四轴的踩坑指南</title>
      <link href="/blog/2018/03/12/dji-interview/"/>
      <url>/blog/2018/03/12/dji-interview/</url>
      
        <content type="html"><![CDATA[<p>怎么可能真的是四轴的踩坑指南，其实是大疆的受苦之旅。恼羞成怒下单了<code>mavic air</code>（所以dji还是赚了？）</p><p>怎么可能会让你回去还能等到通知，人家HR明明都告诉我面试入职一条龙了！算了本来就是自己的问题，能一路到看到四个大佬都是赚的。面试结束还送了架精灵还有一块工牌！（虽然是纸精灵和工牌套子。</p><p>总结一下印象深刻受苦的问题和答案，不过有一点想吐槽的…就<code>vue</code>和<code>react</code>之间的关系和选择，我看到了高一文理科分班的那种影子：人家都是哪科分高选哪科，我是选分低 + 主管臆想……</p><span id="more"></span><h2 id="html5-css3">html5 css3</h2><p>css3：圆角，变形，线性渐变，阴影。后两个没答，另外阴影我一直以为是<code>css2</code>的。</p><p>html5: 算了挺多的…基本上用过的都说了一遍… 下次记得背一下（真的需要用到那么多？</p><h2 id="Vue">Vue</h2><h2 id="created-和-mounted-区别，ajax会在哪里操作">created 和 mounted 区别，ajax会在哪里操作</h2><blockquote><p>放在 created，因为 mounted 的时候还没有渲染节点。</p></blockquote><p>虽然这个问题也有一些讨论，有些会在<code>created</code>就做了，有些是在<code>mounted</code>做。</p><p>有问题吗？还真有。因为我想到的是：在<code>created</code>过程把数据获取之后，从虚拟dom转为真实dom的时候可以顺便把数据带进去。而不需要一整个组件都创建完整之后再去加载数据。毕竟到<code>mounted</code>的时候实例都建立完了，这个时候再刷新数据不是会引起刷新/重绘？不过这个问题不应该是我没看源码的问题，而是有些问题没了解透彻，或者说，文章看太少。</p><p>恰好就坑这了，要的就是在<code>mounted</code>，因为这个时候已经有组件实例了，也就是<code>this.$el</code>已经有树了，如果<code>ajax</code>过来的内容是需要依赖<code>el</code>的话，那在<code>created</code>的时候还没有东西呢。</p><p><img src="https://cn.vuejs.org/images/lifecycle.png" alt="Vue生命周期图示"></p><h2 id="深度-watcher">深度 watcher</h2><p>去翻了一下文档，我发现翻车的是自己吧！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">c: &#123;  handler: function (val, oldVal) &#123; &#x2F;* ... *&#x2F; &#125;,  deep: true&#125;,</code></pre><p>只需要给对象加个<code>deep</code>就行了,而<code>a.b</code>这种情况应不属于深度watch，这只是需要监听的数据在比较深处而已…</p><h2 id="vue-函数式组件">vue 函数式组件</h2><p>这是一个补充问题，关于 什么时候可以使用函数式组件，我觉得确实没什么可以说的啊…</p><p>如果只是充当渲染任务，不需要持久化不需要状态，采用函数式组件可以减少开销。</p><p>总的来说，比较严重的问题还是出现在：表达能力有问题 + 理解框架不够深刻（但远不及原理） + 狗娘的英语表达。还有<code>css</code>过于依赖补全导致想口头表述语句的时候，单词中间那段想不起来所以说不出口导致的丢分。所以打算CSS部分关闭补全一段时间。</p><p>这属于机会完全被自己毁了（还不是技术层面问题），所以烦躁和不甘又有什么用呢…</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>promise链式调用</title>
      <link href="/blog/2018/02/28/promise-chaining/"/>
      <url>/blog/2018/02/28/promise-chaining/</url>
      
        <content type="html"><![CDATA[<p>学会了却不会活用是真的菜…</p><p>前几天面试，提到了回调地狱用<code>promise</code>，然后抛出个衍生问题：<code>promise</code>也会嵌套，怎么解决<code>promise</code>的回调地狱。</p><p>我想不到，直接问能不能用<code>ES8</code>，说行，然后我就想到了<code>const p2 = await Promise</code>这种做法。</p><p>可是，我记得我在若干天前才写了一篇关于「JS方法链式调用」。</p><blockquote><p>只要函数返回值是一个函数，就可以连着调用</p></blockquote><p>So,</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">p1.then((&#123; p2 &#125;) &#x3D;&gt; &#123;  return p2&#125;).then(&#123; p3 &#125; &#x3D;&gt; &#123;&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>抛下不成熟，开始nvim</title>
      <link href="/blog/2018/02/13/new-life-nvim/"/>
      <url>/blog/2018/02/13/new-life-nvim/</url>
      
        <content type="html"><![CDATA[<p>想活得跟过去有些区别，活得更有效率该有的样子，而且我讨厌上一年的自己，不知道为什么会这么想。反正，放弃spacemacs开始使用vim了。</p><p>很简单，spacemacs有时候会卡一下，就像十年前的电脑，按了一长串需要等一下才会突突突突全显示出来。后来vscode + vim插件又出现了“不自觉按空格”的情况，就是写完按两下空格调插件。那既然这样的话，从零开始一个vim吧，把leader换成空格然后一些改不过来的习惯换过来就行了。</p><p>实际上，如果不是因为懒，早就该定制编辑器了。。不过我不会放弃vscode，因为还是有些残留。为什么不从零开始一个emacs？成本太高啊，又要vim模式又要改成leader键操作，而且逐渐能理解那个蚊香图是什么意思了。</p><h2 id="iterm2">iterm2</h2><p>宿主用这个，原先很排斥在终端写东西（不能用鼠标），不过后来一手菜鸡操作<code>xj</code>, <code>xk</code>还有<code>wwwwwwww...</code>也能达到需求了，应该没问题了。</p><span id="more"></span><p>14px的<code>menlo nerd</code>，204x60 的<code>full-width top</code>，接近<code>40%</code>的透明度纯黑背景解决字体字符完整显示和启动时自动无边框全屏，还能看到窗后的情况。顺便把热键改成<code>cmd + return</code>（这操作懂得都懂…）</p><h2 id="zsh">zsh</h2><p>oh-my-zsh一早就装了，用的<code>avit</code>主题，其他没动。对我来说<code>shell</code>就是<code>shell</code>。</p><h2 id="vim">vim</h2><p>从刚开始尝试MacVim到后面把这东西干掉，终端vim更新到vim8.0之后，vim一直充当着“顺手改改”的任务。这次因为要半主力编辑器，也不能全靠手打了…</p><p>对ycm印象极差，虽然deoplete支持vim8，弄了一阵子能用但是一出问题麻烦极多；找到了vim-lsp但是资源稀缺，还不会自启服务器！一气之下编译一手<code>neovim</code>，完美。毕竟我要有这脾气我就去从零开始space + emacs了（主要还可以直接抄大佬的配置）。</p><p>至于其他插件，因为还没有实战过还不知道缺哪些东西。先配好的是肯定会用上的，看情况再说。</p><p>另外求一个vim插件，vim有没有像<code>mmm-mode</code>的插件，就是同一个文件可以不同设置高亮或者补全的？用<code>mmm-mode</code>可以在同一文件同时采用<code>emmet-mode</code>和<code>js2-mode</code>，也因为这样解决我<code>vue</code>高亮补全问题…</p><p>然后就是看情况把在<code>spacemacs</code>的片段搬到<code>vim</code>了。</p><h2 id="tmux">tmux</h2><p>其实<code>iterm2</code>也可以胡乱分屏，但是考虑到大佬墙裂推荐。用！</p><p>看到了<code>i3</code>的影子，配置窗口前后颜色，调整了状态栏左右宽度和配色。毕竟还不熟，随意的改成了和vim主题相近的低调配色并加上时钟（着手做电量）。不过我的终端毕竟不是全屏的，顶栏和dock还是会常驻屏幕，所以一堆东西也没什么用。对了，这一套有颜色的主题颜色都采用了<code>one</code>，atom家那个。</p><p>然后剩下的就是通过使用寻找问题了，现在第一个问题就是vim的主题怎么把背景也至少<code>30%</code>的透明，改了主题文件发现一点用都没有。</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> editor </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex源码理解（二）</title>
      <link href="/blog/2018/01/30/vuex-study-2/"/>
      <url>/blog/2018/01/30/vuex-study-2/</url>
      
        <content type="html"><![CDATA[<p>继续，这次尝试逐行理解Store类的东西</p><p>然后关于这次，一些“工具函数”都集中在<code>util.js</code>的这种做法，已经够我学的了。这是个很受用的做法。</p><h2 id="一些简单的东西">一些简单的东西</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">if (process.env.NODE_ENV !&#x3D;&#x3D; &#39;production&#39;) &#123;  assert(Vue, &#96;must call Vue.use(Vuex) before creating a store instance.&#96;)  assert(typeof Promise !&#x3D;&#x3D; &#39;undefined&#39;, &#96;vuex requires a Promise polyfill in this browser.&#96;)  assert(this instanceof Store, &#96;Store must be called with the new operator.&#96;)&#125; &#x2F;&#x2F; 断言函数在util，如果不满足前面的情况，后面以error 排出来&#x2F;&#x2F; （实际上就是想看有没有在vue环境中和有没有正确安装）</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const &#123;  plugins &#x3D; [],  strict &#x3D; false&#125; &#x3D; options &#x2F;&#x2F; 定义两个变量，在传入的对象中把这两个东西拿出来，字面意思</code></pre><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 这里可能是会把整个vuex所有的内容都会规整到这些中&#x2F;&#x2F; store internal statethis._committing &#x3D; false  &#x2F;&#x2F; commit switch（ -&gt; mutations）this._actions &#x3D; Object.create(null) &#x2F;&#x2F; actionsthis._actionSubscribers &#x3D; [] &#x2F;&#x2F; 应该像在dva中看到的订阅，没用过也没弄清楚应该怎么用this._mutations &#x3D; Object.create(null) &#x2F;&#x2F; mutationsthis._wrappedGetters &#x3D; Object.create(null) &#x2F;&#x2F; gettersthis._modules &#x3D; new ModuleCollection(options) &#x2F;&#x2F; 分模块得到一个类this._modulesNamespaceMap &#x3D; Object.create(null)  &#x2F;&#x2F; 命名空间，上一次有讲到this._subscribers &#x3D; [] &#x2F;&#x2F; 所有订阅者this._watcherVM &#x3D; new Vue() &#x2F;&#x2F;watcher??应该跟vue的watcher有关？</code></pre><h2 id="开始跳着理解">开始跳着理解</h2><h2 id="store-与-操作绑定">store 与 操作绑定</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; bind commit and dispatch to selfconst store &#x3D; this &#x2F;&#x2F; 把store 是指向 this 的const &#123; dispatch, commit &#125; &#x3D; this &#x2F;&#x2F; 所以 &#123; dispatch, commit &#125; &#x3D; store ?this.dispatch &#x3D; function boundDispatch (type, payload) &#123;  return dispatch.call(store, type, payload)&#125;this.commit &#x3D; function boundCommit (type, payload, options) &#123;  return commit.call(store, type, payload, options)&#125;</code></pre><p>虽然有注释，就是把 commit, dispatch 和store绑定到<code>this</code>上，然后<code>&#123; dispatch, commit &#125; = store</code>了。接着class中的<code>dispatch</code>指向刚刚对象中<code>dispatch</code>的方法，通过<code>call</code>用法改变作用域调用。我们用到的<code>this.$store.dispatch</code>应该来源这里，下面同理</p><h2 id="ModuleCollection">ModuleCollection</h2><p>这里感觉很有意思，因为我这是第一次关注vuex的代码，我也不清楚命名空间等这些东西是什么时候加进去的，但我猜测应该是vue2.5之后的内容因为之前没在文档里见过这些东西。</p><p>字面意思，模块收集器。由于现在复杂度的关系，这部分应该先处理一下。把从vue的vuex得到的options，直接传入这个类，然后再进入<code>register</code>方法，接下来的工作就是不断的尾递归（？）得到整棵树。因为现在还有命名空间什么的，所以还有关于命名空间的判断和结合。</p><p>然后还有一些其他方法，比如热更什么的。</p><h2 id="installModule">installModule</h2><p>使用到的位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">installModule(this, state, [], this._modules.root)</code></pre><p>Store开始初始化的其中第一个方法。</p><p>这个方法，字面含义就是安装模块，猜测应该是把store相关的东西先配置下来。</p><p>这里有一个点（函数太长了不浪费篇幅了）</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const isRoot &#x3D; !path.length</code></pre><p>判断是否是根是通过<code>path</code>的长度来做的，如果没长度就是<code>/</code>了，很有意思，对于还没什么经验的我受益匪浅。</p><p>这个函数，需要5个参数，<code>store</code>, <code>rootState</code>, <code>path</code>, <code>module</code>, <code>hot</code>。最后一个应该也跟更新有关系吧？</p><p><code>this</code>在<code>class</code>中，所以指向是<code>class Store</code>的；<code>state</code>是<code>const state = this._modules.root.state</code>得到，而<code>_modules</code>就上面提到的定义了；因为还在根所以没有<code>path</code>，最后传入刚刚各种尾递归得到的树。</p><p>接下来注册命名空间，也就是判断这次的store有没有用到命名空间，有就分成一张张网，摊开处理。</p><p>接下来会遇到一个函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function getNestedState (state, path) &#123;  return path.length    ? path.reduce((state, key) &#x3D;&gt; state[key], state)    : state&#125; &#x2F;&#x2F; 如果不是根的话会被分配到这里，看需不需要拼凑state，就“三光属性”</code></pre><p>非根注册应该是文档的<a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh-cn/modules.html">这里</a>吧，这里提到了模块可以只是局部注册，我们一般都直接在<code>main.js</code>完事儿了。</p><p>然后就是三种操作的模块遍历注册，用到的方法存在<code>module.js</code>，实则还是用到了<code>util.js</code>的遍历方法（通过回调函数返回回去，再次赞叹）</p><p>而注册的方法<code>registerMutation</code> &amp;&amp; <code>registerAction</code> &amp;&amp; <code>registerGetter</code> 就是我们用到的那些例如<code>store.commit(type, payload)</code>的方法。</p><p>然<code>registerAction</code>的方法比其他的复杂得多，它要求<code>handler</code>传入<code>dispatch</code>, <code>commit</code>, <code>getter</code>, <code>state</code>等。显然他命中注定要干一些“脏乱差”的工作。由此也可以得到为什么<code>actions</code>的方法，第一个参数(type)可以传入<code>&#123;dispatch, commit, state&#125;</code>…的东西了。</p><p>题外话：之前在某个论坛看到一个问题，问在vuex中的actions为什么可以取到state，不会造成什么乱七八糟的问题么？我也不知道，问题的答案先留着。不过因为可以得到state，所以我们可以通过现有的state来判断或者操作，这不是更方便了么？</p><h2 id="resetStoreVM">resetStoreVM</h2><p>当一切都准备好了之后，怼进实例。</p><p>实际上前面也有提到，vuex是被vue当做专属插件进行安装的，在Vue实例环境中就可以通过<code>this.$store</code>摸到vuex。然后vuex就可以通过数据的改变来重新得到新的组件或者新的去促进生成得到新的dom。然后在上一篇有讲到那一堆辅助函数，实际上就是控制或者约束操作，但实质就是<code>Vue.$store.dispatch</code>等等等。</p><p>先是从store拿到vm作为旧的vm以作备份（当然如果不存在就不存在备份了），然后让<code>Vue</code>把这段操作定义为静默操作。</p><p>接着生成通过<code>new Vue</code>生成新的vm（假如有旧的也备份了，不会影响），恢复取消静默操作。（意思就是偷偷替换了vm）</p><p>至此新的视图已经更新完成，没有出意外的话，存在的刚刚备份过的旧vm就可以干掉的，执行销毁</p><h2 id="withCommit">_withCommit()</h2><p>通篇是没有提到这个函数的，到这里提一下是因为，至此这个函数用了两次，最后一次是发生在刚刚<code>resetStoreVM</code>的最后，如果存在热更的情况下那里。篇幅不长，拿出来看一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">_withCommit (fn) &#123;  const committing &#x3D; this._committing  this._committing &#x3D; true  fn()  this._committing &#x3D; committing&#125;</code></pre><p>毕竟状态管理，如果谁都能理这个状态，还需要管理干什么。这里的理解可以套入<code>reducer</code>协助理解，<code>state</code>有且仅有<code>reducer</code>可以修改，而vuex的<code>mutations</code>也就是做这份工作的地方。然后<code>_withCommit</code>的话，是个代理来的。</p><p>还是刚刚备份旧vm那个样子，先备份当前状态，然后把该状态转为<code>true</code>，据说是如果不暂时改变状态，严格<code>vuex</code>会认为这是非法操作，是禁止的。</p><p>封印解除之后，执行一下回调（各种需要破例更新的数据），然后再固着。</p><p>为什么这里需要备份状态换回去，而且这里是<code>boolean</code>，非黑即白的。实际上如果这个所谓的开关，在执行这里之前就是关闭的，那道理通过。如果在这之前，开关本来开着，这样你执行一次这里，就又把开关关回去的话，会影响到其他地方的正常工作，这不是一个“合格的秘书”。</p><p>刚刚最后那里的操作</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">store._withCommit(() &#x3D;&gt; &#123;  oldVm._data.$$state &#x3D; null&#125;)</code></pre><p>就是假如这里是<code>hot</code>的话，就把旧vm的状态改成<code>null</code>，然后跟这个vm有关的watcher和计算都会被强行触发更新。通过这样让页面不刷新然后刷新dom。</p><p>最后一个问题：为什么明明<code>this</code>指向的是本体(Store)，初始化的时候需要<code>const store = this</code></p><p>回答：JavaScript那么牛逼的<code>this</code>，墙头草属性的，不找个需要固定的位置固定下来肯定会有机会被带偏的。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vuex源码理解（一）</title>
      <link href="/blog/2018/01/25/vuex-study-1/"/>
      <url>/blog/2018/01/25/vuex-study-1/</url>
      
        <content type="html"><![CDATA[<p>看个代码代价很高，我边读边转笔，然后一个失手把手挑了个滴血不止…（笔头挑掉了一层手皮）</p><p>vuex和dva的源码都想看，不然没办法知道相性在哪。</p><h2 id="由口而入">由口而入</h2><p>这都暴露干净了…</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  Store,  install,  version: &#39;__VERSION__&#39;,  mapState,  mapMutations,  mapGetters,  mapActions,  createNamespacedHelpers&#125;</code></pre><p><code>install</code>肯定是Vue老套路，想把东西当插件用肯定要暴露这个方法。这个之前写组件经常需要碰到，弃之！</p><p>这次就先读暴露出来的四个方法吧</p><span id="more"></span><h2 id="辅助函数">辅助函数</h2><h2 id="normalizeNamespace">normalizeNamespace</h2><p>这个东西可能要先讲，因为你看到<code>mapState</code>的第一眼你就会看到他，虽然不重要。</p><p>这应该是一个初始化或者标准化命名空间的方法，之前&quot;尝试用dva的理解对处理数据&quot;有遇到使用命名空间的情况。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#39;spacename&#39;, &#123;    count: state &#x3D;&gt; state.count  &#125;)&#125;</code></pre><p>看一下实现方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function normalizeNamespace (fn) &#123;  return (namespace, map) &#x3D;&gt; &#123;    if (typeof namespace !&#x3D;&#x3D; &#39;string&#39;) &#123;      map &#x3D; namespace      namespace &#x3D; &#39;&#39;    &#125; else if (namespace.charAt(namespace.length - 1) !&#x3D;&#x3D; &#39;&#x2F;&#39;) &#123;      namespace +&#x3D; &#39;&#x2F;&#39;    &#125;    return fn(namespace, map)  &#125;&#125;</code></pre><p>映入眼帘就是一个柯里了，大致意思就是命名空间需要处理，如果进来的函数第一个不是空间名称那么肯定直接是对象了，因为我们也不是必须使用命名空间，比如最普通的这样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#123;    count: state &#x3D;&gt; state.count  &#125;)&#125;</code></pre><p>如果有命名空间的话，就根据层数用<code>/</code>分开，比如<code>app/save</code></p><h2 id="normalizeMap">normalizeMap</h2><p>对不起还是不能讲到<code>mapState</code>，毕竟通用的函数理解完了之后，游戏也就结束了。（要不怎么说是辅助函数</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;** * Normalize the map * normalizeMap([1, 2, 3]) &#x3D;&gt; [ &#123; key: 1, val: 1 &#125;, &#123; key: 2, val: 2 &#125;, &#123; key: 3, val: 3 &#125; ] * normalizeMap(&#123;a: 1, b: 2, c: 3&#125;) &#x3D;&gt; [ &#123; key: &#39;a&#39;, val: 1 &#125;, &#123; key: &#39;b&#39;, val: 2 &#125;, &#123; key: &#39;c&#39;, val: 3 &#125; ] * @param &#123;Array|Object&#125; map * @return &#123;Object&#125; *&#x2F;function normalizeMap (map) &#123;  return Array.isArray(map)    ? map.map(key &#x3D;&gt; (&#123; key, val: key &#125;))    : Object.keys(map).map(key &#x3D;&gt; (&#123; key, val: map[key] &#125;))&#125;</code></pre><p>注释都直接告诉你了！对的实际上组件对<code>vuex</code>的访问可以有两种，对象或者数组。对象的情况上面已经有了，还有一种数组。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">computed: &#123;  ...mapState(&#39;spacename&#39;, [    &#39;count&#39;  ])&#125;</code></pre><p>这种是，如果组件的参数跟vuex设定一样，那么就直接传入数组匹配，相当于<code>this.count</code>指向<code>this.$store.state.count</code></p><h2 id="mapState-mapMutations-mapGetters-mapActions">mapState, mapMutations, mapGetters, mapActions</h2><p>剩下的就真的是“拼装术”的事情了，通过暴露出去的辅助函数所接收到的数据进行转换并连接<code>vuex</code>。</p><p>相当于<code>redux</code>本身只提供了状态管理，便捷操作需要接触各类型插件。而<code>vuex</code>作为<code>vue</code>专属状态管理，已经提供了最适合<code>vue</code>的操作。</p><h2 id="问题-2">问题</h2><p>由于辅助函数做的工作就是提供在组件中对<code>vuex</code>连接操作的工作，而函数中的转换结果都会是<code>this.$store</code>。在注入<code>vue</code>的环境中，<code>this</code>不出意外的话是指向<code>vue</code>原型上的，这也就意味着，<code>vuex</code>实际上也是作为插件附着在<code>vue</code>原型中。</p><p>不过关于这一点，在一开始就有提到，<code>vuex</code>是通过暴露自己的安装函数让<code>vue</code>可以直接<code>use()</code>。而且我们在<code>main.js</code>绑定时也默认使用<code>store</code>这个key。</p><p>这样的话，只要是能访问到<code>vue</code>的地方就可以访问到<code>$store</code>了，包括组件。**从而可以做到不需要什么辅助函数也不需要<code>actions</code>直接对状态管理动手动脚。**这不仅是react的使用者感觉到的诧异或者反感了吧。</p><p>不过团队是知道这种情况的存在的，所以他们是<strong>推荐在组件中使用辅助函数，请不要直接操作</strong>。</p><p>（不过这个注释最多也就说说而已，懂道理的人都会这么做；不懂道理的，只存留“我只要解决问题就行了”的某些人是不会这么做的。）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> vuex </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>通过dva得到的思考 —— “滥用”VUEX</title>
      <link href="/blog/2018/01/22/vuex-dva/"/>
      <url>/blog/2018/01/22/vuex-dva/</url>
      
        <content type="html"><![CDATA[<p>首先这一手骚操作要感谢@ahonn，确实这几天学习dva，我自己都觉得自己有点烦了。但是老哥好耐心，真心感谢。</p><p>直接上正题吧不磨磨唧唧的了！</p><h2 id="dva是什么">dva是什么</h2><p>这还用说吗，坦克啊！双命特性，大招是通过机甲自爆产生大范围爆炸，本体只有100血，可以反…啊！！！别打我啊！</p><p>好吧可能阿里的工程师也喜欢玩守望先锋，而且我清晰记得dva这个框架就是守望大火的时候诞生的，而且还有一个协同工具叫路霸吧。（看来阿里的工程师都不喜欢当C…）</p><span id="more"></span><p><code>dva</code>是针对<code>react</code>的框架，实际上就是关于<code>redux</code>的一个封装。首先是让本来很难理解和使用的redux变得相对容易理解和操作。另外一个就是因为数据集中管理，并且推荐使用无状态组件，操作者只需要关心数据的走向。</p><h2 id="从dva得到了启示">从dva得到了启示</h2><p>毕竟阿里前端工程师，Ahonn是真的喜欢阿里的东西…最近跟他聊天也比较深入了解“为什么我们需要dva”。</p><p>后来我一个闪念：<code>dva</code>会不会就是一个数据库模型，实际上redux对我们来说就是一个数据库，前端没有状态，不干涉数据，实际上就是我们常说的只关心增删改查？</p><p>那么dva实际上还是对<code>redux</code>，<code>redux-saga</code>，<code>redux-thunk</code>的封装，但对于vue来说简直就是先天优势，因为对于vuex来说已经相当于redux + redux-saga了。从这里也直接萌生了一个想法：vuex + stateless component = 1/2 dva ？</p><h2 id="对启示更清晰的思考">对启示更清晰的思考</h2><p>首先现在的dva，把数据都封装在<code>model</code>中，一个<code>model</code>对应一个redux，<code>state</code>, <code>reducer</code>概念得以保留，引入<code>effect</code>和<code>subscriptions</code>概念。</p><p>首先副作用的目的是，通过异步操作例如网络请求或者一些需要异同步配合的操作，然后去驱使<code>reducer</code>更新<code>state</code>，因为在流中，只有<code>reducer</code>有权利去动<code>state</code>。<code>subscriptions</code>就是一个订阅的概念，在我看来就是一个初始化，或者说是一个接受状态的概念。</p><p>那么为什么说vuex有先天优势？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; dva modelexport default &#123;  namespace: &quot;users&quot;,  state: &#123;&#125;,  reducers: &#123;&#125;,  effects: &#123;&#125;,  subscriptions: &#123;&#125;&#125;&#x2F;&#x2F; vuexexport default new Vuex.Store(&#123;  modules: &#123;    users: &#123;      namespaced: true,      state: &#123;&#125;,      mutations: &#123;&#125;,      actions: &#123;&#125;    &#125;  &#125;&#125;)</code></pre><p>如果你要无限逼近dva是什么感觉？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; users.jsexport default &#123;  namespaced: true,  state: &#123;&#125;,  mutations: &#123;&#125;,  actions: &#123;&#125;&#125;&#x2F;&#x2F;store.jsexport default new Vuex.Store(&#123;  modules: &#123;    users  &#125;&#125;)</code></pre><p>由于 vue/vuex 对于规则还是相对宽松，但理是理法是法，约定俗成<code>mutations</code>是用来做同步的工作，可以用来操作<code>state</code>；<code>actions</code>用来做异步工作，通知<code>mutations</code>去操作<code>state</code>。所以这里是不是就有一种新的概念？</p><pre class="line-numbers language-none"><code class="language-none">state &lt;&#x3D;&gt; statemutation &lt;&#x3D;&gt; reduceraction &lt;&#x3D;&gt; effect_ &lt;&#x3D;&gt; subscription</code></pre><p>对没错，订阅怎么办？</p><p>在dva的例子中，看一下示例的订阅是做了什么工作？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">subscriptions: &#123;  setup(&#123; dispatch, history &#125;) &#123;    return history.listen((&#123; pathname, query &#125;) &#x3D;&gt; &#123;      if (pathname &#x3D;&#x3D;&#x3D; &#39;&#x2F;users&#39;) &#123;        dispatch(&#123; type: &#39;fetch&#39;, payload: query &#125;)      &#125;    &#125;)  &#125;,&#125;</code></pre><p>所以关于这个简单订阅，我们完全可以直接用<code>vue-router</code>，而其中刚好有一个概念我们可以直接使用 —— 导航守卫</p><h2 id="针对vue的操作">针对vue的操作</h2><p>老样子，我们是怎么理解dva的<code>model</code>，就怎么理解vuex的<code>store</code>。首先<code>state</code>和<code>reducer</code>跟vuex的定义是完全对等的，不需要多理解。<code>effects</code>是使用<code>generator</code>函数来解决异同步问题的，那好办啊，都2018年了，我们直接用async/await就行了。而且我们之前关于api都是使用<code>promise</code>，而且用的也是<code>axios</code>，所以这部分可以说是无缝切换。</p><p>那么关于订阅，直接使用<code>vue-router</code>的导航守卫对路由监控，另外在必要的时候还能使用<code>meta</code>。当然导航守卫并不是只能用在全局上，也可以注入到组件中，所以我们注入到页面组件即可。</p><p>接下来就是无状态组件问题了，vue默认是状态组件，而且无状态组件也没有react来的方便。</p><p>react想要无状态组件，无非就是一个函数就结束战斗了。vue也有一个概念叫函数式组件，也就是无状态，这种组件在使用上就已经不是很方便了。</p><p>vue的函数式组件就必须使用<code>render</code>函数不能用<code>template</code>模板，一直到vue2.5才可以在<code>&lt;template functional&gt;</code>使用。但我尝试了一下，手感并不好，所以还是只能用 jsx + vue 这种搭配来操作。不过vue的无状态组件也不像react那么好理解，它依然是一个Object</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;  functional: true， &#x2F;&#x2F; 你只不过是通过这个开关来切换组件状态  methods: &#123;    ...mapActions(&#39;spacename&#39;, &#123;      add: &#39;create&#39;    &#125;)  &#125;  render() &#123;    return &lt;h1&gt;&#123;props.msg&#125;&lt;&#x2F;h1&gt;  &#125;&#125;</code></pre><p>而且在实际使用中，实际上因为vue的概念，你还是没办法在所有组件完全不使用无状态组件（已经除去表单组件）。不过也无伤大雅了。</p><p>所以通过这个操作，也能近似的得到了dva的那种感觉。前端的工作只需要直观的反馈你的数据动向和状态，要那么复杂干什么？</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vuex </tag>
            
            <tag> dva </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>剑指Offer —— 替换空格</title>
      <link href="/blog/2018/01/04/replace-space/"/>
      <url>/blog/2018/01/04/replace-space/</url>
      
        <content type="html"><![CDATA[<p>以后博客专职动物园算了…</p><p>刚刚看到一题</p><blockquote><p>请实现一个函数，将一个字符串中的空格替换成“%20”。例如，当字符串为We Are Happy.则经过替换之后的字符串为We%20Are%20Happy。</p></blockquote><p>我想这什么腿？然后什么都没想，直接就</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">return str.replace(&#x2F;\ &#x2F;g, &#39;%20&#39;)</code></pre><p>然后过了……虽然100多毫秒</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>有意思的monad记录</title>
      <link href="/blog/2017/12/27/funny-monad/"/>
      <url>/blog/2017/12/27/funny-monad/</url>
      
        <content type="html"><![CDATA[<blockquote><p>看到monad我的第一反应竟然是莫纳德…</p></blockquote><p>最近学习haskell的时候（意外的觉得入门不难），接触到函数式编程一个新的思想——Monad</p><p>之前在知乎看到轮子哥说：学习haskell是好事，但最好就是学到monad就停下来，然后去学别的。对别的语言帮助很大。</p><p>然后在知乎看了一些monad的答案，找了点关于monad的博客看，没看懂。英文的话更不可能了！直接看paper的话我会脆死的。</p><p>后来偶然找到一篇文章：<a target="_blank" rel="noopener" href="http://adit.io/posts/2013-04-17-functors,_applicatives,_and_monads_in_pictures.html">Functors, Applicatives, And Monads In Pictures - adit.io</a></p><p>当然有中文版：<a target="_blank" rel="noopener" href="http://jiyinyiyong.github.io/monads-in-pictures/">Functors, Applicatives, And Monads In Pictures - adit.io</a>，<br><a target="_blank" rel="noopener" href="http://www.ruanyifeng.com/blog/2015/07/monad.html">图解 Monad - 阮一峰的网络日志</a></p><p>全程特别轻松，我以后写博客也要按照这个节奏来写！很有意思！<br>（那个抽东西的手直接戳爆了我的笑点…特别是解构传入胶水函数的时候）</p><p>关于理解的话，挖个坑以后总结~</p><p>但有一点是：我用 Vue-jsx 的时候，几乎全是Monad</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript链式方法</title>
      <link href="/blog/2017/12/23/js-method-chaining/"/>
      <url>/blog/2017/12/23/js-method-chaining/</url>
      
        <content type="html"><![CDATA[<blockquote><p>著名框架<code>jQuery</code>所使用的设计模式——“虾扯蛋”</p></blockquote><p>之前在知乎回答过一个问题：2018的前端应该学什么。</p><p>我回答了：就算前端再复杂，jQuery依然是最流行的那个。</p><p>这答案怎么样呢？废话！肯定没人点赞了！</p><p>人性就是如此！一旦接受了更<s>装逼</s>新的思路，就会觉得以前见过的东西都太弱了！</p><p>新项目想用什么就用什么，什么技术栈健全就用什么。可是老项目并没办法想干什么干什么，时间和精力不允许他去重构。金蝶还在卖VB呢，他们肯定也想过VB已经不行了。</p><p>好了题外话，我还是很有兴趣实现一个塞进<code>nlvi</code>的类jq的。</p><span id="more"></span><h2 id="怎么来的链式操作">怎么来的链式操作</h2><blockquote><p>如果不用链式调用，jQuery没有性能可言 ——鲁迅</p></blockquote><p>鲁迅：我不是！我没有！别乱说啊！</p><p>我记得有人测试过，<code>$('#ele')</code>会比<code>document.getElementById('ele')</code>慢很多。如果是按行操作dom而不是用专属的链式调用，效率会更差。</p><p>但这次不是来讨论jQuery的效率的。链式方法也是一种设计模式，有必要了解一下。就算ES6常使用的<code>Promise</code>，也用到了链式调用。</p><p><code>JavaScript</code>能够函数式编程，还是因为它是个“函数为第一公民”的语言，但它并没有<code>pure function</code>是因为它的设计其实是多范式的。而ES6把构造函数和<code>classes</code>加进去之后更是证明了这一点。</p><h2 id="我用过的JavaScript">我用过的JavaScript</h2><p>关于这部分，我觉得我想分享的东西有点超篇幅，所以移步到另外一篇分享吧：<a href="/PersonalBlog/2017/12/26/my-known-javascript/">我所认识的JavaScript</a></p><p>大致上就是<code>JavaScript</code>之所以能这么玩是因为它会把任何东西都看做“函数”来看待，并且以它的理解就是：我能且只能掌控函数，函数必有返回值。并且每产生一个函数就会有一个“我”的含义：<code>function</code>会自然而然的产生<code>this</code>并指向自己。而链式操作就是利用了这点。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function test() &#123;  console.log(&#39;Hello World&#39;);  return this&#125;</code></pre><p>如果是浏览器的话，在没有对象的情况下，父级应该就是<code>window</code>了。而函数返回<code>this</code>相当于把自己返回到操作空间中，而操作空间属于父级。也就是说，只要是同一级别的函数，通过返回<code>this</code>把操作权交还到父级手中从而达到继续调用同级函数的技能。还不清楚？反正我不画图。</p><h2 id="简单链式操作">简单链式操作</h2><p>在此我们以著名歌唱家“雷军”举个例子。雷军可以说是目前最强悍的企业家了，写得了软件造得了手机，能唱一首好歌能吹一手好B。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 雷军（人为对象，构造成立）var LeiJun &#x3D; &#123;  hello: function() &#123;    console.log(&#39;hello, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;,  thank: function() &#123;    console.log(&#39;thank you, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;,  thanks: function() &#123;    console.log(&#39;thank you very much, &#39;)    return this &#x2F;&#x2F; -&gt; LeiJun  &#125;&#125;&#x2F;&#x2F; 驱使对象雷军唱出《Are you ok》前三句leijun  .hello()  .thank()  .thanks()</code></pre><p>如果按字面意思可能永远都理解不来，从而产生哲学三连：我是谁？我在哪？我在干什么？所以又有一句话得以解释：从哪里来，回哪里去。</p><h2 id="为什么用链式操作">为什么用链式操作</h2><blockquote><p>新手村的Monad？</p></blockquote><p>所以作用很明显了，一种工厂流水线式的操作，流的形式完成任务。所以我要把这种设计模式归入函数式编程也是因为，函数式思想本来就是让数据经过所有“函数流”最后得到产物并返回。数据不变，不额外干涉操作。</p><p>不同的是，常规FP中，不管是单函数单返回走流，还是柯里化，它都是一种“一进一出”的思想——出来的产物继续传入下一道“工序”进行加工，一直到最后一个加工函数为止。</p><p>然而链式操作并不是这种哲学，它是一种“从第一次进入就买定离手”的操作——只要一开头传入参数，流不结束不会见到半成品。数据经过一层函数之后，可能经过加工处理结束后，又会被打包/压缩/处理到‘this’中并继续接下来的工作。</p><p>链式操作相对于柯里化来说，起码它做到了：</p><ul><li>可阅读</li><li>少占用</li><li>减少代码重复性（都有）</li><li>代码简洁（都有）</li></ul><p>柯里化最明显的优点就是阅读性差（？？？），假设有个方法叫<code>leijun</code>,那么调用方法的画风就大不相同</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">leijun()()()</code></pre><p>鬼才知道他想唱的是“Are you ok”还是“Indian Mi Fans”呢……</p><p>还有就是，因为流操作可以异步。JS也是患有懒癌很多年了，必须靠事件驱动才能工作，所以注定它是不能异步编程的。</p><p>所以jQuery还是很强大的框架，在ES5什么都没有就靠三种规范的语法，已经要实现那么多东西了。让JS支持异步编程也就两种操作吧：函数内回调函数、链式操作函数。这框架两种都用上了。而说NodeJS速度快，一方面也是因为目前两个服务器框架都是异步（一堆回调函数）得到的结果吧。</p><h2 id="不止JavaScript能用">不止JavaScript能用</h2><p>实际上本质就是，把执行权交给函数之后，函数执行完自己的工作之后，还可以吧执行权重新交回父级手中，让父级自行处理接下来的工作。</p><p>所以强化函数式编程的语言或者说能返回自身的语言应该都可以支持该模式，在这之后我只接触过<code>Golang</code>有这种操作，不过那当时哪来的Go啊…</p><p>这个世界本来就先有的FP，因为概念不够清晰才出现了OOP。现在业务量复杂到OOP已经不好解决了，这个时候人们又想起了凉了的FP。2018年如果前端继续发展下去，可能又会回到一个FP的年代（然后我要放弃FP看着它火了？不！这次看到希望不会撒手了！）</p><p>在我在无脑吹FP的时候（懂得概念不懂得实践），我看到了swift的出现，JAVA8强化λ，go的出现，TypeScript的出现（乱入，它强调OOP）。前几天看到了<code>haskell-react</code>，以后还会有什么？</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡排序的骚思路</title>
      <link href="/blog/2017/12/20/exchange-number/"/>
      <url>/blog/2017/12/20/exchange-number/</url>
      
        <content type="html"><![CDATA[<p>想起以前很容易就会被问到一个问题</p><blockquote><p>如何把两个数值进行交换？</p></blockquote><p>教科书式的编程怎么做？</p><pre class="line-numbers language-C" data-language="C"><code class="language-C">int i &#x3D; 1;int j &#x3D; 2;int k &#x3D; i;i &#x3D; j;j &#x3D; k;&#x2F;&#x2F; 两个数值，把其中一个寄存起来，然后再两次赋值。</code></pre><p>以前去写代码的社团，当时我巨活跃，有个师兄就过来说：看你资质不错，我打算亲自培养你，先问你一个问题吧：你如何把两个数值进行交换？写不出代码没关系，我只是要听思路。</p><p>我：什么跟什么交换？</p><p>师兄：随便你。</p><p>于是我打开了<code>sublime text</code>写下这么些东西</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var i &#x3D; 1;var j &#x3D; 2;i +&#x3D; j;j &#x3D; i - j;i -&#x3D; j;</code></pre><p>然后师兄就懵了，你这个B不按套路出牌？</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用JSX的VUE应用开发体验</title>
      <link href="/blog/2017/12/11/vue-jsx/"/>
      <url>/blog/2017/12/11/vue-jsx/</url>
      
        <content type="html"><![CDATA[<blockquote><p>我说我是做外包的肯定没人信，给你看看外包程序员瞎几把搞的热情！</p></blockquote><p>前排提醒：vue-jsx和react-jsx相差甚远，前者基本就是玩具生产链。很多想利用JS语言特性的骚套路基本上都不好实现，而且感觉奇奇怪怪的。所以你的生产环境，千万不要乱试vue-jsx这种搭配，够简单就无所谓了…</p><span id="more"></span><h2 id="开局搭环境">开局搭环境</h2><p>要什么环境，<code>vue-cli</code>就行了，又不是什么大项目大团队需要约定<code>webpack</code>。</p><h2 id="装插件">装插件</h2><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">npm install\  babel-plugin-syntax-jsx\  babel-plugin-transform-vue-jsx\  babel-helper-vue-jsx-merge-props\  babel-preset-env\  --save-dev</code></pre><p><code>.babelrc</code>主要是这个</p><pre class="line-numbers language-json" data-language="json"><code class="language-json">&#123;  &quot;plugins&quot;: [&quot;transform-vue-jsx&quot;]&#125;</code></pre><p>因为其他的东西基本上都会有，主要是要添加这个东西。至此。</p><h2 id="正文-2">正文</h2><p>没错的这文章本来是属于实践的又不是教程。还是要讲一下自己的体验的。</p><h2 id="渲染元素">渲染元素</h2><p>感想最大的就是这个，Vue在使用jsx的时候很迷，最明显的感觉怪怪的地方有两个：</p><ol><li>它并不是哪个位置的方法都会有createElement函数的。</li><li>classes形式的组件找不到render函数！</li></ol><p>其实关于vue与jsx，tsx我是做了很多次尝试</p><p>首先第一种，常规的就是一个<code>object</code>对象，然后通过<code>Vue.component()</code>方法构建。这种可以说是我现在看来最没坑的一种形式了。平常的话还是像<code>*.vue</code>里的<code>script</code>标签一样，直接<code>export</code>打头开写，<code>&lt;template /&gt;</code>渲染部分移入了<code>render()</code>函数。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  render(&#x2F;* h &#x2F; createElement *&#x2F;) &#123;    return &lt;h1&gt; Hello World &lt;&#x2F;h1&gt;  &#125;&#125;</code></pre><p>这种情况的结构与单文件的代码结构是相差无几的，不过换了种渲染方式而已，而且<code>render()</code>函数可以做一些与渲染相关的子方法，比如条件渲染之类的。所以总的来说：</p><p>优点：</p><ol><li>顺手，完全单文件中的<code>script</code>标签</li><li>没了</li></ol><p>缺点：</p><ol><li>这么搞肯定容易眼花啊！</li><li>不好维护，不直观</li></ol><p>第二种，如果是这种结构的tsx的话，与jsx同理。</p><p>第三种，class形式的组件，需要<code>vue-class-component</code>插件。然后可以写出类似于这样的东西</p><pre class="line-numbers language-vue" data-language="vue"><code class="language-vue">&lt;template&gt;    &lt;h1&gt;Hello World&lt;&#x2F;h1&gt;&lt;&#x2F;template&gt;&lt;script&gt;  @Component  export default class MainClass extends Vue &#123;  &#125;&lt;&#x2F;script&gt;</code></pre><p>乍一看你还以为这是<code>Angular</code>呢！Vue在这方面真的是取长补短的典范。对这种的话，就比传统的方式要好多了，首先全局变量或者<code>data()</code>函数返回值变得特别清晰；再者是原来<code>methods</code>存放的函数可以以<code>class</code>形式的函数来写，那<code>computeds</code>怎么办？直接用<code>get/set</code>关键词，太方便了有没有！</p><p>好了关键的来了…</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">@Componentexport default class MainClass extends Vue &#123;  get render() &#123;    return &lt;h1&gt; Hello World &lt;&#x2F;h1&gt;  &#125;&#125;&#x2F;&#x2F; render or template not defind.</code></pre><p>这是什么鬼，可能是我操作不当，但是不加<code>get</code>的话不会注入createElement，但是这又是个<code>render()</code>函数，本来不需要加什么前缀的。但是不加有感觉会不会把<code>render()</code>函数识别成是传统写法中存在于<code>methods</code>的函数。</p><p>官方在自动注入这方面有一个栗子的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">Vue.component(&#39;jsx-example&#39;, &#123;  render () &#123; &#x2F;&#x2F; h will be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;,  myMethod: function () &#123; &#x2F;&#x2F; h will not be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;,  someOtherMethod: () &#x3D;&gt; &#123; &#x2F;&#x2F; h will not be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;&#125;)@Componentclass App extends Vue &#123;  get computed () &#123; &#x2F;&#x2F; h will be injected    return &lt;div id&#x3D;&quot;foo&quot;&gt;bar&lt;&#x2F;div&gt;  &#125;&#125;</code></pre><p>其中<code>h</code>就是<code>createElement</code>的别称，而且在jsx的话一般都是不用写的。所以这个函数注入的就有点迷了，不过根据亲测，在<code>methods</code>定义的函数是有<code>h</code>的，可能最后也会在<code>render</code>函数里调用吧。</p><p>后来我尝试两三个星期之后，我就放弃了classes形式的jsx写法，等过几天又有经历的时候再继续尝试。目前自己在用的两套写法：例如<code>Hyper</code>那种的classes形式的vue+ts，传统方式的jsx。</p><p>还有就是，对于vue来说，有时候要时常关心<code>h</code>函数有没有被注入，这是一件挺不愉快的事情的。比如说你写了一个渲染函数，然后运行的时候发现惨了凉了函数刚好在渲染范围之外（比如把函数直接分离出去，并不存在于<code>render</code>函数中），这是不运行的，那怎么做？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function example(h, args) &#123;&#125;</code></pre><p>就是这样的！必须在render函数中调用而且<code>h</code>必须是第一个参数！不然不是报错就是不渲染！</p><h2 id="函数式组件">函数式组件</h2><p>可能是解决刚刚提到的“经常找不到自动注入函数”的困扰吧。多了一个这么个东西。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">export default &#123;  functional: true,  render() &#123;&#125;&#125;</code></pre><p>一个关键词<code>functional</code>声明这个位置是个函数式组件。函数式可以直接看做一个能主动注入<code>h</code>的函数，因为它没有状态的，甚至是个RBQ，用完就丢（死无全尸，在组件树是看不到的，依托父组件生存）。同时最大的特点也就是可复用。想想<code>react</code>一个正常语法函数就能搞定的事情…</p><p>有利有弊，这种组件因为没状态，用过就丢，所以它需要的数据全靠传递。也就是单向数据，从父组件 -&gt; props -&gt; 处理 -&gt; 输出 -&gt; 销毁一条龙。很简单就是把它看做是<code>render</code>里面的一个函数就行，本意也是如此。</p><p>所以这种组件就两个接收参数：负责渲染的<code>h</code>，负责上下文<code>context</code>。各种所需的乱七八糟都在<code>context</code>中，比如全程最重要的<code>props</code>。而且多数组件的参数都有调整：</p><blockquote><ul><li><code>props</code>：提供 props 的对象</li><li><code>children</code>: VNode 子节点的数组</li><li><code>slots</code>: slots 对象</li><li><code>data</code>：传递给组件的 data 对象</li><li><code>parent</code>：对父组件的引用</li><li><code>listeners</code>: (2.3.0+) 一个包含了组件上所注册的 <code>v-on</code> 侦听器的对象。这只是一个指向 <code>data.on</code> 的别名。</li><li><code>injections</code>: (2.3.0+) 如果使用了 <a target="_blank" rel="noopener" href="https://cn.vuejs.org/v2/api/#provide-inject"><code>inject</code></a> 选项，则该对象包含了应当被注入的属性。</li></ul></blockquote><h2 id="JSX的一些小区别">JSX的一些小区别</h2><p>因为我还没怎么体验过<code>react</code>，所以就只有一个关于dom书写的区别。在<code>react-jsx</code>中，<code>class</code>可是会被识别成关键词的，所以做样式的<code>class</code>要写成<code>className</code>，但在<code>vue-jsx</code>是不需要的。可能一开始这么做没想过后面竟然还有<code>class-component</code>的需求吧。</p><p><code>vue</code>现在大多奇技淫巧都是基于社区的各种<code>babel</code>插件，并不像<code>react</code>两个官方库皇帝级别支持，也不像<code>angular</code>自从诞生时期就声明“劳资要用TypeScript作为开发语言，你不用也得用ES6形式！”</p><p><code>vue-jsx</code>这种写法我现在也会用，搞点小的就直接这么写，而且这么做实际上思路会清晰一点——像在写一个应用而不是写一个网页，你只需要把dom相关的字段脑里想成一个字符串或者一个子函数就行了。（只是老遇到一些乱七八糟的问题）</p><p>（<code>angular</code>与<code>angular.js</code>至今还是两种东西，不要乱了）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>扯扯柯里化</title>
      <link href="/blog/2017/12/07/about-currying/"/>
      <url>/blog/2017/12/07/about-currying/</url>
      
        <content type="html"><![CDATA[<blockquote><p>在我的博客打开开发者工具 -&gt; console，输入 Nlvi.tools.scroll 试试？</p></blockquote><p>开个玩笑，我自己也不知道这算不算柯里化（逃</p><p>总之为什么这么写，我自己觉得这样容易理解，方便盲僧（理清）。</p><p>还有最近关于“如何治理别人爱装逼的毛病”系列中刚写的一坨，新鲜的：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">const menuItem &#x3D; (list) &#x3D;&gt;      list.map((&#123;title, color, icon, descs&#125;) &#x3D;&gt;        &lt;menu-item title&#x3D;&#123;title&#125; color&#x3D;&#123;color&#125; icon&#x3D;&#123;icon&#125;&gt;&#123;          descs.map(v &#x3D;&gt; &lt;span&gt;&#123;v&#125;&lt;&#x2F;span&gt;)&#125;&lt;&#x2F;menu-item&gt;)</code></pre><span id="more"></span><h2 id="柯里化是什么？">柯里化是什么？</h2><p>好了讲柯里化，就是<strong>接受多个参数的函数变换成接受一个单一参数(最初函数的第一个参数)的函数，并且返回接受余下的参数且返回结果的新函数的技术。柯里化属于函数式编程的内容</strong>。</p><p>在这里有一个<a target="_blank" rel="noopener" href="http://www.zhangxinxu.com/wordpress/2013/02/js-currying/">张鑫旭博客</a>讲关于柯里化（柯南嗑药）的例子，很方便理解。当然我想讲点自己的东西，拿<code>Nlvi.tools.scroll</code>说一下吧</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tools.scroll &#x3D; function (win) &#123;  return function(fn) &#123;    $(win).scroll(function() &#123;      var sct &#x3D; $(win).scrollTop();      fn &amp;&amp; fn(sct);    &#125;);  &#125;;&#125;;&#x2F;&#x2F; 实际上如果不作的话，这样就结束了tools.scroll &#x3D; function(win, fn) &#123;  return $(win).scroll(function() &#123;    var sct &#x3D; $(win).scrollTop();    fn&amp;&amp;fn(sct)  &#125;)&#125;</code></pre><p>所以函数柯里化看上去有一个特点，会嵌套函数。而且道理就跟柯里化的解释一样：用一些参数，剩下的函数作为返回值里的函数的参数。这样我在调用的时候怎么调用：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var scrollTop &#x3D; Nlvi.tools.scroll(window);scrollTop(function(sct) &#123;&#125;);</code></pre><p>首先我给个变量（实际上ES6直接用<code>const</code>，毕竟固定量）引用这个方法，方法传入第一个参数。接着里面的函数返回值函数是接收一个函数变量。</p><p>理一下，函数 - 的返回值 - 是个函数，这个函数接收一个 - 函数 - 的 - 变量。</p><p>然后这个函数参数传进去之后，实际上就是传一个方法进去以便于我等下里面的逻辑走完之后可以把这个函数参数运行起来，行程一个特别做作的回调函数。（当然回调函数带的是当前滚动条的数据）</p><p>为什么这么做呢？一点就是我觉得这样思路就清晰多了，而且在调用区域写起来干净。第二点就是参数复用。</p><p>虽然这个例子看不出什么，但是难免会遇到一些情况，就是明明一个变量或者一个参数，我只要取一次然后调用一次之后，剩下的内容我只要在这个情况之上去处理就行。但是如果传统单函数的做法的话，就会使得这个局外参数也跟着在里面做一些乱七八糟的运动，比如跟着去递归，被扯着去多次判断，这样就会莫名其妙浪费了一堆性能。很简单我举个例子：4x100，明明你交接之后剩下的就接下来的人跑就行了，你非得交接之后跟着跑，边跑边喊加油？</p><p>第三点就是延时</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var total &#x3D; 0&#x2F;&#x2F; normalvar nSum &#x3D; (num) &#x3D;&gt; &#123;  total +&#x3D; num&#125;&#x2F;&#x2F;curryingvar cSum &#x3D; (fn) &#x3D;&gt; &#123;  var nums &#x3D; []  return function() &#123;    if (!arguments.length) &#123;      return fn.apply(null, nums)    &#125;    Array.prototype.push.apply(nums, arguments)    return this  &#125;&#125;var sum &#x3D; cSum((x) &#x3D;&gt; total +&#x3D; x)</code></pre><p>如果是常规的话，那么肯定会立刻计算出结果，而柯里化之后，会把计算的步骤储存起来，然后一起计算。</p><h2 id="柯里化误区">柯里化误区</h2><p>在写这篇东西的时候，我关注到了一尊大神的博客 <a target="_blank" rel="noopener" href="http://www.cnblogs.com/pengchen/p/5434705.html">JavaScript函数柯里化的一些思考</a>，吓得我赶紧回看了自己的函数有没有“画蛇添足”的成分。嗯。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 拿下来继续学习一下var scrollTop &#x3D; Nlvi.tools.scroll(window);scrollTop(function(sct) &#123;&#125;);</code></pre><p>这里我想到的是，我只需要把<code>window</code>传到这个函数之后引用出一个新函数，然后我就可以带着这个函数跑了，如果是不嫌麻烦版本的话我需要则么做？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">tools.scroll &#x3D; function(win, fn) &#123;  return $(win).scroll(function() &#123;    var sct &#x3D; $(win).scrollTop();    fn&amp;&amp;fn(sct)  &#125;)&#125;&#x2F;&#x2F; and sotools.scroll(window, function() &#123;&#125;)</code></pre><p>这样就会造成，我每次想监听滚动的时候，每用一次这个方法，我就要把<code>window</code>传进去一次。如果包一下的话，我就可以拿后面那个函数走就行了，也就是我的<code>window</code>只要传一次就畅通无阻。这也是另一个好处：分段计算。好比我玩Switch，我在外面突然想玩马车的时候，如果我的卡带在卡包里，那我换上就可以玩了，就不需要等回到家把卡带从包装盒里拿出来装到机器上。</p><p>实际上到这里的话应该有所经验了，到这里还会不会觉得<code>apply(), call(), bind()</code>使用机会少之又少？这就是数学的魅力吧，可是我数学不好。</p><h2 id="柯里化-闭包函数？">柯里化 &lt; - &gt; 闭包函数？</h2><p>又是每期一问了，柯里化跟闭包函数是否也有关系？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 经典面试题for(var i&#x3D;0;i&lt;2;i++)&#123;      (function(i)&#123;             setTimeout(function()&#123;              console.log(i);        &#125;,0)    &#125;)(i);&#125;</code></pre><p>那么，柯里化函数和闭包函数应该怎么区分？还是的确有联系？</p><p>最后感谢所有被引用的文章及其作者，感谢帮助学习。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 函数式编程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我还在用Console.log()？</title>
      <link href="/blog/2017/11/20/js-console/"/>
      <url>/blog/2017/11/20/js-console/</url>
      
        <content type="html"><![CDATA[<blockquote><p>也许主题应该改为：你只会使用Console.log()？</p></blockquote><p>现在的前端虽说是越来越复杂，但是我怎么觉得现在前端的要求越来越低了？应该说现在的人，看个几遍vue，知道console.log()，知道var, {}, []，就敢出来找工作了。但是<code>console</code>就这么个方法？</p><p>搞笑，你在你的浏览器输入<code>console</code>，自己看看有多少东西！所以为了高效调试我觉得有必要全了解一遍。</p><span id="more"></span><h2 id="log-info-error-warn">log(), info(), error(), warn()</h2><p>这几个放在一起讲</p><blockquote><p>log() 普通输出</p></blockquote><p>这是最普通，最常见，最没什么东西好讲的。输出的样式是普通样式。</p><blockquote><p>info() 提醒输出</p></blockquote><p>这是一个早期chrome才能看到的效果，现在的FireFox也能看到，是一个圆形中间一个叹号的标记。作提醒作用。chrome不是不会显示，是显示成普通样式。</p><blockquote><p>error() 错误输出</p></blockquote><p>这个应该跟<code>log()</code>同个使用数量级的，表示错误，大红颜色。chrome表现是一整行都是红色的，很显眼。用来显示错误信息。比如throw 错误之类的。如果一套都是<code>log()</code>的话肯定很难一眼看到错误。珍爱视力，路还长着…</p><blockquote><p>warn() 警告输出</p></blockquote><p>就是警告咯，可能用的比较少，但是工具类和一些库肯定会容易看到，原来跟<code>info()</code>平起平坐，现在应该是替代了。显示效果会显眼的黄色，chrome会有黄色背景。</p><blockquote><p>debug() 调试输出</p></blockquote><p>这个就是<code>log()</code>，用来输出调试信息的。不过现在的调试信息都在花式<code>log()</code>，也不需要用到这个了。</p><h2 id="exception-debug">_exception(), debug()</h2><p>这组只有两个，因为这两个没卵用…为什么…</p><blockquote><p>_exception() 例外输出</p></blockquote><p>说白了就是用来输出错误的，那错误不能用<code>error()</code>吗？！</p><blockquote><p>debug() 调试输出</p></blockquote><p>早期可能还有区别，但是这就是一个<code>log()</code>，不过现在各前端都在花式<code>log()</code>调试信息，可能也有些人<code>debug()</code>都没听说过。</p><h2 id="assert-…-clear-count">assert(…), clear(), count()</h2><p>为什么第一个函数搞了三个点？</p><blockquote><p>assert() 断言输出：判断第一个参数是否为真，false的话抛出异常并且在控制台输出相应信息。——MDN</p></blockquote><p>从这里开始就要骚了，这是一个判断的方法，里面需要填写参数，然后得到返回值。如果值为真，就什么都不会发生，反之则以<code>error()</code>通知你。这是个多参数的，除了第一个参数之外，后面接的参数是被输出的对象也好，字符串也好，并且会拼接。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.assert(1&gt;2, &quot;你这么骚的？&quot;)Assertion failed: 你这么骚的？ &#x2F;&#x2F; 假装这里是红字红色背景</code></pre><blockquote><p>clear() 清空控制台</p></blockquote><p>就是把控制台全清空，terminal里面的<code>clear</code></p><blockquote><p>count() 次数输出：以参数为标识记录调用的次数，调用时在控制台打印标识以及调用次数。——MDN</p></blockquote><p>并且MDN明确指出，这个不应该列入正常使用范围，因为这是非标准方法。这是这组里最骚的方法。用来输出本身被调用了几次…虽然如果测试循环的话，一般都直接log(i)的，直接看1234567不是更明确嘛。显示效果就是，每运行一次就会在控制台打印 n + 1。</p><h2 id="dir-dirxml">dir(), dirxml()</h2><p>这两个一起说是因为，有相同点和不同点。</p><blockquote><p>dir() 对象结构输出</p></blockquote><blockquote><p>dirxml() 节点结构输出</p></blockquote><p>这两个都是输出一个树状结构，就是前面有个小三角。但不同点就是，<code>dir()</code>是把一个对象按照对象的形式呈现，当然用来输出节点就是把节点信息按object呈现。<code>dirxml()</code>是把节点呈现出来，就还是保留xml的样式呈现。都是非标准，偶尔用用还行？</p><h2 id="group-groupCollapsed-groupEnd">group(), groupCollapsed(), groupEnd()</h2><p>这是上面那组的正房版。都是打印结构。我就不一行一行解释了有点累…</p><p>第二跟第一都是打印树状结构，但是第一个会自动打开显示结构里面有什么结构（没问题的），第二个叫内联树状，默认不打开。</p><p>而且只要你不结束，你可以一直联下去的，这样一个父节点可以一直续下去…直到通过<code>groupend()</code>来结束。</p><h2 id="table-…">table(…)</h2><p>我必须强调！<strong>这是最棒的我最喜欢的console方法，没有之一！</strong></p><blockquote><p>table() 表格输出</p></blockquote><p>这个方法必须传入内容，内容的类型是array或者object，输出的样式是一个key:value的表格！如果你觉得输出成对象不方便检查的话，那就用<code>table()</code>吧！（当然在表格下方还是会return一次对象或者数组）</p><p>而且不仅是key:value，<strong>你甚至还能多元数组！对象套对象！甚至是JSON！</strong></p><h2 id="另外的技巧就是可以用占位符了">另外的技巧就是可以用占位符了</h2><p>跟C语言的<code>printf()</code>没有区别，就是可以利用占位符然后再把参数接在后面。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">console.log(&quot;%d年%d月%d日&quot;,2017,11,20)</code></pre><p>最后感谢MDN，也感谢AlphaGo！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>引用等于指针吗？</title>
      <link href="/blog/2017/10/17/reference-equal-pointer/"/>
      <url>/blog/2017/10/17/reference-equal-pointer/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一篇思考文，关于JS的reference和Go的指针。（臆想型论文？）</p></blockquote><p>最近投入大量时间接触<code>Golang</code>，了解“指针”的时候，想起了以前学习C语言时对“指针”的疑问：指针是什么。</p><p>以前还小不理解指针和野指针，只知道野指针会出现内存溢出或者值不正确的情况。而且网上大多讲指针的文章看起来都很难。就像现在的知乎：一句话能说清楚的东西恨不得从它的诞生还是写起。就连LOL赛评也是这副P样。</p><p>以至于我后面对C语言没好感，对C++厌恶，对有“指针”的语言直接没兴趣。</p><p>在看到Go的指针的时候，我已经想放弃了。但是想回来，毕竟上一次接触指针已经6年了，也许现在看就能理解出什么呢。（过程中接触的OC根本不能算经验，因为当时完全就是靠抄靠背来写iOS应用，最后还是嫌弃OC麻烦进阶无法理解去学习了swift）</p><span id="more"></span><h2 id="Reference-Pointer">Reference == Pointer?</h2><p>以前看到什么内存地址啊，指向啊就已经乱了，满脑子都在想内存里面是什么样的，内存地址，寄存器又是什么东西。跟着官方教程走了一遍，了解到<strong>指针就是通过一个变量去指向一个有的变量或者说是对象，从而产生一种绑定。通过修改指针变量也可以达到修改本体的效果</strong>。</p><p>这让我想到JS，因为每天都在操作对象，知道：如果你要建立一个新的变量，比如<code>a = 1</code>，我可以通过<code>var b = a</code>得到一个新的变量。但是如果是对象则不是。如果是<code>a = &#123;&#125;;  var b = a</code>的话，b只是单纯指向了a，并没有复制a</p><p>所以我立刻去搜索<em>关于JavaScript的指针</em>。得到这么一个结果 <a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=2Xxo3-ptdvabLARr0p-DcoBbeysd2lvRxH-jEevvWHBJ7pNBk-mkxGqaB6h8UTWVRi-2lc56zjWVMYPUgv6tfK&amp;wd=&amp;eqid=e1820c9600002f360000000659e5b92d">JavaScript 的<em>指针</em>是什么? - 知乎</a></p><blockquote><p>JavaScript 里头什么时候有指针的概念？倒是有 reference （引用）的说法。 —— <a target="_blank" rel="noopener" href="https://www.zhihu.com/people/sansmana">陈木野</a></p></blockquote><p>关于this的总结，不单我自己，网络上已经大量的文章了。不管是详细解析，还是总结，都已经很多了。但是如果说：指针就是一种指向变量的话，那JavaScript就很多了，遍地都是。而这样的话，就跟reference有关系了。</p><p>说起来也是邪门了，今天打算把《红宝书》拿出来翻一下，翻到了第四章4.1.2，看到了这么一句</p><blockquote><p>当使用 num1 的值来初始化 num2 时，num2 中也保存了值 5。但 num2<br>中的 5 与 num1 中的 5 是完全独立的，该值只是 num1 中 5 的一个副本。</p><p>当从一个变量向另一个变量复制引用类型的值时，同样也会将存储在变量对象中的值复制一份放到<br>为新变量分配的空间中。不同的是，这个值的副本实际上是一个指针，而这个指针指向存储在堆中的一<br>个对象。复制操作结束后，两个变量实际上将引用同一个对象。</p></blockquote><p>于是我的想法 “引用是一种指针” 或许成立。（复习有好处的！）</p><h2 id="Point-Reference">Point == Reference</h2><p>如果反过来，还能成立吗？我觉得不行。</p><p>C++，让我很崇拜很信仰的，却因不理解和学不会让我产生厌恶的语言，在这方面是两者皆有。由于根本不懂所以不参加讨论。</p><p>Java，他也有reference，但是在<a target="_blank" rel="noopener" href="https://www.baidu.com/link?url=bI4EsfOKw8lfPjTwX3_gY7pbn2LFMOwmFPmoalBBNr7lFCv9ZltHfuravfoA7uVHrNJtSUxm0Epjk-IW5Zr2z_&amp;wd=&amp;eqid=ee91ddc5000508bd0000000659e60253">Java的<em>Reference</em>感觉很象C++的<em>指针</em>,但是区别是本质的 - f…_博客园</a> 提到：</p><blockquote><p>Java中你无法对这个地址进行任何数学运算，并且这个地址你不知道，是Java Runtime分配给你的，它随时还要调整这个地址（After GC,Memory要Compact，这时候一个Object Reference的地址就会改变）。</p></blockquote><p>我不是很理解，所以我也不敢评论什么。我只想关于Go和JS的东西。</p><p>也许是心理隔阂，也许是真理。我怎么都想不出怎么让“指针是一种引用”成立。</p><p>老是想内存内存，不如想成一个盒子，指针就是给盒子里的东西连了一条线。这样做就不用我找这个东西的时候去盒子里找，而是直接去找这条线？</p><p>可是在JS中，引用也不能修改和做任何运算吗？</p><h2 id="Reference-Pointer-2">Reference === Pointer?</h2><p>我不是语言专家，我一点都不敢保证。或者说我不懂。</p><p>我不知道所谓的指针是什么东西，但是我知道<code>reference</code>是一个<code>object</code>，毕竟不知道哪篇文章写道：函数是JavaScript第一公民。但并不是很纯的函数式编程语言。</p><p>其实思考到现在，我又有新的问题了：<strong>前端语言，或者说函数式编程语言，有没有内存，指针一说？</strong></p><p>不过现在可以知道的是：</p><p>​在指令式编程中，数值就是数值，一切工作之后无非就是想得到一个值，过程中也在围绕着值。</p><p>​在函数式编程中，函数还是占主要地位，它需要以数学的方式去解决编程的问题。</p><p>那我现在可不可以有一种新的理解：</p><p>​比如C语言这种，他定义指针是需要 <code>*</code> 这种东西，也就是<code>int *a = b</code>是用a指针指向b，我可以通过a来修改b。但是如果直接<code>int a = b</code>的话，我就相当于复制了这个变量了，没权修改b变量了。而如果<code>int a</code>是一个函数的话，那它最后也需要返回一个<code>int</code>返回值。所以它并没有“用函数搞事”的权利。</p><p>​而JS语言这种，我想用一个代码框来写：</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#x2F;&#x2F; 还是根据红宝书的例子var a &#x3D; 5;var b &#x3D; a;&#x2F;&#x2F; 一种复制，相互独立var x &#x3D; &#123;a: 5&#125;var y &#x3D; x&#x2F;&#x2F; 一种引用，实际上操作y的时候还是在操作x&#x2F;&#x2F;现在暂时借用一下以 _ 代替*var o &#x3D; &#123; a: 5 &#125;var _b &#x3D; o.a&#x2F;&#x2F; 达到继承的目的？&#x2F;&#x2F; var _b &#x3D; int *b   在某种意义上？</code></pre><p>在红宝书接下来有一句：</p><blockquote><p>换句话说，obj1和 obj2 都指向同一个对象。这样，当为 obj1 添加 name 属性后，可以通过 obj2 来访问这个属性，<br>因为这两个变量引用的都是同一个对象。</p></blockquote><p>按我的角度翻译一下，就是：<strong>我定义一个b出来，无非就是给a多了一个出口</strong></p><p>所以综上所述，我认为，对我来说，或者对C系除外的语言来说，<strong>把“指针”说成“指向”，或许让人更好理解。</strong></p><p>哼，计算机真是有趣。</p><p>（最后感谢所有被引用的文章和作者，谢谢。）</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>使用桌面应用写hexo博客是什么体验？</title>
      <link href="/blog/2017/09/19/what-the-feeling-about-hyper/"/>
      <url>/blog/2017/09/19/what-the-feeling-about-hyper/</url>
      
        <content type="html"><![CDATA[<blockquote><p>稳的稳的，这次真是为了需求造轮子了。Hyper = Hexo + Typer.</p></blockquote><p>接触到hexo是因为，hexo可以是一个前端博客生成器，直接生成一个前端静态页面，做到可以上传到github“个人页面”作为博客网站。</p><p>不过，毕竟是基于<code>node</code>的生成器，编写过程很geek。首先创建和预览甚至发布，依赖<code>terminal</code>和<code>node</code>。你要使用一个你喜欢的<code>markdown</code>编辑器，或者直接就在代码编辑器搞例如<code>vscode</code>。原来我也是用这个写博客。因为自带了<code>terminal</code>，直接创建了搞完直接上。后来生活逐渐好点，用的 iterm2 + zsh 之后，编辑器改用了<code>Typora</code>。然而关于这段的话，我上一篇<a target="_blank" rel="noopener" href="http://blog.co1mugx.tk/2017/08/22/do-markdown-hexo/">搞electron+vue+webpack2+TypeScript什么体验</a> 已经讲得够多了，所以不赘述了。</p><p>但是现在，可能生活会更好了…</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/1.png" alt=""></p><span id="more"></span><h2 id="为什么？">为什么？</h2><p>这是个<code>electron</code> + <code>Typescript</code> + <code>vue</code>的产物。也就是首先它是桌面应用了，由于<code>electron</code>意味着它可能可以跨平台。不过我没有想过…所以现在是 MacOS 版本。</p><p>为什么想起写这个，原因就两点</p><ul><li>原来的方式太过于繁琐，甚至感觉不到自己是在写博客。</li><li>对计算机理解和操作都不是顺畅的人会带来很多麻烦。</li></ul><p>博客博客，文字记录自己的生活或者技术探讨。多少写手或者说喜欢分享的人，喜欢hexo又不会用没办法用。当分享被技术限制之后，那么写文章也就不是专注于文章了。（比如我写文章也一直很跳，跟性格有关吧）</p><p>所以我才想要实现这么个东西，实际上在早之前就已经打算了，当时前端太菜。也不知道<code>electron</code>是什么东西。还是个<code>swift</code>新教徒的时候。有想过用MacOS 原生的方式去做这个东西，后来放弃了，原因还是因为技术上的问题。</p><p>这次实现这个东西的时候，巧了，跟<a target="_blank" rel="noopener" href="http://www.ahonn.me">@Ahonn</a>几乎不约而同的想到了一起。他也说他很早就想做了，不过大神不是因为技术原因，而是开坑不填工期延后…</p><p>不过他的实现方式是不同的，他想使用<code>cljs</code>去实现这个东西。我为了求稳，还有还是熟悉一下<code>TypeScript</code>作为脚本使用的感觉，用了这么套技术栈。</p><p>Ahonn的项目地址是这个：<a target="_blank" rel="noopener" href="https://github.com/ahonn/hexdit">ahonn / hexdit</a>。利益相关的话：还是算关系挺好的校友吧…</p><h2 id="怎么用？">怎么用？</h2><p>不搞事情，不吹牛逼，这次为了 <s>装逼</s> 测试一下软件大概“正常使用”有没有什么问题。所以这次我这篇文章完完全全使用<code>Hyper</code>创建、编写、保存、修改，甚至我等下生成发布也直接用这个。</p><p>确实，这才像在写博客。</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/2.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/7.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/9.png" alt=""></p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/10.png" alt=""></p><p>我甚至都不怕被你看！</p><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/5.png" alt=""></p><p>（因为编辑器的样式还有预览的样式还没上，所以现在看起来还是很丑的，不过测试功能嘛，我等下还会用其他编辑器看）</p><p>但不管怎么说！就是好看！<strong>简就是美！甚至还有点少女心！</strong></p><p>在首屏直接载入<strong>整个博客程序文件夹</strong>之后，就会到达这个界面，左边是显示你当前博客程序里面的文章（名字我都不怕给你看，这名字最后会显示到网址上！），文章列表上面三个按钮分别是 “创建”，“预览”，“生成/发布”。每一个文章名称前面一个“绿色的勾”是提醒你，当前这篇文章是可见的。没错文章可以是隐藏的，这在<code>hexo</code>的文档上有提到，<code>source</code>文件夹中不会上传文件名前带’_'的文件。所以自然可以过滤“草稿”和“不想发布”的文章。所以隐藏的文章会显示一个红色的叉。</p><p>点击想编辑的文章之后，其实会有动画回馈，但是不会常驻高亮。然后右边会跳出目前文章的内容以及一些编辑文章会用到的功能。实际上我应该做一个当前编辑文件高亮的！</p><p>右边编辑区中第一个“笔样子”的图标我是放着玩的…一些测试的工作会挂在上面当starter。然后保存和删除这个应该能看懂。右边有个开关，这个开关就是作为**“选择当前文章是否隐藏”**的作用。当然如果是<code>off</code>状态的话就是显示了，默认也是显示的。最右边的“X”就是关闭当前编辑区咯。</p><p>下面一整个编辑区，写文章可以用，不过<code>markdown</code>了，应该熟悉的是不会用到的吧，可能会用到两个功能：一个是全屏编辑，一个是分屏编辑。噢插入表格也可以有，<code>markdown</code>的表格真是蛋疼。</p><h2 id="另外还给对hexo不熟悉的写手准备了一个大功能。">另外还给对hexo不熟悉的写手准备了一个大功能。</h2><p><img src="https://github.com/ColMugX/GitBed/raw/master/hyper/3.png" alt=""></p><p>那就是简易设置了！漂不漂亮我不敢说！反正我就喜欢清静的感觉，看看<code>Nlvi</code>！是不是还有一股禅意！</p><p>截图的信息是我在做测试的时候，我当前导入的是当时用来测试主题功能的一个示例博客，官方提供的。毕竟不敢把自己的博客导入进去，万一弄瞎了不就真瞎了…</p><p>就我遇到的很多情况看，还是会有刚接触前端或者刚接触hexo的人不知道hexo的配置文件应该是怎么弄的。虽然我在<a target="_blank" rel="noopener" href="https://github.com/ColMugX/hexo-theme-Nlvi">hexo-theme-Nlvi</a>里面写到：如果主题有使用问题的话，你可以提ISSUE，或者直接到知乎上锤我！</p><p>但事实上，很多给我知乎发私信的同学，问的都基本不是主题使用的问题，反而是博客本身的使用问题。所以我重新整理了博客配置文件，并把一些比较重要的，必须要的功能作为一张设置界面出来，这样就方便使用了。只要这张填的满，按道理说博客的显示和发布就没问题了。</p><p>而且这张设置界面就这么多内容，在地址设置下面也就多了一个“文章代码是否高亮”和“部署地址”。这样而已。然后就可以保存完事。</p><p>由于还是在测试和进一步编写。所以一些难看的目前用不到的我都<code>display:none</code>了，所以看不到完整设置。</p><p>初来乍到，第一次写这种软件，还是有很多问题的。如果你看到问题了还希望你能帮我指正。我也是想服务一下社区，给喜欢但是不会用的人一点帮助。</p><h2 id="是什么？">是什么？</h2><p>其实介绍文章按正常来说到上面就结束了。这也是为什么 “是什么 -&gt; 为什么 -&gt; 怎么做”反而是这种顺序。</p><p>关于是什么，应该很多人都不愿意去关心了，这里是我想记录的一些心得和学习遇到的坑。</p>]]></content>
      
      
      <categories>
          
          <category> 动物园 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> electron </tag>
            
            <tag> TypeScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搞electron + vue + webpack2 + TypeScript什么体验</title>
      <link href="/blog/2017/08/22/do-markdown-hexo/"/>
      <url>/blog/2017/08/22/do-markdown-hexo/</url>
      
        <content type="html"><![CDATA[<p>本来是想放弃的，后来歪打正着，成功运行。最后搞一个ts类型的启动器，不想再懵了。</p><p><a target="_blank" rel="noopener" href="https://github.com/ColMugX/vue-ts-electron-starter">vue-ts-electron-starter</a></p><p>想看看原项目<code>electron-vue</code>有没有这个打算，没有的话自己fork个分支出来。这个将就。</p><p>这次搞这个项目目的就很明显了，想做一个Hexo博客的编辑器（没错就是我这个博客的核心）。Hexo的话，属于页面生成器类的博客系统。直接一套生成静态页面，然后随意访问。因为一整套静态页面故还是有人喜欢直接干一套SPA上去，体验也好。</p><p>其实搞这个，我去年就想搞了。可是去年的话，明显前端的技术都不扎实更别说搞了，当时的想法是写一个Mac App（我swift应该还行，随便写写问题不大。不过可能现在的话问题就大了）。不过就一直拖拖拖，导致swift3.0都有苗头了我还是没想写。而且关于如何操作terminal命令，还是个问题。</p><p>这次心就大了。搞了再说，搞一半不行了就让他荒了。以后想起来再搞，再搞的时候技术肯定又上涨。如果这波做成了，开源，我不管有没有人用，总有人喜欢用。</p><span id="more"></span><h2 id="讲在前面">讲在前面</h2><p>在这之前我用的是<a target="_blank" rel="noopener" href="https://github.com/CodeFalling/blog-admin">CodeFalling / blog-admin</a>。这是一个Emacs的插件，当然spacemacs也能弄来用一下。这是一个在github很活跃的大神写的（我经常看到，同时也是hexojs成员），也是很出名的Emacs教徒。不过据说他现在用的是webstorm + vim插件了…</p><p>当然今天不想吹Emacs，而且工作上我也不敢用Emacs，原因不说。</p><p>其实就是一直想做一个方便用一点的。在emacs之前我都是开一个terminal+一个编辑器来做的。在emacs之前是用<code>typora</code>和<code>vscode</code>做的。总这样不好吧太麻烦了。而且这东西又算刚需…所以算了，还是尝试一下吧，顺便把<code>electron</code>和<code>vuex</code>给学清楚了，而且顺便练一下<code>TypeScript</code>。</p><p>所以这次打算的技术选型是：</p><ul><li>TypeScript</li><li>electron</li><li>vue</li><li>vuex</li></ul><p>electron + vue环境的话，直接使用<a target="_blank" rel="noopener" href="https://github.com/SimulatedGREG/electron-vue">SimulatedGREG/<em>electron-vue</em></a>，这样<code>electron</code>，<code>vue</code>，<code>webpack</code>就都完成了。如果针对<code>TypeScript</code>的话<code>webpack</code>应该要小改一下。</p><h2 id="为什么使用TypeScript">为什么使用TypeScript</h2><p>TypeScript是微软开发的语言，由于师出同门所以跟<code>C#</code>的语法是极其像的，不过由于是<code>JavaScript</code>的超类，所以还会考虑到ES的语法。所以很早的时候<code>ES6</code>还没流行起来的时候，<code>TypeScript</code>已经开始使用像ES6一样的语法，并提供编译把TS的代码编译成ES5的代码，在没有<code>es6</code>和<code>babel</code>的世界，需要用JS来创造更强大的程序无疑是福音。</p><p>一开始看到的时候，我觉得JS也就那样了，还能怎样…到后来去接触的原因，是因为它的语法跟我先接触的<code>swift</code>很像，我觉得可能能通过TS学好swift或者说通过对swift的理解去学TS，反正都能编译成JS的嘛。</p><p>再后来就遇到了游戏，接触Unity3D的时候，最热门最成熟的语言是C#，而我当时是个软黑。转而让我发现了Egret，Egret竟然把TS作为开发语言，我就想要不把TS也弄清楚了，以后如果接触C#可能也不会太难。可是经过几轮跌爬滚打之后，我竟然放弃了…对这就是我小时候的不懂事…大学快毕业的时候几乎每天就在后悔，为什么当时不好好学TS，而在ES6789流行开的时代里，语法完整功能完善的TS优势也没有那么大了。现在浏览器都能直接用ES7了…</p><p>但是现在说没优势都是骗人的…如果你只是单纯用JS写的话，一如果出现类型错误，不好控制。二在万物都是函数的世界中，可能如果要实现一些其他功能，可能会考虑不周。即使能考虑到了，写上去。也会造成很大的工作量。但是TS编译器都替我们想好和做好了，为什么不去用？</p><p>所以，如果是应用开发的话，为什么不考虑应用级别的开发语言呢？我是这么想的。</p><p>如果是web，但是要强大的框架比如vue，reactjs，我会选择用JS。如果是需要更强大的能力和稳定、可控的app，我肯定是选择TS。</p><h2 id="干！填坑！">干！填坑！</h2><p>两点核心</p><ul><li><code>webpack</code>需要配置对<code>TypeScript</code>的编译。</li><li>从入口到组件都使用<code>TypeScript</code></li></ul><p>因为我也是误打误撞突然可以正常运行，所以我是开一个新的项目进行接下来的工作。 （结果发现并不是误打误撞，而是本来就是正确的，那么为什么会错误…）</p><p>首先npm安装<code>typescript</code>, <code>ts-loader</code>, <code>vue-class-component</code>，这三个都很重要。<code>typescript</code>提供的是语言支持，也可以说是提供内部编译，当然如果说你本身就全局装过了，那么你直接<code>link</code>就行了</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm i -S typescript ts-loader vue-class-component# ornpm i -S ts-loader vue-class-componentnpm link typescript</code></pre><p>然后是<code>webpack.renderer.config.js</code>，不出意外的话在<code>25:3</code>入口，<code>26:58</code>把<code>js</code>改成<code>ts</code>，下面的rule添加对ts的支持</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;test: &#x2F;\.ts$&#x2F;,loader: &#39;ts-loader&#39;,exclude: &#x2F;node_modules|vue\&#x2F;src&#x2F;, options: &#123;appendTsSuffixTo: [&#x2F;\.vue$&#x2F;]&#125;&#125;</code></pre><p>如果有需要<code>tslint</code>的话（说实话我还不会用…而且我觉得ts约束本来就很厉害了），需要安装</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">npm i -S tslint tslint-loader</code></pre><p>老位置</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">&#123;test: &#x2F;\.(ts)$&#x2F;,enforce: &#39;pre&#39;,exclude: &#x2F;node_modules&#x2F;,use: &#123;loader: &#39;tslint-loader&#39;&#125;&#125;</code></pre><p>第二，就是把关于<code>vue</code>部分的入口改成<code>main.ts</code>。这样接近完成。</p><p>第三，最重要的，<code>typescript</code>能不能用就靠这个了，<code>jsconfig.json</code></p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">tsc --init#通过tsc初始化得到</code></pre><p>至于怎么配置，<code>vue</code>官方也给了一个推荐配置，<code>vue-class-component</code>也给了一个。</p><p>但不管怎样，建议把<code>allowjs</code>打开了，可以调用<code>js</code>文件。</p><h2 id="开始填坑">开始填坑</h2><ul><li>入口必须是<code>.ts</code></li></ul><p>这点说起来很坑，TS的话，只要有<code>allowjs</code>就可以调用JS文件，运行是没问题的。但是反过来就不行了，毕竟超类能认，但JS根本不知道TS是个什么鬼，所以无法编译</p><pre class="line-numbers language-sh" data-language="sh"><code class="language-sh">Module build failed: Error: Could not find file: &#39;...*.ts&#39;# 或者Module build failed: Error: Could not find file: &#39;...*.vue&#39;</code></pre><p>所以必须是TS入口</p><ul><li>建议关于<code>script</code>部分分开写。</li></ul><p>当然是可以直接在<code>.vue</code>写你的逻辑的，不过为了防止<code>typescript</code>有小脾气，或者关于类型推断，总的来说就是为了编译少点麻烦吧，我觉得还是分开写是最保险的。当然在组件内写也不是不可以。</p><ul><li><code>vue-class-component</code>核心</li></ul><p>如果用了TS的话，那么漂亮的组件代码肯定就是<code>class</code>了，通过修饰<code>@component</code>声明该位置是一个组件，然后开始写组件代码，继承自<code>vue</code>，然后就可以像写一个程序类一样去写这部分组件。看起来是相当漂亮的。举个例子，在通过<code>electron-vue</code>创建出来的工程中，对实例组件<code>LandingPage.vue</code>进行改写</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">@Component(&#123;  name: &#39;landing-page&#39;,  components: &#123;    SystemInformation  &#125;&#125;)export default class LandingPage extends Vue &#123;  open (link) &#123;    (this as any).$electron.shell.openExternal(link)  &#125;&#125;</code></pre><p>漂亮，清晰。（当然复杂一点，就复杂了！）</p><ul><li>关于对Vue进行扩展</li></ul><p>在添加<code>axios</code>的时候我遇到了问题：无法扩展<code>Vue</code>，原因好像是无法推断<code>vue</code> 的类型。这个问题的话，我还得去研究一下。</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> vue </tag>
            
            <tag> electron </tag>
            
            <tag> editor </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript的call，bind，apply</title>
      <link href="/blog/2017/08/14/js-call-apply-bind/"/>
      <url>/blog/2017/08/14/js-call-apply-bind/</url>
      
        <content type="html"><![CDATA[<blockquote><p>联动水文，大约半年前记录了Javascript的this。顺水推舟理一下call()，bind()，apply()</p></blockquote><p>扩展阅读：<a href="https://colmugx.github.io/PersonalBlog/2017/03/03/js-this/">关于JavaScript的this</a></p><p>还是上次的代码，修改一下</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let test &#x3D; obj.getNametest()&#x2F;&#x2F;undefined.</code></pre><p>（敲黑板！）复习一下！为什么就<code>undefined</code>了！原因就是，<code>this</code>指向不同了。那么直接运行是否可以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;obj.getName()&#x2F;&#x2F;koala</code></pre><span id="more"></span><p>因为有时候并没办法这么自由的随便调用，那如果要搞个变量出来用，怎么做？</p><h2 id="call">call()</h2><blockquote><p><strong>call</strong></p><ul><li>vi. 呼叫；拜访；叫牌</li><li>vt. 呼叫；称呼；召集</li><li>n. 电话；呼叫；要求；访问</li><li>n. (Call)人名；(瑞典、罗)卡尔；(英)考尔<br>以上来自有道翻译</li></ul></blockquote><p>有一手有道翻译就方便了，就是call（叫）它，把要用的方法call（叫）出来。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let cal &#x3D; obj.getName&#x2F;&#x2F;先定义出来cal.call(obj)&#x2F;&#x2F;koala   （指向还给他，不动其他把它叫出来</code></pre><h2 id="apply">apply()</h2><blockquote><p><strong>apply</strong></p><ul><li>v.应用；使用；涂；敷</li><li>Web申请；适用；套用<br>以上来自bing词典，感谢微软爸爸</li></ul></blockquote><p>再来一手必应翻译简直就是，不谈了！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let apy &#x3D; obj.getName&#x2F;&#x2F;这手还是不变apy.apply(obj)&#x2F;&#x2F;koala  （可以说不是指向还给他，这不是假装了，而是直接套用</code></pre><p>有人要问，那你这手跟<code>call()</code>不是一样的么，为什么要区分开来。这个问题<a href="/2017/08/14/js-call-apply-bind/#call-%E5%92%8C-apply-%E5%8C%BA%E5%88%AB">下面再讲</a></p><h2 id="bind">bind()</h2><p>是不是以为我要用百度翻译了？我偏不！</p><blockquote><p><strong>bind</strong></p><p><strong>n.</strong> 窘境；讨厌的事情；捆绑；植物的藤蔓<br><strong>v.</strong> 捆绑；约束；装订；（使）结合；使关系密切<br>以上来自沪江小d，我学日语就靠它</p></blockquote><p><s>顺便，请以上三家公司尽快给我打钱，谢谢合作。</s></p><p><code>bind()</code>有点土匪的意思，它就是想抢走你老婆借用一晚的意思。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let bid &#x3D; obj.getName&#x2F;&#x2F; [Function: getName]          (这手还是不变&#x2F;&#x2F; 接着这样做，把this指向回去，变成一个可以自由操作的变量bid &#x3D; bid.bind(obj)&#x2F;&#x2F; [Function: bound getName]bid()&#x2F;&#x2F; koala   （这样才会运行，因为刚刚只是抢过来了</code></pre><h2 id="call-和-apply-区别">call()和#apply()区别</h2><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;    return this.name    &#125;&#125;let cal &#x3D; obj.getNamecal.call(obj)&#x2F;&#x2F;koalalet apy &#x3D; obj.getNameapy.apply(obj)&#x2F;&#x2F;koala</code></pre><p>说是这么说了，可是，他们并不是说就这么改变<code>this</code>方向然后就没什么用处了啊，可以借用<code>call()</code>和<code>apply()</code>传参数的。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName(param1, param2) &#123;    return this.name + &#39; params: &#39; + param1 + param2    &#125;&#125;let cal &#x3D; obj.getNamecal.call(obj, 1, 2)&#x2F;&#x2F;koala params: 12</code></pre><p>那么<code>apply()</code>就有区别了？哎！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let apy &#x3D; obj.getName&#x2F;&#x2F;这手还是不变apy.apply(obj, [1, 2])&#x2F;&#x2F;koala params: 12</code></pre><p><code>apply</code>后面接参数，只接受数组，<code>call</code>的话按顺序怼进去就行了。就这点区别。</p><p>暂时先这样，以后更深入的使用再深入的理解一下。现在大概就用到这些。</p><p><strong>下一篇，讲Javascript的柯基化！</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于JavaScript的this</title>
      <link href="/blog/2017/03/03/js-this/"/>
      <url>/blog/2017/03/03/js-this/</url>
      
        <content type="html"><![CDATA[<blockquote><p>一次被this支配之后的思考</p></blockquote><h2 id="开门见山">开门见山</h2><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        return function() &#123;            return this.name        &#125;    &#125;&#125;console.log(obj.getName()())    &#x2F;&#x2F;undefined.</code></pre><p>题目这样，我第一次回答的是<code>koala</code>。现在想了一下，估计是满脑子想吃波星冰乐给冲昏了脑子。<br>如果我改下！</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        let that &#x3D; this    &#x2F;&#x2F;this -&gt; that        let name &#x3D; &#39;koala&#39;        return function() &#123;            return that.name &#x2F;&#x2F;this -&gt; that        &#125;    &#125;&#125;console.log(obj.getName()()) &#x2F;&#x2F;koala&#x2F;&#x2F; 或者第二种，利用ES6let name &#x3D; &#39;panda&#39;let obj &#x3D; &#123;    name: &#39;koala&#39;,    getName() &#123;        let name &#x3D; &#39;koala&#39;        return () &#x3D;&gt; &#123;            return this.name        &#125;    &#125;&#125;console.log(obj.getName()()) &#x2F;&#x2F;koala</code></pre><h2 id="解题想法">解题想法</h2><p>我的理解，<code>this</code>其实跟其他语言的<code>self</code>应该是差不多。就是指代自己，比如说在一个<code>function</code>里面，那么<code>this</code>指向的就是这个func。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function colmugx() &#123;    &#x2F;&#x2F;do something.&#125;</code></pre><p>可能我讲的不清楚，就是<strong>this其实就是括号里的东西。</strong></p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function colmugx(&#x2F;** this *&#x2F;) &#123;    &#x2F;&#x2F;do somethings&#125;</code></pre><p>当然这是我的理解，我觉得应该就是这样的，所以刚刚那样取到的this并不是this。</p><h2 id="浅谈this">浅谈this</h2><p>只讲两种我懂的东西。</p><h3 id="跟着new走">跟着new走</h3><p>就是用new来创建对象的话，那么<code>this</code>就会跟着这个new</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;    constructor(name) &#123;        this.name &#x3D; name;    &#125;    func() &#123;        return this    &#125;&#125;let a &#x3D; new Animal(&#39;koala&#39;)console.log(a.name) &#x2F;&#x2F;koala</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">class Animal &#123;    constructor(name) &#123;        this.name &#x3D; name;    &#125;    func() &#123;        return this    &#125;&#125;let a &#x3D; new Animal(&#39;koala&#39;)console.log(a.func()) &#x2F;&#x2F;Animal &#123; name: &#39;koala&#39; &#125;</code></pre><h3 id="ES6中括号函数的this">ES6中括号函数的this</h3><p>括号函数的<code>this</code>，不存在的！</p><p>说是不存在，实际上并不是说真的不见了，而是它会绑定到上一层函数中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">func(()&#x3D;&gt; &#123;    &#x2F;&#x2F;do somethings.&#125;&#x2F;** ,this *&#x2F;)</code></pre><p>而如果不是括号的话</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">func(function(&#x2F;** this *&#x2F;)&#123;    &#x2F;&#x2F;do somethings.&#125;)</code></pre>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript所有for</title>
      <link href="/blog/2017/03/02/js-for/"/>
      <url>/blog/2017/03/02/js-for/</url>
      
        <content type="html"><![CDATA[<h2 id="先讲for">先讲for</h2><p>我觉得这应该是最古老而且实用性最强的for了，就是三段式定义。<code>for (;;)</code><br>想到当年考java编程基础的时候（一门学科），有一道手写题要用到循环，我抬手就是<code>for (var ...)</code>…</p><span id="more"></span><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i;i&lt;len;i++)</code></pre><p>其中不管怎样，常规for必须要两个;，因为就是这样，里面有三段式嘛。第一个是定义自走变量，第二个是条件，第三个是自加或自减。实际上for应该是这样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i;let len;i&lt;len;++i)</code></pre><h2 id="for…in">for…in</h2><p>这个在上次总结对象遍历已经提到了，它好像也就遍历对象用得多一点。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i in sth) &#123;&#125;</code></pre><p>不过<code>for in</code>的话，为什么说遍历对象比较多，其中一个除了好写~~（打死吧这人）~~，还有一点它只能用来遍历有key或者说是个index的东西，比如数组，它只能读到数组的index，那对象的话就直接读到键值咯。而且有一点的是，你读数组，<strong>读出来的index是个string不是number</strong>。这个要记得，因为js这种弱类型的东西，如果索引相加就变成字符串相加了……<strong>（我幼儿园就会20以内加减法了，1加2等于12)</strong></p><h2 id="forEach">forEach</h2><p>这个方法就不是古老的方法了，JS(ES5)版本的时候的，针对数组的一个方法</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">arr.forEach((i)&#x3D;&gt; &#123;&#125;)</code></pre><p>这种遍历的话，你遍历完直接能把数据处理掉最好，因为如果不是的话就麻烦了…它并不是一个开放的遍历，而是借用的闭包函数做的遍历。可以看成是<code>arr.func()</code>，它是一个数组方法，传进去一个<code>callback</code>，那就厉害了啊，闭包一个特点就是保护变量避免污染啊，变量保护是双向的啊…进得去出不来… （所以我的微信小程序openradio有用到计数器的时候不敢用这个，而且这个方法也是针对数组才能用的）</p><h2 id="for…of">for…of</h2><p>这是ES6的新东西，它比<code>for in</code>遍历的更多，没有<code>for (;;)</code>复杂，对比<code>forEach</code>它是开放的不是闭包，也就是那些条件控制流什么的都可以操作。</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i of arr)</code></pre><p>可是不止，好像还可以</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">for (let i of &#39;colmu&#39;) &#123;    console.log(i)  &#x2F;&#x2F;&#39;c&#39;\n &#39;o&#39;\n &#39;l&#39;\n &#39;m&#39;\n &#39;u&#39;\n&#125;</code></pre><p>不过它不能遍历对象！不能遍历对象！不能遍历对象！而且错误信息<code>TypeError: str[Symbol.iterator] is not a function</code>。所以这里我不行不BB了。</p><blockquote><p>所有实现了[Symbol.iterator]接口的对象都可以被遍历。</p></blockquote><h2 id="for-in-和-for-of-对比">for in 和 for of 对比</h2><p>一个栗子就能锤到头皮发麻</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let arr &#x3D; [6,6,4,2,8]for (let i in arr) &#123;    console.log(i)  &#x2F;&#x2F; 0,1,2,3,4&#125;</code></pre><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">let arr &#x3D; [6,6,4,2,8]for (let i of arr) &#123;    console.log(i)  &#x2F;&#x2F;6,6,4,2,8&#125;</code></pre><h2 id="summary">summary</h2><p>光说区别不行，我要讲怎么用！</p><p><s>万能膏药<code>while</code></s> （不对走错片场…）</p><p>万能膏药<code>for (;;)</code>：这是怎样都能用的，不过就是长了点，但是定义细了多。</p><p>数组专利<code>forEach</code>：数组的方法，只能用在数组。</p><p>能用在数组的：<code>for</code>, <code>forEach</code>, <code>for in </code>, <code>for of</code></p><p>能用在找头的：<code>for in</code></p><p>只要支持[Symbol.iterator]要什么找什么的：<code>for of</code></p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>来搞一手关于Javascript对象继承</title>
      <link href="/blog/2017/02/22/js-extends/"/>
      <url>/blog/2017/02/22/js-extends/</url>
      
        <content type="html"><![CDATA[<blockquote><p>小爝（知乎用户）：js里面什么都是对象，所以你看单身狗学这个语言学的老快了。</p></blockquote><p>就前几天看到的答案，觉得对啊！js这种边缘OP的语言，你说它没对象它是可以有的，你说它是面向对象语言它不是。<br>所以来研究一手关于JavaScript的继承。研究过程用一下typescript（这个真有对象了）<span id="more"></span></p><h2 id="先看一下关于typescript的继承">先看一下关于typescript的继承</h2><p>看一下ts的类</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Parent &#123;    name: string    age: number    constructor(msg:string, age:number) &#123;        this.age &#x3D; age        this.name &#x3D; msg;    &#125;    sayHello() &#123;        return console.log(&#96;hello $&#123;this.name&#125;,now is $&#123;this.age&#125;&#96;)    &#125;&#125;</code></pre><p>然后来一手调用，全程感觉像在用<code>java</code></p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">let par &#x3D; new Parent(&quot;mike&quot;, 16)par.sayHello()      &#x2F;&#x2F;hello mike,now is 16</code></pre><p><strong>答案我在terminal验证过的没问题！！</strong></p><p>接下来尝试一下如果我走继承会是什么样，来一手继承</p><pre class="line-numbers language-typescript" data-language="typescript"><code class="language-typescript">class Parent &#123;    name: string    age: number    constructor(msg:string, age:number) &#123;        this.age &#x3D; age        this.name &#x3D; msg;    &#125;    sayHello() &#123;        return console.log(&#96;hello $&#123;this.name&#125;,now is $&#123;this.age&#125;&#96;)    &#125;&#125;&#x2F;&#x2F;Now extends.class Son extends Parent &#123;    constructor(msg, age) &#123;        super(msg, age);    &#125;    sayHello() &#123;        console.log(&#96;hello I&#39;m Son. next is my Parent&#39;s say&#96;)        super.sayHello()    &#125;&#125;</code></pre><p>来手调用验证结果</p><pre class="line-numbers language-csharp" data-language="csharp"><code class="language-csharp">let sapi &#x3D; new Son(&#39;peanut&#39;, 10)sapi.sayHello()  &#x2F;&#x2F;hello I&#39;m Son. next is my Parent&#39;s say\n hello peanut,now is 10</code></pre><h2 id="该研究JavaScript的继承了">该研究JavaScript的继承了</h2><p>先来看一下第一个例子翻译成ES5(JavaScript)是什么样的</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var Parent &#x3D; (function () &#123;    function Parent(msg, age) &#123;        this.age &#x3D; age;        this.name &#x3D; msg;    &#125;    Parent.prototype.sayHello &#x3D; function () &#123;        return console.log(&quot;hello &quot; + this.name + &quot;,now is &quot; + this.age);    &#125;;    return Parent;&#125;());var par &#x3D; new Parent(&quot;mike&quot;, 16);par.sayHello();</code></pre><p>首先是建立了个函数，函数内再嵌套一层函数，然后通过内部的<code>prototype</code>添加一个方法，最后返回整个父函数。<br>燃鹅在这个函数内部已经做了一次叫“原型链继承”的事情了。就是从父级，或者说从其他原型来指向到继承的实例来达到元素一并继承，这样我要实现后面的实例的时候就要连带前面的也一并执行了。</p><p>然后第二个例子，多了个继承</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">var __extends &#x3D; (this &amp;&amp; this.__extends) || function (d, b) &#123;    for (var p in b) if (b.hasOwnProperty(p)) d[p] &#x3D; b[p];    function __() &#123; this.constructor &#x3D; d; &#125;    d.prototype &#x3D; b &#x3D;&#x3D;&#x3D; null ? Object.create(b) : (__.prototype &#x3D; b.prototype, new __());&#125;;var Parent &#x3D; (function () &#123;    function Parent(msg, age) &#123;        this.age &#x3D; age;        this.name &#x3D; msg;    &#125;    Parent.prototype.sayHello &#x3D; function () &#123;        return console.log(&quot;hello &quot; + this.name + &quot;,now is &quot; + this.age);    &#125;;    return Parent;&#125;());var Son &#x3D; (function (_super) &#123;    __extends(Son, _super);    function Son(msg, age) &#123;        return _super.call(this, msg, age) || this;    &#125;    Son.prototype.sayHello &#x3D; function () &#123;        console.log(&quot;hello I&#39;m Son. next is my Parent&#39;s say&quot;);        _super.prototype.sayHello.call(this);    &#125;;    return Son;&#125;(Parent));var sapi &#x3D; new Son(&#39;peanut&#39;, 10);sapi.sayHello();</code></pre><p>有点厉害，我先坐下来……</p><p>先是构造了个链子，然后（那个是闭包污染处理嘛…）…… 说不清了……</p><p>反正看子类，很明显在“Son类”结束前，有一个<code>(Parent)</code>，虽说ts对于类的处理都是一个大个的及时运行函数，但是&quot;parent&quot;运行时并没有带参数，而&quot;Son&quot;带了它的爹，如果我的理解的是对的的话，就是&quot;Son&quot;在运行的时候把&quot;Parent&quot;带着运行一次起到“继承”的效果。最后还是照原型链的理解。</p><h2 id="关于JavaScript的其他继承">关于JavaScript的其他继承</h2><p>还是因为我的爬虫小记中的现世界宝可梦数量及其名字的项目中，用到了<code>.call(this)</code>这个函数句。所以在想，是否可以使用构造函数走一波继承？</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">function a() &#123;    return console.log(&#39;this is a&#39;)&#125;function b() &#123;    a.call(this)&#125;</code></pre><p>然后调用</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript">b()     &#x2F;&#x2F;this is a</code></pre><p>所以也是可以的。结束！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自己造轮子！—— Syuanpi.css</title>
      <link href="/blog/2017/02/13/syuanpi-css/"/>
      <url>/blog/2017/02/13/syuanpi-css/</url>
      
        <content type="html"><![CDATA[<p>本来首发知乎，再说了现在这东西又不需要怎么用了，各种前端框架各种自动化，这些东西早就带得干干净净了。<br>这是demo的页面：<a href="https://colmugx.github.io/Syuanpi.css">Syuanpi.css</a><br>这是GitHub的页面：<a target="_blank" rel="noopener" href="https://github.com/ColMugX/Syuanpi.css">ColMugX/Syuanpi.css: ✨A library of CSS animations.</a></p><p>说到CSS动画库，其实有一个很出名很好用，“就像喝水一样简单”的叫做Animate.css的开源库子。那些动画真的挺炫酷的。然后我就想起，我自己在玩Hexo主题的时候不是动画也是自己写么，那要不把用过的动画自己封装起来，然后再加点跟自己脑洞产物的动画，然后自己也做一个库试试？然后我就把Syuanpi.css弄出来了…作为练习产物，日后想到什么好玩的实现方式也是会一直加一直加~ 不过我要说实话：不排除把Animate.css出现的部分动画自己再实现一遍进自己库子！</p><h2 id="为什么要出这东西…">为什么要出这东西…</h2><span id="more"></span><p>在知乎看了一段时间了认识了kpi这东西，觉得这东西好坑啊233，导致我现在觉得kpi的意思就是：有现有轮子不要用！不管怎样自己用的东西能做成轮子就给它做成轮子！然后再用自己的轮子！然后kpi就啪啪啪的往上走！不过这库子我的出发点还是想把我原来弄的一些基础的动画归类起来，加上自己比较会常用的操作封装起来，仅此而已。<br>在知乎学习的过程，就有一个关于没工作经验然后怎么面试的问题。就有提到关于自己开源自己的代码，不是不负责任的像托管作业一样把乱七八糟的东西放上去然后就说“噢！劳资也有开源”这样，至少要有一个给人一种便捷操作，要有头有尾，还要会写文档，不会写给个README也行。然后我也没经验，就听话这么做了…</p><h2 id="它是个什么东西…">它是个什么东西…</h2><p>好了说回来我的东西~ Syuanpi意思很简单，我喜欢它日后可以炫得一批233。但是它并不炫，而是一些很基础很基础的动画用法。不过，一些稍微认真的网站不就要点轻转场就行了嘛。比如我觉得博客挺认真的，但是没有转场动画又觉得好干燥，所以我的大部分动画起始点都是基于在自己博客上面用。而且动画的过程速度和位置全靠目测！不会计算也是硬伤呀…用的是stylus，不知道为什么总觉得那个被那个绿色的长的 ∮ 撩到了，然后就这么用了。<br>认认真真做作业，不要搞什么大新闻。就像标题说的，针对自己脑洞的产物。不过由于是自己第一次比较成型的“自己的作业自己做”，我还是好高兴的。如果有人愿意给star就更好了，还没体验过被5个star砸死是什么感觉呢~（不贪心的好孩子~）<br>嗯！该讲说明书了！<a target="_blank" rel="noopener" href="http://xn--GitHubREADME-bw5s79dg68csxgug160t3mxdzuve649b.md">大份说明书在GitHub的头页README.md</a>，所以就不讲了！</p>]]></content>
      
      
      <categories>
          
          <category> 编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Syuanpi </tag>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于微信小程序</title>
      <link href="/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/"/>
      <url>/blog/2016/10/28/guan-yu-wei-xin-xiao-cheng-xu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>向腾讯大佬低头！</p></blockquote><p><strong>说在前面，你们这下可不能说我这博客天天吹水不讲东西了！</strong></p><h2 id="说说这大佬又想干什么！">说说这大佬又想干什么！</h2><p>怎么说，腾讯微信真的是野心挺大的，要把微信做成一个应用平台<br>谁还能想的起来微信当时只是定位为一个低流语音信息的即时通讯工具啊！<br>小程序怎么定义呢，就是一个在微信启动的App<br>不过归根到底还是个Web App<br>那这么说来其实也可以说是一个以微信做壳的App了，相对于隔壁那个叫Ionic的东西来说。<br>不过怎么说，这小程序应该也是依托公众号来实现的吧，我看它文档都是在公众号里面。<br>先上地址：<a target="_blank" rel="noopener" href="https://mp.weixin.qq.com/debug/wxadoc/dev/devtools/download.html?t=1474887501214">下载链接</a><br>这开发工具原来就是一个chrome开发者工具，可能是因为加了小程序这么个东西，现在也有开发功能了<br>刚刚试用了一下，效！率！贼！差！（默默打开了Atom）<span id="more"></span></p><h2 id="这东西大概怎么写怎么用">这东西大概怎么写怎么用</h2><p>我粗略看了一下啊，这东西跟隔壁那些什么<code>angular</code>啊，还有<code>vue</code>啊什么都有点差不多，就是前后绑定然后做逻辑。<br>大概结构就是（不会用树形，随便看一下）</p><pre class="line-numbers language-none"><code class="language-none">- &#x2F; - pages     - index         index.js         index.wxml         index.wxss     - logs         logs.js         logs.json         logs.wxml         logs.wxss - utils     util.js app.js app.json app.wxss</code></pre><p><strong>这结果tm似曾相识啊！</strong><br>好了这就是个Web App，那讲一下那些文件干嘛的呗。<br>说到底还是个老biao子，js就不用说了（哎等下这东西好像还是得依托<code>NodeJs</code>啊，顺便说下我特别不喜欢<code>PHP</code>…）</p><p><code>wxml</code>:是个什么，wxml其实就是xml了，只是有点特殊的xml，可以理解成就是我们做ionic那个html吧<br><code>wxss</code>:卧槽了就是这个wxss！卧槽！挑白了说就是个CSS！不过在像素定义有点不同。引用一下</p><blockquote><p>尺寸单位<br>rpx（responsive pixel）: 可以根据屏幕宽度进行自适应。规定屏幕宽为750rpx。如在 iPhone6 上，屏幕宽度为375px，共有750个物理像素，则750rpx = 375px = 750物理像素，1rpx = 0.5px = 1物理像素。<br>设备rpx换算px (屏幕宽度/750)px换算rpx (750/屏幕宽度)<br>iPhone51rpx = 0.42px1px = 2.34rpx<br>iPhone61rpx = 0.5px1px = 2rpx<br>iPhone6 Plus1rpx = 0.552px1px = 1.81rpx</p></blockquote><p>所以官方说的是，<strong>“我们鼓励使用iphone 6 作为标准屏幕开发”</strong><br>原话是</p><blockquote><p>建议： 开发微信小程序时设计师可以用 iPhone6 作为视觉稿的标准。 注意： 在较小的屏幕上不可避免的会有一些毛刺，请在开发时尽量避免这种情况。</p></blockquote><p>（噢…是嘛…</p><p>另外最近在学Vue.js，估计跟玩小程序应该也会有点联系吧，就这样了剩下的日后再说。</p>]]></content>
      
      
      
        <tags>
            
            <tag> weapp </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
